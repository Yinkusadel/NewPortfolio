/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa";
exports.ids = ["vendor-chunks/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var {\n  _optionalChain\n} = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/.pnpm/@sentry+utils@8.17.0/node_modules/@sentry/utils/build/cjs/index.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst semanticConventions = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.25.1/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst utils = __webpack_require__(/*! @sentry/utils */ \"(ssr)/./node_modules/.pnpm/@sentry+utils@8.17.0/node_modules/@sentry/utils/build/cjs/index.js\");\nconst api = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core = __webpack_require__(/*! @sentry/core */ \"(ssr)/./node_modules/.pnpm/@sentry+core@8.17.0/node_modules/@sentry/core/build/cjs/index.js\");\nconst core$1 = __webpack_require__(/*! @opentelemetry/core */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+core@1.25.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst sdkTraceBase = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.25.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nconst instrumentation = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(ssr)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.52.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nfunction spanHasAttributes(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasKind(span) {\n  const castSpan = span ;\n  return !!castSpan.kind;\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasStatus(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasName(span) {\n  const castSpan = span ;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasParentId(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.parentSpanId;\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasEvents(\n  span,\n) {\n  const castSpan = span ;\n  return Array.isArray(castSpan.events);\n}\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nfunction getRequestSpanData(span) {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  const data = {\n    url: span.attributes[semanticConventions.SEMATTRS_HTTP_URL] ,\n    'http.method': span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD] ,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    const urlStr = span.attributes[semanticConventions.SEMATTRS_HTTP_URL];\n    if (typeof urlStr === 'string') {\n      const url = utils.parseUrl(urlStr);\n\n      data.url = utils.getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  return data;\n}\n\nfunction _optionalChain$8(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client with things we need for OpenTelemetry support.\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nfunction wrapClientClass\n\n(ClientClass) {\n  class OpenTelemetryClient extends ClientClass  {\n\n     constructor(...args) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n     get tracer() {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = core.SDK_VERSION;\n      const tracer = api.trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n     async flush(timeout) {\n      const provider = this.traceProvider;\n      const spanProcessor = _optionalChain$8([provider, 'optionalAccess', _ => _.activeSpanProcessor]);\n\n      if (spanProcessor) {\n        await spanProcessor.forceFlush();\n      }\n\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nfunction getSpanKind(span) {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return api.SpanKind.INTERNAL;\n}\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\nconst SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nconst SENTRY_TRACE_STATE_PARENT_SPAN_ID = 'sentry.parent_span_id';\nconst SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nconst SENTRY_TRACE_STATE_URL = 'sentry.url';\n\nconst SENTRY_SCOPES_CONTEXT_KEY = api.createContextKey('sentry_scopes');\n\nconst SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_isolation_scope');\n\nconst SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_scope');\n\nconst SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_isolation_scope');\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nfunction getScopesFromContext(context) {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) ;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nfunction setScopesOnContext(context, scopes) {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nfunction setContextOnScope(scope, context) {\n  utils.addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n * TODO v8: Use this for the `trace` functions.\n * */\nfunction getContextFromScope(scope) {\n  return (scope )[SCOPE_CONTEXT_FIELD];\n}\n\n/**\n *\n * @param otelSpan Checks wheter a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nfunction isSentryRequestSpan(span) {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return core.isSentryRequestUrl(httpUrl.toString(), core.getClient());\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nfunction parseSpanDescription(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n\n  // This attribute is intentionally exported as a SEMATTR constant because it should stay intimite API\n  if (attributes['sentry.skip_span_data_inference']) {\n    return {\n      op: undefined,\n      description: name,\n      source: 'custom',\n      data: {\n        // Suggest to callers of `parseSpanDescription` to wipe the hint because it is unnecessary data in the end.\n        'sentry.skip_span_data_inference': undefined,\n      },\n    };\n  }\n\n  // if http.method exists, this is an http request span\n  //\n  // TODO: Referencing `http.request.method` is a temporary workaround until the semantic\n  // conventions export an attribute key for it.\n  const httpMethod = attributes['http.request.method'] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name, kind: getSpanKind(span) }, httpMethod);\n  }\n\n  const dbSystem = attributes[semanticConventions.SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name });\n  }\n\n  // If rpc.service exists then this is a rpc call span.\n  const rpcService = attributes[semanticConventions.SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      op: 'rpc',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  const messagingSystem = attributes[semanticConventions.SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      op: 'message',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  const faasTrigger = attributes[semanticConventions.SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return { op: faasTrigger.toString(), description: name, source: 'route' };\n  }\n\n  return { op: undefined, description: name, source: 'custom' };\n}\n\nfunction descriptionForDbSystem({ attributes, name }) {\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  const statement = attributes[semanticConventions.SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nfunction descriptionForHttpMethod(\n  { name, kind, attributes },\n  httpMethod,\n) {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case api.SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case api.SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { op: opParts.join('.'), description: name, source: 'custom' };\n  }\n\n  // Ex. description=\"GET /api/users\".\n  const description = `${httpMethod} ${urlPath}`;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const source = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\n/** Exported for tests only */\nfunction getSanitizedUrl(\n  attributes,\n  kind,\n)\n\n {\n  // This is the relative path of the URL, e.g. /sub\n  const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[semanticConventions.SEMATTRS_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? utils.parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? utils.getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl && parsedUrl.search ? parsedUrl.search : undefined;\n  const fragment = parsedUrl && parsedUrl.hash ? parsedUrl.hash : undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === api.SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: utils.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: utils.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nfunction enhanceDscWithOpenTelemetryRootSpanName(client) {\n  client.on('createDsc', (dsc, rootSpan) => {\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n    if (rootSpan) {\n      const jsonSpan = core.spanToJSON(rootSpan);\n      const attributes = jsonSpan.data || {};\n      const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n      const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n      if (source !== 'url' && description) {\n        dsc.transaction = description;\n      }\n    }\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  return api.trace.getActiveSpan();\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = ( false || false);\n\nfunction _optionalChain$7(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nfunction getSamplingDecision(spanContext) {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === api.TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? utils.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (_optionalChain$7([dsc, 'optionalAccess', _ => _.sampled]) === 'true') {\n    return true;\n  }\n  if (_optionalChain$7([dsc, 'optionalAccess', _2 => _2.sampled]) === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n\nconst setupElements = new Set();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nfunction openTelemetrySetupCheck() {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nfunction setIsSetup(element) {\n  setupElements.add(element);\n}\n\nfunction _optionalChain$6(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/** Get the Sentry propagation context from a span context. */\nfunction getPropagationContextFromSpan(span) {\n  const spanContext = span.spanContext();\n  const { traceId, spanId, traceState } = spanContext;\n\n  // When we have a dsc trace state, it means this came from the incoming trace\n  // Then this takes presedence over the root span\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const traceStateDsc = dscString ? utils.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  const parentSpanId = traceState ? traceState.get(SENTRY_TRACE_STATE_PARENT_SPAN_ID) || undefined : undefined;\n\n  const sampled = getSamplingDecision(spanContext);\n\n  // No trace state? --> Take DSC from root span\n  const dsc = traceStateDsc || core.getDynamicSamplingContextFromSpan(core.getRootSpan(span));\n\n  return {\n    traceId,\n    spanId,\n    sampled,\n    parentSpanId,\n    dsc,\n  };\n}\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nclass SentryPropagator extends core$1.W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n\n   constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new utils.LRUMap(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   inject(context, carrier, setter) {\n    if (core$1.isTracingSuppressed(context)) {\n      DEBUG_BUILD && utils.logger.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = api.trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = _optionalChain$6([core.getClient, 'call', _ => _(), 'optionalAccess', _2 => _2.getOptions, 'call', _3 => _3(), 'optionalAccess', _4 => _4.tracePropagationTargets]);\n    if (\n      typeof url === 'string' &&\n      tracePropagationTargets &&\n      !this._shouldInjectTraceData(tracePropagationTargets, url)\n    ) {\n      DEBUG_BUILD &&\n        utils.logger.log(\n          '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:',\n          url,\n        );\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = api.propagation.getBaggage(context) || api.propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = utils.parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${utils.SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== api.INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, utils.generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(api.propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   extract(context, carrier, getter) {\n    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    const propagationContext = utils.propagationContextFromHeaders(sentryTrace, baggage);\n\n    // Add remote parent span context\n    const ctxWithSpanContext = getContextWithRemoteActiveSpan(context, { sentryTrace, baggage });\n\n    // Also update the scope on the context (to be sure this is picked up everywhere)\n    const scopes = getScopesFromContext(ctxWithSpanContext);\n    const newScopes = {\n      scope: scopes ? scopes.scope.clone() : core.getCurrentScope().clone(),\n      isolationScope: scopes ? scopes.isolationScope : core.getIsolationScope(),\n    };\n    newScopes.scope.setPropagationContext(propagationContext);\n\n    return setScopesOnContext(ctxWithSpanContext, newScopes);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   fields() {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n\n  /** If we want to inject trace data for a given URL. */\n   _shouldInjectTraceData(tracePropagationTargets, url) {\n    if (tracePropagationTargets === undefined) {\n      return true;\n    }\n\n    const cachedDecision = this._urlMatchesTargetsMap.get(url);\n    if (cachedDecision !== undefined) {\n      return cachedDecision;\n    }\n\n    const decision = utils.stringMatchesSomePattern(url, tracePropagationTargets);\n    this._urlMatchesTargetsMap.set(url, decision);\n    return decision;\n  }\n}\n\n/** Exported for tests. */\nfunction makeTraceState({\n  parentSpanId,\n  dsc,\n  sampled,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? utils.dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  // We _always_ set the parent span ID, even if it is empty\n  // If we'd set this to 'undefined' we could not know if the trace state was set, but there was no parentSpanId,\n  // vs the trace state was not set at all (in which case we want to do fallback handling)\n  // If `''`, it should be considered \"no parent\"\n  const traceStateBase = new core$1.TraceState().set(SENTRY_TRACE_STATE_PARENT_SPAN_ID, parentSpanId || '');\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n\nfunction getInjectionData(context)\n\n {\n  const span = core.hasTracingEnabled() ? api.trace.getSpan(context) : undefined;\n  const spanIsRemote = _optionalChain$6([span, 'optionalAccess', _5 => _5.spanContext, 'call', _6 => _6(), 'access', _7 => _7.isRemote]);\n\n  // If we have a local span, we can just pick everything from it\n  if (span && !spanIsRemote) {\n    const spanContext = span.spanContext();\n\n    const propagationContext = getPropagationContextFromSpan(span);\n    const dynamicSamplingContext = getDynamicSamplingContext(propagationContext, spanContext.traceId);\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext),\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  const scope = _optionalChain$6([getScopesFromContext, 'call', _8 => _8(context), 'optionalAccess', _9 => _9.scope]) || core.getCurrentScope();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = getDynamicSamplingContext(propagationContext, propagationContext.traceId);\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.spanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\n/** Get the DSC from a context, or fall back to use the one from the client. */\nfunction getDynamicSamplingContext(\n  propagationContext,\n  traceId,\n) {\n  // If we have a DSC on the propagation context, we just use it\n  if (_optionalChain$6([propagationContext, 'optionalAccess', _10 => _10.dsc])) {\n    return propagationContext.dsc;\n  }\n\n  // Else, we try to generate a new one\n  const client = core.getClient();\n\n  if (client) {\n    return core.getDynamicSamplingContextFromClient(traceId || propagationContext.traceId, client);\n  }\n\n  return undefined;\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx,\n  { sentryTrace, baggage },\n) {\n  const propagationContext = utils.propagationContextFromHeaders(sentryTrace, baggage);\n\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    parentSpanId: propagationContext.parentSpanId,\n    dsc: propagationContext.dsc,\n    sampled: propagationContext.sampled,\n  });\n\n  const spanContext = {\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.parentSpanId || '',\n    isRemote: true,\n    traceFlags: propagationContext.sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  return api.trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nfunction continueTraceAsRemoteSpan(\n  ctx,\n  options,\n  callback,\n) {\n  const ctxWithSpanContext = getContextWithRemoteActiveSpan(ctx, options);\n\n  return api.context.with(ctxWithSpanContext, callback);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier) {\n  try {\n    const baggage = (carrier )[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span) {\n  const urlAttribute = _optionalChain$6([core.spanToJSON, 'call', _11 => _11(span), 'access', _12 => _12.data, 'optionalAccess', _13 => _13[semanticConventions.SEMATTRS_HTTP_URL]]);\n  if (urlAttribute) {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = _optionalChain$6([span, 'access', _14 => _14.spanContext, 'call', _15 => _15(), 'access', _16 => _16.traceState, 'optionalAccess', _17 => _17.get, 'call', _18 => _18(SENTRY_TRACE_STATE_URL)]);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction _optionalChain$5(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      _applySentryAttributesToSpan(span, options);\n\n      return core.handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(\n  options,\n  callback,\n) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      _applySentryAttributesToSpan(span, options);\n\n      return core.handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    _applySentryAttributesToSpan(span, options);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const newContextWithActiveSpan = span ? api.trace.setSpan(api.context.active(), span) : api.trace.deleteSpan(api.context.active());\n  return api.context.with(newContextWithActiveSpan, () => callback(core.getCurrentScope()));\n}\n\nfunction getTracer() {\n  const client = core.getClient();\n  return (client && client.tracer) || api.trace.getTracer('@sentry/opentelemetry', core.SDK_VERSION);\n}\n\nfunction _applySentryAttributesToSpan(span, options) {\n  const { op } = options;\n\n  if (op) {\n    span.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_OP, op);\n  }\n}\n\nfunction getSpanOptions(options) {\n  const { startTime, attributes, kind } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes,\n    kind,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp) {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope, forceTransaction) {\n  const ctx = getContextForScope(scope);\n  const actualScope = _optionalChain$5([getScopesFromContext, 'call', _ => _(ctx), 'optionalAccess', _2 => _2.scope]);\n\n  const parentSpan = api.trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we need to \"simulate\" one to ensure the propagation context is correct\n  if (!parentSpan) {\n    const client = core.getClient();\n\n    if (actualScope && client) {\n      const propagationContext = actualScope.getPropagationContext();\n\n      // We store the DSC as OTEL trace state on the span context\n      const traceState = makeTraceState({\n        parentSpanId: propagationContext.parentSpanId,\n        // Not defined yet, we want to pick this up on-demand only\n        dsc: undefined,\n        sampled: propagationContext.sampled,\n      });\n\n      const spanOptions = {\n        traceId: propagationContext.traceId,\n        spanId: propagationContext.parentSpanId || propagationContext.spanId,\n        isRemote: true,\n        traceFlags: propagationContext.sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n        traceState,\n      };\n\n      // Add remote parent span context,\n      return api.trace.setSpanContext(ctx, spanOptions);\n    }\n\n    // if we have no scope or client, we just return the context as-is\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = api.trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = core.getRootSpan(parentSpan);\n  const dsc = core.getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    parentSpanId: spanId !== api.INVALID_SPANID ? spanId : undefined,\n    sampled,\n  });\n\n  const spanOptions = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = api.trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope) {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return api.context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nfunction continueTrace(options, callback) {\n  return core.continueTrace(options, () => {\n    return continueTraceAsRemoteSpan(api.context.active(), options, callback);\n  });\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan\n    ? (callback) => {\n        // We cast this, because the OTEL Span has a few more methods than our Span interface\n        // TODO: Add these missing methods to the Span interface\n        return withActiveSpan(parentSpan , callback);\n      }\n    : (callback) => callback();\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const ctx = core$1.suppressTracing(api.context.active());\n  return api.context.with(ctx, callback);\n}\n\nfunction _optionalChain$4(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n/** Ensure the `trace` context is set on all events. */\nfunction setupEventContextTrace(client) {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    const spanContext = span.spanContext();\n\n    // If we have a parent span id from trace state, use that ('' means no parent should be used)\n    // Else, pick the one from the span\n    const parentSpanIdFromTraceState = _optionalChain$4([spanContext, 'access', _ => _.traceState, 'optionalAccess', _2 => _2.get, 'call', _3 => _3(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);\n    const parent_span_id =\n      typeof parentSpanIdFromTraceState === 'string'\n        ? parentSpanIdFromTraceState || undefined\n        : spanHasParentId(span)\n          ? span.parentSpanId\n          : undefined;\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: utils.dropUndefinedKeys({\n        trace_id: spanContext.traceId,\n        span_id: spanContext.spanId,\n        parent_span_id,\n      }),\n      ...event.contexts,\n    };\n\n    const rootSpan = core.getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nfunction setOpenTelemetryContextAsyncContextStrategy() {\n  function getScopes() {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope(scope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope(isolationScope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope() {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope() {\n    return getScopes().isolationScope;\n  }\n\n  core.setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan ,\n    suppressTracing: suppressTracing,\n  });\n}\n\nfunction _optionalChain$3(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nfunction wrapContextManagerClass(\n  ContextManagerClass,\n) {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n     constructor(...args) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n     with(\n      context,\n      fn,\n      thisArg,\n      ...args\n    ) {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = _optionalChain$3([currentScopes, 'optionalAccess', _ => _.scope]) || core.getCurrentScope();\n      const currentIsolationScope = _optionalChain$3([currentScopes, 'optionalAccess', _2 => _2.isolationScope]) || core.getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) ;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) ;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager ;\n}\n\n/** If this attribute is true, it means that the parent is a remote span. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nfunction groupSpansWithParents(spans) {\n  const nodeMap = new Map();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nfunction getLocalParentId(span) {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? span.parentSpanId : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap, span) {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap, id) {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap, spanNode) {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing && existing.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} ;\n\nconst isStatusErrorMessageValid = (message) => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message );\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nfunction mapStatus(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === api.SpanStatusCode.OK) {\n      return { code: core.SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === api.SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: core.SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status && status.code === api.SpanStatusCode.UNSET) {\n    return { code: core.SPAN_STATUS_OK };\n  } else {\n    return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes) {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  const httpCodeAttribute = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  const grpcCodeAttribute = attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return core.getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: core.SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n\nfunction _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nclass SentrySpanExporter {\n\n   constructor(options) {\n    this._finishedSpans = [];\n    this._timeout = _optionalChain$2([options, 'optionalAccess', _ => _.timeout]) || DEFAULT_TIMEOUT;\n  }\n\n  /** Export a single span. */\n   export(span) {\n    this._finishedSpans.push(span);\n\n    // If the span has a local parent ID, we don't need to export anything just yet\n    if (getLocalParentId(span)) {\n      const openSpanCount = this._finishedSpans.length;\n      DEBUG_BUILD && utils.logger.log(`SpanExporter has ${openSpanCount} unsent spans remaining`);\n      this._cleanupOldSpans();\n      return;\n    }\n\n    this._clearTimeout();\n\n    // If we got a parent span, we try to send the span tree\n    // Wait a tick for this, to ensure we avoid race conditions\n    this._flushTimeout = setTimeout(() => {\n      this.flush();\n    }, 1);\n  }\n\n  /** Try to flush any pending spans immediately. */\n   flush() {\n    this._clearTimeout();\n\n    const openSpanCount = this._finishedSpans.length;\n\n    const remainingSpans = maybeSend(this._finishedSpans);\n\n    const remainingOpenSpanCount = remainingSpans.length;\n    const sentSpanCount = openSpanCount - remainingOpenSpanCount;\n\n    DEBUG_BUILD &&\n      utils.logger.log(`SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} unsent spans remaining`);\n\n    this._cleanupOldSpans(remainingSpans);\n  }\n\n  /** Clear the exporter. */\n   clear() {\n    this._finishedSpans = [];\n    this._clearTimeout();\n  }\n\n  /** Clear the flush timeout. */\n   _clearTimeout() {\n    if (this._flushTimeout) {\n      clearTimeout(this._flushTimeout);\n      this._flushTimeout = undefined;\n    }\n  }\n\n  /**\n   * Remove any span that is older than 5min.\n   * We do this to avoid leaking memory.\n   */\n   _cleanupOldSpans(spans = this._finishedSpans) {\n    this._finishedSpans = spans.filter(span => {\n      const shouldDrop = shouldCleanupSpan(span, this._timeout);\n      DEBUG_BUILD &&\n        shouldDrop &&\n        utils.logger.log(\n          `SpanExporter dropping span ${span.name} (${\n            span.spanContext().spanId\n          }) because it is pending for more than 5 minutes.`,\n        );\n      return !shouldDrop;\n    });\n  }\n}\n\n/**\n * Send the given spans, but only if they are part of a finished transaction.\n *\n * Returns the unsent spans.\n * Spans remain unsent when their parent span is not yet finished.\n * This will happen regularly, as child spans are generally finished before their parents.\n * But it _could_ also happen because, for whatever reason, a parent span was lost.\n * In this case, we'll eventually need to clean this up.\n */\nfunction maybeSend(spans) {\n  const grouped = groupSpansWithParents(spans);\n  const remaining = new Set(grouped);\n\n  const rootNodes = getCompletedRootNodes(grouped);\n\n  rootNodes.forEach(root => {\n    remaining.delete(root);\n    const span = root.span;\n    const transactionEvent = createTransactionForOtelSpan(span);\n\n    // We'll recursively add all the child spans to this array\n    const spans = transactionEvent.spans || [];\n\n    root.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, remaining);\n    });\n\n    // spans.sort() mutates the array, but we do not use this anymore after this point\n    // so we can safely mutate it here\n    transactionEvent.spans =\n      spans.length > MAX_SPAN_COUNT\n        ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n        : spans;\n\n    const measurements = core.timedEventsToMeasurements(span.events);\n    if (measurements) {\n      transactionEvent.measurements = measurements;\n    }\n\n    core.captureEvent(transactionEvent);\n  });\n\n  return Array.from(remaining)\n    .map(node => node.span)\n    .filter((span) => !!span);\n}\n\nfunction nodeIsCompletedRootNode(node) {\n  return !!node.span && !node.parentNode;\n}\n\nfunction getCompletedRootNodes(nodes) {\n  return nodes.filter(nodeIsCompletedRootNode);\n}\n\nfunction shouldCleanupSpan(span, maxStartTimeOffsetSeconds) {\n  const cutoff = Date.now() / 1000 - maxStartTimeOffsetSeconds;\n  return core.spanTimeInputToSeconds(span.startTime) < cutoff;\n}\n\nfunction parseSpan(span) {\n  const attributes = span.attributes;\n\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ;\n  const op = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] ;\n  const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n  return { origin, op, source };\n}\n\nfunction createTransactionForOtelSpan(span) {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = core.getCapturedScopesOnSpan(span );\n\n  const sampleRate = span.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ;\n\n  const attributes = utils.dropUndefinedKeys({\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  });\n\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  const parentSpanIdFromTraceState = _optionalChain$2([span, 'access', _2 => _2.spanContext, 'call', _3 => _3(), 'access', _4 => _4.traceState, 'optionalAccess', _5 => _5.get, 'call', _6 => _6(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take presedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id =\n    typeof parentSpanIdFromTraceState === 'string' ? parentSpanIdFromTraceState || undefined : span.parentSpanId;\n\n  const status = mapStatus(span);\n\n  const traceContext = utils.dropUndefinedKeys({\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n  });\n\n  const transactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n    },\n    spans: [],\n    start_timestamp: core.spanTimeInputToSeconds(span.startTime),\n    timestamp: core.spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      ...utils.dropUndefinedKeys({\n        capturedSpanScope: capturedSpanScopes.scope,\n        capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n        sampleRate,\n        dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(span ),\n      }),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n    _metrics_summary: core.getMetricSummaryJsonForSpan(span ),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node, spans, remaining) {\n  remaining.delete(node);\n  const span = node.span;\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, remaining);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n\n  const { attributes, startTime, endTime, parentSpanId } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = utils.dropUndefinedKeys({\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  });\n\n  const status = mapStatus(span);\n\n  const spanJSON = utils.dropUndefinedKeys({\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: core.spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: core.spanTimeInputToSeconds(endTime) || undefined,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    _metrics_summary: core.getMetricSummaryJsonForSpan(span ),\n    measurements: core.timedEventsToMeasurements(span.events),\n  });\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, remaining);\n  });\n}\n\nfunction getSpanData(span)\n\n {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attribtues we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data) {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span) {\n  const attributes = span.attributes;\n  const data = {\n    'otel.kind': api.SpanKind[span.kind],\n  };\n\n  if (attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE]) {\n    const statusCode = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE] ;\n    data['http.response.status_code'] = statusCode;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n\nfunction _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nfunction onSpanStart(span, parentContext) {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = api.trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    core.addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan && parentSpan.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === api.ROOT_CONTEXT) {\n    scopes = {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    core.setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  core.logSpanStart(span);\n\n  const client = core.getClient();\n  _optionalChain$1([client, 'optionalAccess', _ => _.emit, 'call', _2 => _2('spanStart', span)]);\n}\n\nfunction onSpanEnd(span) {\n  core.logSpanEnd(span);\n\n  const client = core.getClient();\n  _optionalChain$1([client, 'optionalAccess', _3 => _3.emit, 'call', _4 => _4('spanEnd', span)]);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nclass SentrySpanProcessor  {\n\n   constructor(options) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async forceFlush() {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async shutdown() {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   onStart(span, parentContext) {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n   onEnd(span) {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nclass SentrySampler  {\n\n   constructor(client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n   shouldSample(\n    context,\n    traceId,\n    spanName,\n    spanKind,\n    spanAttributes,\n    _links,\n  ) {\n    const options = this._client.getOptions();\n\n    const parentSpan = api.trace.getSpan(context);\n    const parentContext = _optionalChain([parentSpan, 'optionalAccess', _ => _.spanContext, 'call', _2 => _2()]);\n\n    if (!core.hasTracingEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (\n      spanKind === api.SpanKind.CLIENT &&\n      spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD] &&\n      (!parentSpan || _optionalChain([parentContext, 'optionalAccess', _3 => _3.isRemote]))\n    ) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: spanAttributes,\n        spanName: spanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const [sampled, sampleRate] = core.sampleSpan(options, {\n      name: spanName,\n      attributes: spanAttributes,\n      transactionContext: {\n        name: spanName,\n        parentSampled,\n      },\n      parentSampled,\n    });\n\n    const attributes = {\n      [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    };\n\n    const method = `${spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD]}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && utils.logger.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return {\n        ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.NOT_RECORD, context, spanAttributes }),\n        attributes,\n      };\n    }\n\n    if (!sampled) {\n      return {\n        ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.NOT_RECORD, context, spanAttributes }),\n        attributes,\n      };\n    }\n    return {\n      ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED, context, spanAttributes }),\n      attributes,\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n   toString() {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentRemoteSampled(parentSpan) {\n  const traceId = parentSpan.spanContext().traceId;\n  const traceparentData = getPropagationContextFromSpan(parentSpan);\n\n  // Only inherit sampled if `traceId` is the same\n  return traceparentData && traceId === traceparentData.traceId ? traceparentData.sampled : undefined;\n}\n\nfunction getParentSampled(parentSpan, traceId, spanName) {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (api.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getParentRemoteSampled(parentSpan);\n      DEBUG_BUILD &&\n        utils.logger.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && utils.logger.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nfunction wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n}) {\n  const traceState = getBaseTraceState(context, spanAttributes);\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === sdkTraceBase.SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context, spanAttributes) {\n  const parentSpan = api.trace.getSpan(context);\n  const parentContext = _optionalChain([parentSpan, 'optionalAccess', _4 => _4.spanContext, 'call', _5 => _5()]);\n\n  let traceState = _optionalChain([parentContext, 'optionalAccess', _6 => _6.traceState]) || new core$1.TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  const url = spanAttributes[semanticConventions.SEMATTRS_HTTP_URL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * This method takes an OpenTelemetry instrumentation or\n * array of instrumentations and registers them with OpenTelemetry.\n */\nfunction addOpenTelemetryInstrumentation(...instrumentations) {\n  instrumentation.registerInstrumentations({\n    instrumentations,\n  });\n}\n\nexports.getClient = core.getClient;\nexports.getCurrentHubShim = core.getCurrentHubShim;\nexports.getDynamicSamplingContextFromSpan = core.getDynamicSamplingContextFromSpan;\nexports.SentryPropagator = SentryPropagator;\nexports.SentrySampler = SentrySampler;\nexports.SentrySpanProcessor = SentrySpanProcessor;\nexports.addOpenTelemetryInstrumentation = addOpenTelemetryInstrumentation;\nexports.continueTrace = continueTrace;\nexports.enhanceDscWithOpenTelemetryRootSpanName = enhanceDscWithOpenTelemetryRootSpanName;\nexports.getActiveSpan = getActiveSpan;\nexports.getRequestSpanData = getRequestSpanData;\nexports.getScopesFromContext = getScopesFromContext;\nexports.getSpanKind = getSpanKind;\nexports.isSentryRequestSpan = isSentryRequestSpan;\nexports.openTelemetrySetupCheck = openTelemetrySetupCheck;\nexports.setOpenTelemetryContextAsyncContextStrategy = setOpenTelemetryContextAsyncContextStrategy;\nexports.setupEventContextTrace = setupEventContextTrace;\nexports.spanHasAttributes = spanHasAttributes;\nexports.spanHasEvents = spanHasEvents;\nexports.spanHasKind = spanHasKind;\nexports.spanHasName = spanHasName;\nexports.spanHasParentId = spanHasParentId;\nexports.spanHasStatus = spanHasStatus;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\nexports.wrapClientClass = wrapClientClass;\nexports.wrapContextManagerClass = wrapContextManagerClass;\nexports.wrapSamplingDecision = wrapSamplingDecision;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStvcGVudGVsZW1ldHJ5QDguMTcuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjBfQG9wZW50ZWxlbWV0cnkrY29yZUAxLjI1LjFfQG9wZW50ZWxlbWV0X293N2MzN2RtM2w0YnltYzdpNGV0aXB6bWFhL25vZGVfbW9kdWxlcy9Ac2VudHJ5L29wZW50ZWxlbWV0cnkvYnVpbGQvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxvSEFBZTs7QUFFM0IsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCw0QkFBNEIsbUJBQU8sQ0FBQyxzTEFBcUM7QUFDekUsY0FBYyxtQkFBTyxDQUFDLG9IQUFlO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxrSUFBb0I7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGlIQUFjO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywrSkFBcUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsNkxBQStCO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLGdNQUFnQzs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQywrQkFBK0Isb0JBQW9CLFdBQVcseUJBQXlCLG1CQUFtQix1QkFBdUIsUUFBUSwyRUFBMkUsb0JBQW9CLGtEQUFrRCx1QkFBdUIscUJBQXFCLG1EQUFtRCw2REFBNkQsK0JBQStCOztBQUV0ZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxhQUFhOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBMkM7QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxXQUFXO0FBQ1g7O0FBRUEsa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBOztBQUVBOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsSUFBSSx3QkFBd0I7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSwwQ0FBMEM7O0FBRXBEO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EseUJBQXlCLFlBQVksRUFBRSxRQUFROztBQUUvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGNBQWMsNkRBQTZEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE1BQXVDLElBQUksS0FBZ0I7O0FBRWhGLGlDQUFpQywrQkFBK0Isb0JBQW9CLFdBQVcseUJBQXlCLG1CQUFtQix1QkFBdUIsUUFBUSwyRUFBMkUsb0JBQW9CLGtEQUFrRCx1QkFBdUIscUJBQXFCLG1EQUFtRCw2REFBNkQsK0JBQStCOztBQUV0ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7O0FBRW5DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLCtCQUErQixvQkFBb0IsV0FBVyx5QkFBeUIsbUJBQW1CLHVCQUF1QixRQUFRLDJFQUEyRSxvQkFBb0Isa0RBQWtELHVCQUF1QixxQkFBcUIsbURBQW1ELDZEQUE2RCwrQkFBK0I7O0FBRXRmO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQThCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlGQUF5Rjs7QUFFekYsWUFBWSxtREFBbUQ7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25ELFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0MsRUFBRSxPQUFPLEtBQUssaUJBQWlCO0FBQzlGO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlFQUF5RSxzQkFBc0I7O0FBRS9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksc0JBQXNCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlDQUFpQywrQkFBK0Isb0JBQW9CLFdBQVcseUJBQXlCLG1CQUFtQix1QkFBdUIsUUFBUSwyRUFBMkUsb0JBQW9CLGtEQUFrRCx1QkFBdUIscUJBQXFCLG1EQUFtRCw2REFBNkQsK0JBQStCOztBQUV0ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxxQ0FBcUM7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHFDQUFxQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsS0FBSzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsOEJBQThCOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsa0JBQWtCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsK0JBQStCLG9CQUFvQixXQUFXLHlCQUF5QixtQkFBbUIsdUJBQXVCLFFBQVEsMkVBQTJFLG9CQUFvQixrREFBa0QsdUJBQXVCLHFCQUFxQixtREFBbUQsNkRBQTZELCtCQUErQjtBQUN0ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlDQUFpQywrQkFBK0Isb0JBQW9CLFdBQVcseUJBQXlCLG1CQUFtQix1QkFBdUIsUUFBUSwyRUFBMkUsb0JBQW9CLGtEQUFrRCx1QkFBdUIscUJBQXFCLG1EQUFtRCw2REFBNkQsK0JBQStCOztBQUV0ZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsb0NBQW9DO0FBQ2pGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLGtCQUFrQjtBQUN6RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsK0JBQStCLG9CQUFvQixXQUFXLHlCQUF5QixtQkFBbUIsdUJBQXVCLFFBQVEsMkVBQTJFLG9CQUFvQixrREFBa0QsdUJBQXVCLHFCQUFxQixtREFBbUQsNkRBQTZELCtCQUErQjs7QUFFdGY7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsZUFBZSxTQUFTLHdCQUF3Qjs7QUFFaEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxVQUFVLG1EQUFtRDtBQUM3RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsVUFBVSxxQ0FBcUM7O0FBRS9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsVUFBVSwrQ0FBK0M7O0FBRXpELFVBQVUsMkNBQTJDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxVQUFVLCtDQUErQztBQUN6RCxVQUFVLDBFQUEwRTs7QUFFcEY7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsK0JBQStCLG9CQUFvQixXQUFXLHlCQUF5QixtQkFBbUIsdUJBQXVCLFFBQVEsMkVBQTJFLG9CQUFvQixrREFBa0QsdUJBQXVCLHFCQUFxQixtREFBbUQsNkRBQTZELCtCQUErQjs7QUFFdGY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLDhDQUE4QztBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7O0FBRUE7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4Q0FBOEM7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHlEQUF5RDtBQUMvRTtBQUNBLDZGQUE2RixPQUFPLFFBQVEsU0FBUzs7QUFFckg7QUFDQSxrQ0FBa0MsNkVBQTZFO0FBQy9HO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLDZFQUE2RTtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxRkFBcUY7QUFDckg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixTQUFTLElBQUksY0FBYztBQUNqSDtBQUNBOztBQUVBO0FBQ0EsMEZBQTBGLFNBQVMsSUFBSSxjQUFjO0FBQ3JIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekIseUNBQXlDO0FBQ3pDLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLHVDQUF1QztBQUN2QyxxQkFBcUI7QUFDckIsK0NBQStDO0FBQy9DLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLG1CQUFtQjtBQUNuQiwyQkFBMkI7QUFDM0IsK0JBQStCO0FBQy9CLG1EQUFtRDtBQUNuRCw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrb3BlbnRlbGVtZXRyeUA4LjE3LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wX0BvcGVudGVsZW1ldHJ5K2NvcmVAMS4yNS4xX0BvcGVudGVsZW1ldF9vdzdjMzdkbTNsNGJ5bWM3aTRldGlwem1hYS9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L2J1aWxkL2Nqcy9pbmRleC5qcz9jZTRkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB7XG4gIF9vcHRpb25hbENoYWluXG59ID0gcmVxdWlyZSgnQHNlbnRyeS91dGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBzZW1hbnRpY0NvbnZlbnRpb25zID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnQHNlbnRyeS91dGlscycpO1xuY29uc3QgYXBpID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvYXBpJyk7XG5jb25zdCBjb3JlID0gcmVxdWlyZSgnQHNlbnRyeS9jb3JlJyk7XG5jb25zdCBjb3JlJDEgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9jb3JlJyk7XG5jb25zdCBzZGtUcmFjZUJhc2UgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZScpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uJyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhdHRyaWJ1dGVzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZXMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyB0aGVtLlxuICovXG5mdW5jdGlvbiBzcGFuSGFzQXR0cmlidXRlcyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5hdHRyaWJ1dGVzICYmIHR5cGVvZiBjYXN0U3Bhbi5hdHRyaWJ1dGVzID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEga2luZC5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIGtpbmQsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0tpbmQoc3Bhbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5raW5kO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBzdGF0dXMuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBzdGF0dXMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc1N0YXR1cyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5zdGF0dXM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIG5hbWUuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBuYW1lLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNOYW1lKHNwYW4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4ubmFtZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEga2luZC5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIGtpbmQsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc1BhcmVudElkKFxuICBzcGFuLFxuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLnBhcmVudFNwYW5JZDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGV2ZW50cy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBldmVudHMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0V2ZW50cyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjYXN0U3Bhbi5ldmVudHMpO1xufVxuXG4vKipcbiAqIEdldCBzYW5pdGl6aWVkIHJlcXVlc3QgZGF0YSBmcm9tIGFuIE9URUwgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVxdWVzdFNwYW5EYXRhKHNwYW4pIHtcbiAgLy8gVGhlIGJhc2UgYFNwYW5gIHR5cGUgaGFzIG5vIGBhdHRyaWJ1dGVzYCwgc28gd2UgbmVlZCB0byBndWFyZCBoZXJlIGFnYWluc3QgdGhhdFxuICBpZiAoIXNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHtcbiAgICB1cmw6IHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSAsXG4gICAgJ2h0dHAubWV0aG9kJzogc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9NRVRIT0RdICxcbiAgfTtcblxuICAvLyBEZWZhdWx0IHRvIEdFVCBpZiBVUkwgaXMgc2V0IGJ1dCBtZXRob2QgaXMgbm90XG4gIGlmICghZGF0YVsnaHR0cC5tZXRob2QnXSAmJiBkYXRhLnVybCkge1xuICAgIGRhdGFbJ2h0dHAubWV0aG9kJ10gPSAnR0VUJztcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXJsU3RyID0gc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdO1xuICAgIGlmICh0eXBlb2YgdXJsU3RyID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdXJsID0gdXRpbHMucGFyc2VVcmwodXJsU3RyKTtcblxuICAgICAgZGF0YS51cmwgPSB1dGlscy5nZXRTYW5pdGl6ZWRVcmxTdHJpbmcodXJsKTtcblxuICAgICAgaWYgKHVybC5zZWFyY2gpIHtcbiAgICAgICAgZGF0YVsnaHR0cC5xdWVyeSddID0gdXJsLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwuaGFzaCkge1xuICAgICAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSB1cmwuaGFzaDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpZ25vcmVcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfb3B0aW9uYWxDaGFpbiQ4KG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9XG5cbi8vIFR5cGVzY3JpcHQgY29tcGxhaW5zIGlmIHdlIGRvIG5vdCB1c2UgYC4uLmFyZ3M6IGFueVtdYCBmb3IgdGhlIG1peGluLCB3aXRoOlxuLy8gQSBtaXhpbiBjbGFzcyBtdXN0IGhhdmUgYSBjb25zdHJ1Y3RvciB3aXRoIGEgc2luZ2xlIHJlc3QgcGFyYW1ldGVyIG9mIHR5cGUgJ2FueVtdJy50cygyNTQ1KVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIFdyYXAgYW4gQ2xpZW50IHdpdGggdGhpbmdzIHdlIG5lZWQgZm9yIE9wZW5UZWxlbWV0cnkgc3VwcG9ydC5cbiAqXG4gKiBVc2FnZTpcbiAqIGNvbnN0IE9wZW5UZWxlbWV0cnlDbGllbnQgPSBnZXRXcmFwcGVkQ2xpZW50Q2xhc3MoTm9kZUNsaWVudCk7XG4gKiBjb25zdCBjbGllbnQgPSBuZXcgT3BlblRlbGVtZXRyeUNsaWVudChvcHRpb25zKTtcbiAqL1xuZnVuY3Rpb24gd3JhcENsaWVudENsYXNzXG5cbihDbGllbnRDbGFzcykge1xuICBjbGFzcyBPcGVuVGVsZW1ldHJ5Q2xpZW50IGV4dGVuZHMgQ2xpZW50Q2xhc3MgIHtcblxuICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBPVEVMIHRyYWNlci4gKi9cbiAgICAgZ2V0IHRyYWNlcigpIHtcbiAgICAgIGlmICh0aGlzLl90cmFjZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNlcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZSA9ICdAc2VudHJ5L29wZW50ZWxlbWV0cnknO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IGNvcmUuU0RLX1ZFUlNJT047XG4gICAgICBjb25zdCB0cmFjZXIgPSBhcGkudHJhY2UuZ2V0VHJhY2VyKG5hbWUsIHZlcnNpb24pO1xuICAgICAgdGhpcy5fdHJhY2VyID0gdHJhY2VyO1xuXG4gICAgICByZXR1cm4gdHJhY2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgIGFzeW5jIGZsdXNoKHRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy50cmFjZVByb3ZpZGVyO1xuICAgICAgY29uc3Qgc3BhblByb2Nlc3NvciA9IF9vcHRpb25hbENoYWluJDgoW3Byb3ZpZGVyLCAnb3B0aW9uYWxBY2Nlc3MnLCBfID0+IF8uYWN0aXZlU3BhblByb2Nlc3Nvcl0pO1xuXG4gICAgICBpZiAoc3BhblByb2Nlc3Nvcikge1xuICAgICAgICBhd2FpdCBzcGFuUHJvY2Vzc29yLmZvcmNlRmx1c2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1cGVyLmZsdXNoKHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcGVuVGVsZW1ldHJ5Q2xpZW50IDtcbn1cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIEdldCB0aGUgc3BhbiBraW5kIGZyb20gYSBzcGFuLlxuICogRm9yIHdoYXRldmVyIHJlYXNvbiwgdGhpcyBpcyBub3QgcHVibGljIEFQSSBvbiB0aGUgZ2VuZXJpYyBcIlNwYW5cIiB0eXBlLFxuICogc28gd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIGEgYFNES1RyYWNlQmFzZVNwYW5gIHdoZXJlIHdlIGNhbiBmZXRjaCB0aGlzIGZyb20uXG4gKiBPdGhlcndpc2UsIHdlIGZhbGwgYmFjayB0byBgU3BhbktpbmQuSU5URVJOQUxgLlxuICovXG5mdW5jdGlvbiBnZXRTcGFuS2luZChzcGFuKSB7XG4gIGlmIChzcGFuSGFzS2luZChzcGFuKSkge1xuICAgIHJldHVybiBzcGFuLmtpbmQ7XG4gIH1cblxuICByZXR1cm4gYXBpLlNwYW5LaW5kLklOVEVSTkFMO1xufVxuXG5jb25zdCBTRU5UUllfVFJBQ0VfSEVBREVSID0gJ3NlbnRyeS10cmFjZSc7XG5jb25zdCBTRU5UUllfQkFHR0FHRV9IRUFERVIgPSAnYmFnZ2FnZSc7XG5cbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9EU0MgPSAnc2VudHJ5LmRzYyc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfUEFSRU5UX1NQQU5fSUQgPSAnc2VudHJ5LnBhcmVudF9zcGFuX2lkJztcbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcgPSAnc2VudHJ5LnNhbXBsZWRfbm90X3JlY29yZGluZyc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfVVJMID0gJ3NlbnRyeS51cmwnO1xuXG5jb25zdCBTRU5UUllfU0NPUEVTX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9zY29wZXMnKTtcblxuY29uc3QgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX2lzb2xhdGlvbl9zY29wZScpO1xuXG5jb25zdCBTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X2Zvcmtfc2V0X3Njb3BlJyk7XG5cbmNvbnN0IFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X2Zvcmtfc2V0X2lzb2xhdGlvbl9zY29wZScpO1xuXG5jb25zdCBTQ09QRV9DT05URVhUX0ZJRUxEID0gJ19zY29wZUNvbnRleHQnO1xuXG4vKipcbiAqIFRyeSB0byBnZXQgdGhlIGN1cnJlbnQgc2NvcGVzIGZyb20gdGhlIGdpdmVuIE9URUwgY29udGV4dC5cbiAqIFRoaXMgcmVxdWlyZXMgYSBDb250ZXh0IE1hbmFnZXIgdGhhdCB3YXMgd3JhcHBlZCB3aXRoIGdldFdyYXBwZWRDb250ZXh0TWFuYWdlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfU0NPUEVTX0NPTlRFWFRfS0VZKSA7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHNjb3BlcyBvbiBhbiBPVEVMIGNvbnRleHQuXG4gKiBUaGlzIHdpbGwgcmV0dXJuIGEgZm9ya2VkIGNvbnRleHQgd2l0aCB0aGUgUHJvcGFnYXRpb24gQ29udGV4dCBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldFNjb3Blc09uQ29udGV4dChjb250ZXh0LCBzY29wZXMpIHtcbiAgcmV0dXJuIGNvbnRleHQuc2V0VmFsdWUoU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSwgc2NvcGVzKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbnRleHQgb24gdGhlIHNjb3BlIHNvIHdlIGNhbiBsYXRlciBsb29rIGl0IHVwLlxuICogV2UgbmVlZCB0aGlzIHRvIGdldCB0aGUgY29udGV4dCBmcm9tIHRoZSBzY29wZSBpbiB0aGUgYHRyYWNlYCBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHRPblNjb3BlKHNjb3BlLCBjb250ZXh0KSB7XG4gIHV0aWxzLmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShzY29wZSwgU0NPUEVfQ09OVEVYVF9GSUVMRCwgY29udGV4dCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZXh0IHJlbGF0ZWQgdG8gYSBzY29wZS5cbiAqIFRPRE8gdjg6IFVzZSB0aGlzIGZvciB0aGUgYHRyYWNlYCBmdW5jdGlvbnMuXG4gKiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkge1xuICByZXR1cm4gKHNjb3BlIClbU0NPUEVfQ09OVEVYVF9GSUVMRF07XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvdGVsU3BhbiBDaGVja3Mgd2hldGVyIGEgZ2l2ZW4gT1RFTCBTcGFuIGlzIGFuIGh0dHAgcmVxdWVzdCB0byBzZW50cnkuXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzU2VudHJ5UmVxdWVzdFNwYW4oc3Bhbikge1xuICBpZiAoIXNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBzcGFuO1xuXG4gIGNvbnN0IGh0dHBVcmwgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdO1xuXG4gIGlmICghaHR0cFVybCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb3JlLmlzU2VudHJ5UmVxdWVzdFVybChodHRwVXJsLnRvU3RyaW5nKCksIGNvcmUuZ2V0Q2xpZW50KCkpO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYmV0dGVyIG9wL2Rlc2NyaXB0aW9uIGZyb20gYW4gb3RlbCBzcGFuLlxuICpcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWNvbGxlY3Rvci1jb250cmliL2Jsb2IvNzQyMmNlMmEwNjMzN2Y2OGE1OWI1NTJiOGM1YTJhYzEyNWQ2YmFlNS9leHBvcnRlci9zZW50cnlleHBvcnRlci9zZW50cnlfZXhwb3J0ZXIuZ28jTDMwNlxuICovXG5mdW5jdGlvbiBwYXJzZVNwYW5EZXNjcmlwdGlvbihzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSA/IHNwYW4uYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBuYW1lID0gc3Bhbkhhc05hbWUoc3BhbikgPyBzcGFuLm5hbWUgOiAnPHVua25vd24+JztcblxuICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyBpbnRlbnRpb25hbGx5IGV4cG9ydGVkIGFzIGEgU0VNQVRUUiBjb25zdGFudCBiZWNhdXNlIGl0IHNob3VsZCBzdGF5IGludGltaXRlIEFQSVxuICBpZiAoYXR0cmlidXRlc1snc2VudHJ5LnNraXBfc3Bhbl9kYXRhX2luZmVyZW5jZSddKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wOiB1bmRlZmluZWQsXG4gICAgICBkZXNjcmlwdGlvbjogbmFtZSxcbiAgICAgIHNvdXJjZTogJ2N1c3RvbScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIC8vIFN1Z2dlc3QgdG8gY2FsbGVycyBvZiBgcGFyc2VTcGFuRGVzY3JpcHRpb25gIHRvIHdpcGUgdGhlIGhpbnQgYmVjYXVzZSBpdCBpcyB1bm5lY2Vzc2FyeSBkYXRhIGluIHRoZSBlbmQuXG4gICAgICAgICdzZW50cnkuc2tpcF9zcGFuX2RhdGFfaW5mZXJlbmNlJzogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gaWYgaHR0cC5tZXRob2QgZXhpc3RzLCB0aGlzIGlzIGFuIGh0dHAgcmVxdWVzdCBzcGFuXG4gIC8vXG4gIC8vIFRPRE86IFJlZmVyZW5jaW5nIGBodHRwLnJlcXVlc3QubWV0aG9kYCBpcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kIHVudGlsIHRoZSBzZW1hbnRpY1xuICAvLyBjb252ZW50aW9ucyBleHBvcnQgYW4gYXR0cmlidXRlIGtleSBmb3IgaXQuXG4gIGNvbnN0IGh0dHBNZXRob2QgPSBhdHRyaWJ1dGVzWydodHRwLnJlcXVlc3QubWV0aG9kJ10gfHwgYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTtcbiAgaWYgKGh0dHBNZXRob2QpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb25Gb3JIdHRwTWV0aG9kKHsgYXR0cmlidXRlcywgbmFtZSwga2luZDogZ2V0U3BhbktpbmQoc3BhbikgfSwgaHR0cE1ldGhvZCk7XG4gIH1cblxuICBjb25zdCBkYlN5c3RlbSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19EQl9TWVNURU1dO1xuICBjb25zdCBvcElzQ2FjaGUgPVxuICAgIHR5cGVvZiBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0gPT09ICdzdHJpbmcnICYmXG4gICAgYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdLnN0YXJ0c1dpdGgoJ2NhY2hlLicpO1xuXG4gIC8vIElmIGRiLnR5cGUgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIGRhdGFiYXNlIGNhbGwgc3BhblxuICAvLyBJZiB0aGUgUmVkaXMgREIgaXMgdXNlZCBhcyBhIGNhY2hlLCB0aGUgc3BhbiBkZXNjcmlwdGlvbiBzaG91bGQgbm90IGJlIGNoYW5nZWRcbiAgaWYgKGRiU3lzdGVtICYmICFvcElzQ2FjaGUpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb25Gb3JEYlN5c3RlbSh7IGF0dHJpYnV0ZXMsIG5hbWUgfSk7XG4gIH1cblxuICAvLyBJZiBycGMuc2VydmljZSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgcnBjIGNhbGwgc3Bhbi5cbiAgY29uc3QgcnBjU2VydmljZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19SUENfU0VSVklDRV07XG4gIGlmIChycGNTZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wOiAncnBjJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBuYW1lLFxuICAgICAgc291cmNlOiAncm91dGUnLFxuICAgIH07XG4gIH1cblxuICAvLyBJZiBtZXNzYWdpbmcuc3lzdGVtIGV4aXN0cyB0aGVuIHRoaXMgaXMgYSBtZXNzYWdpbmcgc3lzdGVtIHNwYW4uXG4gIGNvbnN0IG1lc3NhZ2luZ1N5c3RlbSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19NRVNTQUdJTkdfU1lTVEVNXTtcbiAgaWYgKG1lc3NhZ2luZ1N5c3RlbSkge1xuICAgIHJldHVybiB7XG4gICAgICBvcDogJ21lc3NhZ2UnLFxuICAgICAgZGVzY3JpcHRpb246IG5hbWUsXG4gICAgICBzb3VyY2U6ICdyb3V0ZScsXG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIGZhYXMudHJpZ2dlciBleGlzdHMgdGhlbiB0aGlzIGlzIGEgZnVuY3Rpb24gYXMgYSBzZXJ2aWNlIHNwYW4uXG4gIGNvbnN0IGZhYXNUcmlnZ2VyID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0ZBQVNfVFJJR0dFUl07XG4gIGlmIChmYWFzVHJpZ2dlcikge1xuICAgIHJldHVybiB7IG9wOiBmYWFzVHJpZ2dlci50b1N0cmluZygpLCBkZXNjcmlwdGlvbjogbmFtZSwgc291cmNlOiAncm91dGUnIH07XG4gIH1cblxuICByZXR1cm4geyBvcDogdW5kZWZpbmVkLCBkZXNjcmlwdGlvbjogbmFtZSwgc291cmNlOiAnY3VzdG9tJyB9O1xufVxuXG5mdW5jdGlvbiBkZXNjcmlwdGlvbkZvckRiU3lzdGVtKHsgYXR0cmlidXRlcywgbmFtZSB9KSB7XG4gIC8vIFVzZSBEQiBzdGF0ZW1lbnQgKEV4IFwiU0VMRUNUICogRlJPTSB0YWJsZVwiKSBpZiBwb3NzaWJsZSBhcyBkZXNjcmlwdGlvbi5cbiAgY29uc3Qgc3RhdGVtZW50ID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0RCX1NUQVRFTUVOVF07XG5cbiAgY29uc3QgZGVzY3JpcHRpb24gPSBzdGF0ZW1lbnQgPyBzdGF0ZW1lbnQudG9TdHJpbmcoKSA6IG5hbWU7XG5cbiAgcmV0dXJuIHsgb3A6ICdkYicsIGRlc2NyaXB0aW9uLCBzb3VyY2U6ICd0YXNrJyB9O1xufVxuXG4vKiogT25seSBleHBvcnRlZCBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBkZXNjcmlwdGlvbkZvckh0dHBNZXRob2QoXG4gIHsgbmFtZSwga2luZCwgYXR0cmlidXRlcyB9LFxuICBodHRwTWV0aG9kLFxuKSB7XG4gIGNvbnN0IG9wUGFydHMgPSBbJ2h0dHAnXTtcblxuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIGFwaS5TcGFuS2luZC5DTElFTlQ6XG4gICAgICBvcFBhcnRzLnB1c2goJ2NsaWVudCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhcGkuU3BhbktpbmQuU0VSVkVSOlxuICAgICAgb3BQYXJ0cy5wdXNoKCdzZXJ2ZXInKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY29uc3QgeyB1cmxQYXRoLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGUgfSA9IGdldFNhbml0aXplZFVybChhdHRyaWJ1dGVzLCBraW5kKTtcblxuICBpZiAoIXVybFBhdGgpIHtcbiAgICByZXR1cm4geyBvcDogb3BQYXJ0cy5qb2luKCcuJyksIGRlc2NyaXB0aW9uOiBuYW1lLCBzb3VyY2U6ICdjdXN0b20nIH07XG4gIH1cblxuICAvLyBFeC4gZGVzY3JpcHRpb249XCJHRVQgL2FwaS91c2Vyc1wiLlxuICBjb25zdCBkZXNjcmlwdGlvbiA9IGAke2h0dHBNZXRob2R9ICR7dXJsUGF0aH1gO1xuXG4gIC8vIElmIGBodHRwUGF0aGAgaXMgYSByb290IHBhdGgsIHRoZW4gd2UgY2FuIGNhdGVnb3JpemUgdGhlIHRyYW5zYWN0aW9uIHNvdXJjZSBhcyByb3V0ZS5cbiAgY29uc3Qgc291cmNlID0gaGFzUm91dGUgfHwgdXJsUGF0aCA9PT0gJy8nID8gJ3JvdXRlJyA6ICd1cmwnO1xuXG4gIGNvbnN0IGRhdGEgPSB7fTtcblxuICBpZiAodXJsKSB7XG4gICAgZGF0YS51cmwgPSB1cmw7XG4gIH1cbiAgaWYgKHF1ZXJ5KSB7XG4gICAgZGF0YVsnaHR0cC5xdWVyeSddID0gcXVlcnk7XG4gIH1cbiAgaWYgKGZyYWdtZW50KSB7XG4gICAgZGF0YVsnaHR0cC5mcmFnbWVudCddID0gZnJhZ21lbnQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wOiBvcFBhcnRzLmpvaW4oJy4nKSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzb3VyY2UsXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuLyoqIEV4cG9ydGVkIGZvciB0ZXN0cyBvbmx5ICovXG5mdW5jdGlvbiBnZXRTYW5pdGl6ZWRVcmwoXG4gIGF0dHJpYnV0ZXMsXG4gIGtpbmQsXG4pXG5cbiB7XG4gIC8vIFRoaXMgaXMgdGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIFVSTCwgZS5nLiAvc3ViXG4gIGNvbnN0IGh0dHBUYXJnZXQgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9UQVJHRVRdO1xuICAvLyBUaGlzIGlzIHRoZSBmdWxsIFVSTCwgaW5jbHVkaW5nIGhvc3QgJiBxdWVyeSBwYXJhbXMgZXRjLiwgZS5nLiBodHRwczovL2V4YW1wbGUuY29tL3N1Yj9mb289YmFyXG4gIGNvbnN0IGh0dHBVcmwgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdO1xuICAvLyBUaGlzIGlzIHRoZSBub3JtYWxpemVkIHJvdXRlIG5hbWUgLSBtYXkgbm90IGFsd2F5cyBiZSBhdmFpbGFibGUhXG4gIGNvbnN0IGh0dHBSb3V0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1JPVVRFXTtcblxuICBjb25zdCBwYXJzZWRVcmwgPSB0eXBlb2YgaHR0cFVybCA9PT0gJ3N0cmluZycgPyB1dGlscy5wYXJzZVVybChodHRwVXJsKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdXJsID0gcGFyc2VkVXJsID8gdXRpbHMuZ2V0U2FuaXRpemVkVXJsU3RyaW5nKHBhcnNlZFVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHF1ZXJ5ID0gcGFyc2VkVXJsICYmIHBhcnNlZFVybC5zZWFyY2ggPyBwYXJzZWRVcmwuc2VhcmNoIDogdW5kZWZpbmVkO1xuICBjb25zdCBmcmFnbWVudCA9IHBhcnNlZFVybCAmJiBwYXJzZWRVcmwuaGFzaCA/IHBhcnNlZFVybC5oYXNoIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgaHR0cFJvdXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IGh0dHBSb3V0ZSwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiB0cnVlIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gYXBpLlNwYW5LaW5kLlNFUlZFUiAmJiB0eXBlb2YgaHR0cFRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiB1dGlscy5zdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQoaHR0cFRhcmdldCksIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbiAgfVxuXG4gIGlmIChwYXJzZWRVcmwpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiB1cmwsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbiAgfVxuXG4gIC8vIGZhbGwgYmFjayB0byB0YXJnZXQgZXZlbiBmb3IgY2xpZW50IHNwYW5zLCBpZiBubyBVUkwgaXMgcHJlc2VudFxuICBpZiAodHlwZW9mIGh0dHBUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogdXRpbHMuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KGh0dHBUYXJnZXQpLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICByZXR1cm4geyB1cmxQYXRoOiB1bmRlZmluZWQsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBTZXR1cCBhIERTQyBoYW5kbGVyIG9uIHRoZSBwYXNzZWQgY2xpZW50LFxuICogZW5zdXJpbmcgdGhhdCB0aGUgdHJhbnNhY3Rpb24gbmFtZSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBzcGFuIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gZW5oYW5jZURzY1dpdGhPcGVuVGVsZW1ldHJ5Um9vdFNwYW5OYW1lKGNsaWVudCkge1xuICBjbGllbnQub24oJ2NyZWF0ZURzYycsIChkc2MsIHJvb3RTcGFuKSA9PiB7XG4gICAgLy8gV2Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBEU0MgdGhhdCBpcyBjcmVhdGVkIGJ5IGRlZmF1bHQgaW4gY29yZVxuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB3ZSB3YW50IHRvIGluZmVyIHRoZSBzcGFuIG5hbWUsIG5vdCB1c2UgdGhlIGluaXRpYWwgb25lXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBnZXQgbmFtZXMgbGlrZSBcIkdFVFwiIGluc3RlYWQgb2YgZS5nLiBcIkdFVCAvZm9vXCJcbiAgICAvLyBgcGFyc2VTcGFuRGVzY3JpcHRpb25gIHRha2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBzcGFuIGludG8gYWNjb3VudCBmb3IgdGhlIG5hbWVcbiAgICAvLyBUaGlzIG11dGF0ZXMgdGhlIHBhc3NlZC1pbiBEU0NcbiAgICBpZiAocm9vdFNwYW4pIHtcbiAgICAgIGNvbnN0IGpzb25TcGFuID0gY29yZS5zcGFuVG9KU09OKHJvb3RTcGFuKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBqc29uU3Bhbi5kYXRhIHx8IHt9O1xuICAgICAgY29uc3Qgc291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTtcblxuICAgICAgY29uc3QgeyBkZXNjcmlwdGlvbiB9ID0gc3Bhbkhhc05hbWUocm9vdFNwYW4pID8gcGFyc2VTcGFuRGVzY3JpcHRpb24ocm9vdFNwYW4pIDogeyBkZXNjcmlwdGlvbjogdW5kZWZpbmVkIH07XG4gICAgICBpZiAoc291cmNlICE9PSAndXJsJyAmJiBkZXNjcmlwdGlvbikge1xuICAgICAgICBkc2MudHJhbnNhY3Rpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlU3BhbigpIHtcbiAgcmV0dXJuIGFwaS50cmFjZS5nZXRBY3RpdmVTcGFuKCk7XG59XG5cbi8qKlxuICogVGhpcyBzZXJ2ZXMgYXMgYSBidWlsZCB0aW1lIGZsYWcgdGhhdCB3aWxsIGJlIHRydWUgYnkgZGVmYXVsdCwgYnV0IGZhbHNlIGluIG5vbi1kZWJ1ZyBidWlsZHMgb3IgaWYgdXNlcnMgcmVwbGFjZSBgX19TRU5UUllfREVCVUdfX2AgaW4gdGhlaXIgZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogQVRURU5USU9OOiBUaGlzIGNvbnN0YW50IG11c3QgbmV2ZXIgY3Jvc3MgcGFja2FnZSBib3VuZGFyaWVzIChpLmUuIGJlIGV4cG9ydGVkKSB0byBndWFyYW50ZWUgdGhhdCBpdCBjYW4gYmUgdXNlZCBmb3IgdHJlZSBzaGFraW5nLlxuICovXG5jb25zdCBERUJVR19CVUlMRCA9ICh0eXBlb2YgX19TRU5UUllfREVCVUdfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgX19TRU5UUllfREVCVUdfXyk7XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDcob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxuLyoqXG4gKiBPcGVuVGVsZW1ldHJ5IG9ubHkga25vd3MgYWJvdXQgU0FNUExFRCBvciBOT05FIGRlY2lzaW9uLFxuICogYnV0IGZvciB1cyBpdCBpcyBpbXBvcnRhbnQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHVuc2V0IGFuZCB1bnNhbXBsZWQuXG4gKlxuICogQm90aCBvZiB0aGVzZSBhcmUgaWRlbnRpZmllZCBhcyBgdHJhY2VGbGFncyA9PT0gVHJhY2VnRmxhZ3MuTk9ORWAsXG4gKiBidXQgd2UgYWRkaXRpb25hbGx5IGxvb2sgYXQgYSBzcGVjaWFsIHRyYWNlIHN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGVtLlxuICovXG5mdW5jdGlvbiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSB7XG4gIGNvbnN0IHsgdHJhY2VGbGFncywgdHJhY2VTdGF0ZSB9ID0gc3BhbkNvbnRleHQ7XG5cbiAgY29uc3Qgc2FtcGxlZE5vdFJlY29yZGluZyA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HKSA9PT0gJzEnIDogZmFsc2U7XG5cbiAgLy8gSWYgdHJhY2UgZmxhZyBpcyBgU0FNUExFRGAsIHdlIGludGVycHJldCB0aGlzIGFzIHNhbXBsZWRcbiAgLy8gSWYgaXQgaXMgYE5PTkVgLCBpdCBjb3VsZCBtZWFuIGVpdGhlciBpdCB3YXMgc2FtcGxlZCB0byBiZSBub3QgcmVjb3JkZXIsIG9yIHRoYXQgaXQgd2FzIG5vdCBzYW1wbGVkIGF0IGFsbFxuICAvLyBGb3IgdXMgdGhpcyBpcyBhbiBpbXBvcnRhbnQgZGlmZmVyZW5jZSwgc293IGUgbG9vayBhdCB0aGUgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElOR1xuICAvLyB0byBpZGVudGlmeSB3aGljaCBpdCBpc1xuICBpZiAodHJhY2VGbGFncyA9PT0gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNhbXBsZWROb3RSZWNvcmRpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gRFNDIGFzIGEgbGFzdCByZXNvcnQsIHRoYXQgbWF5IGFsc28gY29udGFpbiBgc2FtcGxlZGAuLi5cbiAgY29uc3QgZHNjU3RyaW5nID0gdHJhY2VTdGF0ZSA/IHRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MpIDogdW5kZWZpbmVkO1xuICBjb25zdCBkc2MgPSBkc2NTdHJpbmcgPyB1dGlscy5iYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KGRzY1N0cmluZykgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKF9vcHRpb25hbENoYWluJDcoW2RzYywgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnNhbXBsZWRdKSA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKF9vcHRpb25hbENoYWluJDcoW2RzYywgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuc2FtcGxlZF0pID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3Qgc2V0dXBFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEdldCBhbGwgdGhlIE9wZW5UZWxlbWV0cnkgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gc2V0IHVwLiAqL1xuZnVuY3Rpb24gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2soKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNldHVwRWxlbWVudHMpO1xufVxuXG4vKiogTWFyayBhbiBPcGVuVGVsZW1ldHJ5IGVsZW1lbnQgYXMgc2V0dXAuICovXG5mdW5jdGlvbiBzZXRJc1NldHVwKGVsZW1lbnQpIHtcbiAgc2V0dXBFbGVtZW50cy5hZGQoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDYob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxuLyoqIEdldCB0aGUgU2VudHJ5IHByb3BhZ2F0aW9uIGNvbnRleHQgZnJvbSBhIHNwYW4gY29udGV4dC4gKi9cbmZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uQ29udGV4dEZyb21TcGFuKHNwYW4pIHtcbiAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG4gIGNvbnN0IHsgdHJhY2VJZCwgc3BhbklkLCB0cmFjZVN0YXRlIH0gPSBzcGFuQ29udGV4dDtcblxuICAvLyBXaGVuIHdlIGhhdmUgYSBkc2MgdHJhY2Ugc3RhdGUsIGl0IG1lYW5zIHRoaXMgY2FtZSBmcm9tIHRoZSBpbmNvbWluZyB0cmFjZVxuICAvLyBUaGVuIHRoaXMgdGFrZXMgcHJlc2VkZW5jZSBvdmVyIHRoZSByb290IHNwYW5cbiAgY29uc3QgZHNjU3RyaW5nID0gdHJhY2VTdGF0ZSA/IHRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MpIDogdW5kZWZpbmVkO1xuICBjb25zdCB0cmFjZVN0YXRlRHNjID0gZHNjU3RyaW5nID8gdXRpbHMuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChkc2NTdHJpbmcpIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHBhcmVudFNwYW5JZCA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfUEFSRU5UX1NQQU5fSUQpIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBzYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCk7XG5cbiAgLy8gTm8gdHJhY2Ugc3RhdGU/IC0tPiBUYWtlIERTQyBmcm9tIHJvb3Qgc3BhblxuICBjb25zdCBkc2MgPSB0cmFjZVN0YXRlRHNjIHx8IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKGNvcmUuZ2V0Um9vdFNwYW4oc3BhbikpO1xuXG4gIHJldHVybiB7XG4gICAgdHJhY2VJZCxcbiAgICBzcGFuSWQsXG4gICAgc2FtcGxlZCxcbiAgICBwYXJlbnRTcGFuSWQsXG4gICAgZHNjLFxuICB9O1xufVxuXG4vKipcbiAqIEluamVjdHMgYW5kIGV4dHJhY3RzIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgaGVhZGVycyBmcm9tIGNhcnJpZXJzLlxuICovXG5jbGFzcyBTZW50cnlQcm9wYWdhdG9yIGV4dGVuZHMgY29yZSQxLlczQ0JhZ2dhZ2VQcm9wYWdhdG9yIHtcbiAgLyoqIEEgbWFwIG9mIFVSTHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBjaGVja2VkIGZvciBpZiB0aGV5IG1hdGNoIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLiAqL1xuXG4gICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVByb3BhZ2F0b3InKTtcblxuICAgIC8vIFdlJ3JlIGNhY2hpbmcgcmVzdWx0cyBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSByZWdleHAgZXZlcnkgdGltZSB3ZSBjcmVhdGUgYSByZXF1ZXN0LlxuICAgIHRoaXMuX3VybE1hdGNoZXNUYXJnZXRzTWFwID0gbmV3IHV0aWxzLkxSVU1hcCgxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgaW5qZWN0KGNvbnRleHQsIGNhcnJpZXIsIHNldHRlcikge1xuICAgIGlmIChjb3JlJDEuaXNUcmFjaW5nU3VwcHJlc3NlZChjb250ZXh0KSkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgdXRpbHMubG9nZ2VyLmxvZygnW1RyYWNpbmddIE5vdCBpbmplY3RpbmcgdHJhY2UgZGF0YSBmb3IgdXJsIGJlY2F1c2UgdHJhY2luZyBpcyBzdXBwcmVzc2VkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcbiAgICBjb25zdCB1cmwgPSBhY3RpdmVTcGFuICYmIGdldEN1cnJlbnRVUkwoYWN0aXZlU3Bhbik7XG5cbiAgICBjb25zdCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cyA9IF9vcHRpb25hbENoYWluJDYoW2NvcmUuZ2V0Q2xpZW50LCAnY2FsbCcsIF8gPT4gXygpLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMiA9PiBfMi5nZXRPcHRpb25zLCAnY2FsbCcsIF8zID0+IF8zKCksICdvcHRpb25hbEFjY2VzcycsIF80ID0+IF80LnRyYWNlUHJvcGFnYXRpb25UYXJnZXRzXSk7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzICYmXG4gICAgICAhdGhpcy5fc2hvdWxkSW5qZWN0VHJhY2VEYXRhKHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLCB1cmwpXG4gICAgKSB7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICB1dGlscy5sb2dnZXIubG9nKFxuICAgICAgICAgICdbVHJhY2luZ10gTm90IGluamVjdGluZyB0cmFjZSBkYXRhIGZvciB1cmwgYmVjYXVzZSBpdCBkb2VzIG5vdCBtYXRjaCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0czonLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZ0JhZ2dhZ2VIZWFkZXIgPSBnZXRFeGlzdGluZ0JhZ2dhZ2UoY2Fycmllcik7XG4gICAgbGV0IGJhZ2dhZ2UgPSBhcGkucHJvcGFnYXRpb24uZ2V0QmFnZ2FnZShjb250ZXh0KSB8fCBhcGkucHJvcGFnYXRpb24uY3JlYXRlQmFnZ2FnZSh7fSk7XG5cbiAgICBjb25zdCB7IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsIHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCB9ID0gZ2V0SW5qZWN0aW9uRGF0YShjb250ZXh0KTtcblxuICAgIGlmIChleGlzdGluZ0JhZ2dhZ2VIZWFkZXIpIHtcbiAgICAgIGNvbnN0IGJhZ2dhZ2VFbnRyaWVzID0gdXRpbHMucGFyc2VCYWdnYWdlSGVhZGVyKGV4aXN0aW5nQmFnZ2FnZUhlYWRlcik7XG5cbiAgICAgIGlmIChiYWdnYWdlRW50cmllcykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhiYWdnYWdlRW50cmllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgYmFnZ2FnZSA9IGJhZ2dhZ2Uuc2V0RW50cnkoa2V5LCB7IHZhbHVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHluYW1pY1NhbXBsaW5nQ29udGV4dCkge1xuICAgICAgYmFnZ2FnZSA9IE9iamVjdC5lbnRyaWVzKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpLnJlZHVjZSgoYiwgW2RzY0tleSwgZHNjVmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChkc2NWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiLnNldEVudHJ5KGAke3V0aWxzLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVh9JHtkc2NLZXl9YCwgeyB2YWx1ZTogZHNjVmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LCBiYWdnYWdlKTtcbiAgICB9XG5cbiAgICAvLyBXZSBhbHNvIHdhbnQgdG8gYXZvaWQgc2V0dGluZyB0aGUgZGVmYXVsdCBPVEVMIHRyYWNlIElELCBpZiB3ZSBnZXQgdGhhdCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgaWYgKHRyYWNlSWQgJiYgdHJhY2VJZCAhPT0gYXBpLklOVkFMSURfVFJBQ0VJRCkge1xuICAgICAgc2V0dGVyLnNldChjYXJyaWVyLCBTRU5UUllfVFJBQ0VfSEVBREVSLCB1dGlscy5nZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyKHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCkpO1xuICAgIH1cblxuICAgIHN1cGVyLmluamVjdChhcGkucHJvcGFnYXRpb24uc2V0QmFnZ2FnZShjb250ZXh0LCBiYWdnYWdlKSwgY2Fycmllciwgc2V0dGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGV4dHJhY3QoY29udGV4dCwgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgY29uc3QgbWF5YmVTZW50cnlUcmFjZUhlYWRlciA9IGdldHRlci5nZXQoY2FycmllciwgU0VOVFJZX1RSQUNFX0hFQURFUik7XG4gICAgY29uc3QgYmFnZ2FnZSA9IGdldHRlci5nZXQoY2FycmllciwgU0VOVFJZX0JBR0dBR0VfSEVBREVSKTtcblxuICAgIGNvbnN0IHNlbnRyeVRyYWNlID0gbWF5YmVTZW50cnlUcmFjZUhlYWRlclxuICAgICAgPyBBcnJheS5pc0FycmF5KG1heWJlU2VudHJ5VHJhY2VIZWFkZXIpXG4gICAgICAgID8gbWF5YmVTZW50cnlUcmFjZUhlYWRlclswXVxuICAgICAgICA6IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gdXRpbHMucHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMoc2VudHJ5VHJhY2UsIGJhZ2dhZ2UpO1xuXG4gICAgLy8gQWRkIHJlbW90ZSBwYXJlbnQgc3BhbiBjb250ZXh0XG4gICAgY29uc3QgY3R4V2l0aFNwYW5Db250ZXh0ID0gZ2V0Q29udGV4dFdpdGhSZW1vdGVBY3RpdmVTcGFuKGNvbnRleHQsIHsgc2VudHJ5VHJhY2UsIGJhZ2dhZ2UgfSk7XG5cbiAgICAvLyBBbHNvIHVwZGF0ZSB0aGUgc2NvcGUgb24gdGhlIGNvbnRleHQgKHRvIGJlIHN1cmUgdGhpcyBpcyBwaWNrZWQgdXAgZXZlcnl3aGVyZSlcbiAgICBjb25zdCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjdHhXaXRoU3BhbkNvbnRleHQpO1xuICAgIGNvbnN0IG5ld1Njb3BlcyA9IHtcbiAgICAgIHNjb3BlOiBzY29wZXMgPyBzY29wZXMuc2NvcGUuY2xvbmUoKSA6IGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkuY2xvbmUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBzY29wZXMgPyBzY29wZXMuaXNvbGF0aW9uU2NvcGUgOiBjb3JlLmdldElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgICBuZXdTY29wZXMuc2NvcGUuc2V0UHJvcGFnYXRpb25Db250ZXh0KHByb3BhZ2F0aW9uQ29udGV4dCk7XG5cbiAgICByZXR1cm4gc2V0U2NvcGVzT25Db250ZXh0KGN0eFdpdGhTcGFuQ29udGV4dCwgbmV3U2NvcGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGZpZWxkcygpIHtcbiAgICByZXR1cm4gW1NFTlRSWV9UUkFDRV9IRUFERVIsIFNFTlRSWV9CQUdHQUdFX0hFQURFUl07XG4gIH1cblxuICAvKiogSWYgd2Ugd2FudCB0byBpbmplY3QgdHJhY2UgZGF0YSBmb3IgYSBnaXZlbiBVUkwuICovXG4gICBfc2hvdWxkSW5qZWN0VHJhY2VEYXRhKHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLCB1cmwpIHtcbiAgICBpZiAodHJhY2VQcm9wYWdhdGlvblRhcmdldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVkRGVjaXNpb24gPSB0aGlzLl91cmxNYXRjaGVzVGFyZ2V0c01hcC5nZXQodXJsKTtcbiAgICBpZiAoY2FjaGVkRGVjaXNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZERlY2lzaW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY2lzaW9uID0gdXRpbHMuc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuKHVybCwgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMpO1xuICAgIHRoaXMuX3VybE1hdGNoZXNUYXJnZXRzTWFwLnNldCh1cmwsIGRlY2lzaW9uKTtcbiAgICByZXR1cm4gZGVjaXNpb247XG4gIH1cbn1cblxuLyoqIEV4cG9ydGVkIGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIG1ha2VUcmFjZVN0YXRlKHtcbiAgcGFyZW50U3BhbklkLFxuICBkc2MsXG4gIHNhbXBsZWQsXG59XG5cbikge1xuICAvLyBXZSBzdG9yZSB0aGUgRFNDIGFzIE9URUwgdHJhY2Ugc3RhdGUgb24gdGhlIHNwYW4gY29udGV4dFxuICBjb25zdCBkc2NTdHJpbmcgPSBkc2MgPyB1dGlscy5keW5hbWljU2FtcGxpbmdDb250ZXh0VG9TZW50cnlCYWdnYWdlSGVhZGVyKGRzYykgOiB1bmRlZmluZWQ7XG5cbiAgLy8gV2UgX2Fsd2F5c18gc2V0IHRoZSBwYXJlbnQgc3BhbiBJRCwgZXZlbiBpZiBpdCBpcyBlbXB0eVxuICAvLyBJZiB3ZSdkIHNldCB0aGlzIHRvICd1bmRlZmluZWQnIHdlIGNvdWxkIG5vdCBrbm93IGlmIHRoZSB0cmFjZSBzdGF0ZSB3YXMgc2V0LCBidXQgdGhlcmUgd2FzIG5vIHBhcmVudFNwYW5JZCxcbiAgLy8gdnMgdGhlIHRyYWNlIHN0YXRlIHdhcyBub3Qgc2V0IGF0IGFsbCAoaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGRvIGZhbGxiYWNrIGhhbmRsaW5nKVxuICAvLyBJZiBgJydgLCBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBcIm5vIHBhcmVudFwiXG4gIGNvbnN0IHRyYWNlU3RhdGVCYXNlID0gbmV3IGNvcmUkMS5UcmFjZVN0YXRlKCkuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9QQVJFTlRfU1BBTl9JRCwgcGFyZW50U3BhbklkIHx8ICcnKTtcblxuICBjb25zdCB0cmFjZVN0YXRlV2l0aERzYyA9IGRzY1N0cmluZyA/IHRyYWNlU3RhdGVCYXNlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDLCBkc2NTdHJpbmcpIDogdHJhY2VTdGF0ZUJhc2U7XG5cbiAgLy8gV2UgYWxzbyBzcGVjaWZpY2FsbHkgd2FudCB0byBzdG9yZSBpZiB0aGlzIGlzIHNhbXBsZWQgdG8gYmUgbm90IHJlY29yZGluZyxcbiAgLy8gb3IgdW5zYW1wbGVkICg9Y291bGQgYmUgZWl0aGVyIHNhbXBsZWQgb3Igbm90KVxuICByZXR1cm4gc2FtcGxlZCA9PT0gZmFsc2UgPyB0cmFjZVN0YXRlV2l0aERzYy5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORywgJzEnKSA6IHRyYWNlU3RhdGVXaXRoRHNjO1xufVxuXG5mdW5jdGlvbiBnZXRJbmplY3Rpb25EYXRhKGNvbnRleHQpXG5cbiB7XG4gIGNvbnN0IHNwYW4gPSBjb3JlLmhhc1RyYWNpbmdFbmFibGVkKCkgPyBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgc3BhbklzUmVtb3RlID0gX29wdGlvbmFsQ2hhaW4kNihbc3BhbiwgJ29wdGlvbmFsQWNjZXNzJywgXzUgPT4gXzUuc3BhbkNvbnRleHQsICdjYWxsJywgXzYgPT4gXzYoKSwgJ2FjY2VzcycsIF83ID0+IF83LmlzUmVtb3RlXSk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGxvY2FsIHNwYW4sIHdlIGNhbiBqdXN0IHBpY2sgZXZlcnl0aGluZyBmcm9tIGl0XG4gIGlmIChzcGFuICYmICFzcGFuSXNSZW1vdGUpIHtcbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAgIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IGdldFByb3BhZ2F0aW9uQ29udGV4dEZyb21TcGFuKHNwYW4pO1xuICAgIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0KHByb3BhZ2F0aW9uQ29udGV4dCwgc3BhbkNvbnRleHQudHJhY2VJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICB0cmFjZUlkOiBzcGFuQ29udGV4dC50cmFjZUlkLFxuICAgICAgc3BhbklkOiBzcGFuQ29udGV4dC5zcGFuSWQsXG4gICAgICBzYW1wbGVkOiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSxcbiAgICB9O1xuICB9XG5cbiAgLy8gRWxzZSB3ZSB0cnkgdG8gdXNlIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0IGZyb20gdGhlIHNjb3BlXG4gIGNvbnN0IHNjb3BlID0gX29wdGlvbmFsQ2hhaW4kNihbZ2V0U2NvcGVzRnJvbUNvbnRleHQsICdjYWxsJywgXzggPT4gXzgoY29udGV4dCksICdvcHRpb25hbEFjY2VzcycsIF85ID0+IF85LnNjb3BlXSkgfHwgY29yZS5nZXRDdXJyZW50U2NvcGUoKTtcblxuICBjb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSBzY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKTtcbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHQocHJvcGFnYXRpb25Db250ZXh0LCBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCk7XG4gIHJldHVybiB7XG4gICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbiAgICB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCxcbiAgICBzcGFuSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5zcGFuSWQsXG4gICAgc2FtcGxlZDogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQsXG4gIH07XG59XG5cbi8qKiBHZXQgdGhlIERTQyBmcm9tIGEgY29udGV4dCwgb3IgZmFsbCBiYWNrIHRvIHVzZSB0aGUgb25lIGZyb20gdGhlIGNsaWVudC4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHQoXG4gIHByb3BhZ2F0aW9uQ29udGV4dCxcbiAgdHJhY2VJZCxcbikge1xuICAvLyBJZiB3ZSBoYXZlIGEgRFNDIG9uIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0LCB3ZSBqdXN0IHVzZSBpdFxuICBpZiAoX29wdGlvbmFsQ2hhaW4kNihbcHJvcGFnYXRpb25Db250ZXh0LCAnb3B0aW9uYWxBY2Nlc3MnLCBfMTAgPT4gXzEwLmRzY10pKSB7XG4gICAgcmV0dXJuIHByb3BhZ2F0aW9uQ29udGV4dC5kc2M7XG4gIH1cblxuICAvLyBFbHNlLCB3ZSB0cnkgdG8gZ2VuZXJhdGUgYSBuZXcgb25lXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG5cbiAgaWYgKGNsaWVudCkge1xuICAgIHJldHVybiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50KHRyYWNlSWQgfHwgcHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQsIGNsaWVudCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0V2l0aFJlbW90ZUFjdGl2ZVNwYW4oXG4gIGN0eCxcbiAgeyBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9LFxuKSB7XG4gIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHV0aWxzLnByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzKHNlbnRyeVRyYWNlLCBiYWdnYWdlKTtcblxuICAvLyBXZSBzdG9yZSB0aGUgRFNDIGFzIE9URUwgdHJhY2Ugc3RhdGUgb24gdGhlIHNwYW4gY29udGV4dFxuICBjb25zdCB0cmFjZVN0YXRlID0gbWFrZVRyYWNlU3RhdGUoe1xuICAgIHBhcmVudFNwYW5JZDogcHJvcGFnYXRpb25Db250ZXh0LnBhcmVudFNwYW5JZCxcbiAgICBkc2M6IHByb3BhZ2F0aW9uQ29udGV4dC5kc2MsXG4gICAgc2FtcGxlZDogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQsXG4gIH0pO1xuXG4gIGNvbnN0IHNwYW5Db250ZXh0ID0ge1xuICAgIHRyYWNlSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC50cmFjZUlkLFxuICAgIHNwYW5JZDogcHJvcGFnYXRpb25Db250ZXh0LnBhcmVudFNwYW5JZCB8fCAnJyxcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICB0cmFjZUZsYWdzOiBwcm9wYWdhdGlvbkNvbnRleHQuc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgIHRyYWNlU3RhdGUsXG4gIH07XG5cbiAgcmV0dXJuIGFwaS50cmFjZS5zZXRTcGFuQ29udGV4dChjdHgsIHNwYW5Db250ZXh0KTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0cmFjZSBzdHJpbmdzIGFuZCBwcm9wYWdhdGVzIHRoZW0gYXMgYSByZW1vdGUgYWN0aXZlIHNwYW4uXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIGFkZGl0aW9uIHRvIGBjb250aW51ZVRyYWNlYCBpbiBPVEVMLXBvd2VyZWQgZW52aXJvbm1lbnRzLlxuICovXG5mdW5jdGlvbiBjb250aW51ZVRyYWNlQXNSZW1vdGVTcGFuKFxuICBjdHgsXG4gIG9wdGlvbnMsXG4gIGNhbGxiYWNrLFxuKSB7XG4gIGNvbnN0IGN0eFdpdGhTcGFuQ29udGV4dCA9IGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3BhbihjdHgsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eFdpdGhTcGFuQ29udGV4dCwgY2FsbGJhY2spO1xufVxuXG4vKiogVHJ5IHRvIGdldCB0aGUgZXhpc3RpbmcgYmFnZ2FnZSBoZWFkZXIgc28gd2UgY2FuIG1lcmdlIHRoaXMgaW4uICovXG5mdW5jdGlvbiBnZXRFeGlzdGluZ0JhZ2dhZ2UoY2Fycmllcikge1xuICB0cnkge1xuICAgIGNvbnN0IGJhZ2dhZ2UgPSAoY2FycmllciApW1NFTlRSWV9CQUdHQUdFX0hFQURFUl07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYmFnZ2FnZSkgPyBiYWdnYWdlLmpvaW4oJywnKSA6IGJhZ2dhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogSXQgaXMgcHJldHR5IHRyaWNreSB0byBnZXQgYWNjZXNzIHRvIHRoZSBvdXRnb2luZyByZXF1ZXN0IFVSTCBvZiBhIHJlcXVlc3QgaW4gdGhlIHByb3BhZ2F0b3IuXG4gKiBBcyB3ZSBvbmx5IGhhdmUgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9mIHRoZSBzcGFuIHRvIGJlIHNlbnQgYW5kIHRoZSBjYXJyaWVyICg9aGVhZGVycyksXG4gKiBidXQgdGhlIHNwYW4gbWF5IGJlIHVuc2FtcGxlZCBhbmQgdGh1cyBoYXZlIG5vIGF0dHJpYnV0ZXMuXG4gKlxuICogU28gd2UgdXNlIHRoZSBmb2xsb3dpbmcgbG9naWM6XG4gKiAxLiBJZiB3ZSBoYXZlIGFuIGFjdGl2ZSBzcGFuLCB3ZSBjaGVjayBpZiBpdCBoYXMgYSBVUkwgYXR0cmlidXRlLlxuICogMi4gRWxzZSwgaWYgdGhlIGFjdGl2ZSBzcGFuIGhhcyBubyBVUkwgYXR0cmlidXRlIChlLmcuIGl0IGlzIHVuc2FtcGxlZCksIHdlIGNoZWNrIGEgc3BlY2lhbCB0cmFjZSBzdGF0ZSAod2hpY2ggd2Ugc2V0IGluIG91ciBzYW1wbGVyKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFVSTChzcGFuKSB7XG4gIGNvbnN0IHVybEF0dHJpYnV0ZSA9IF9vcHRpb25hbENoYWluJDYoW2NvcmUuc3BhblRvSlNPTiwgJ2NhbGwnLCBfMTEgPT4gXzExKHNwYW4pLCAnYWNjZXNzJywgXzEyID0+IF8xMi5kYXRhLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMTMgPT4gXzEzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdXSk7XG4gIGlmICh1cmxBdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gdXJsQXR0cmlidXRlO1xuICB9XG5cbiAgLy8gQWxzbyBsb29rIGF0IHRoZSB0cmFjZVN0YXRlLCB3aGljaCB3ZSBtYXkgc2V0IGluIHRoZSBzYW1wbGVyIGV2ZW4gZm9yIHVuc2FtcGxlZCBzcGFuc1xuICBjb25zdCB1cmxUcmFjZVN0YXRlID0gX29wdGlvbmFsQ2hhaW4kNihbc3BhbiwgJ2FjY2VzcycsIF8xNCA9PiBfMTQuc3BhbkNvbnRleHQsICdjYWxsJywgXzE1ID0+IF8xNSgpLCAnYWNjZXNzJywgXzE2ID0+IF8xNi50cmFjZVN0YXRlLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMTcgPT4gXzE3LmdldCwgJ2NhbGwnLCBfMTggPT4gXzE4KFNFTlRSWV9UUkFDRV9TVEFURV9VUkwpXSk7XG4gIGlmICh1cmxUcmFjZVN0YXRlKSB7XG4gICAgcmV0dXJuIHVybFRyYWNlU3RhdGU7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfb3B0aW9uYWxDaGFpbiQ1KG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgdHJhbnNhY3Rpb24vc3BhbiBhbmQgZmluaXNoZXMgdGhlIHNwYW4gYWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGRvbmUuXG4gKiBUaGUgY3JlYXRlZCBzcGFuIGlzIHRoZSBhY3RpdmUgc3BhbiBhbmQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBieSBvdGhlciBzcGFucyBjcmVhdGVkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIGFuZCBjYW4gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYCwgYXMgbG9uZyBhcyB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hpbGUgdGhlIHNjb3BlIGlzIGFjdGl2ZS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBzcGFuIHRoYXQgaXMgbm90IHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRJbmFjdGl2ZVNwYW59LlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuXG4gIGNvbnN0IHsgbmFtZSwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSBnZXRDb250ZXh0KG9wdGlvbnMuc2NvcGUsIG9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhYXBpLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBjdHggPSBzaG91bGRTa2lwU3BhbiA/IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYWN0aXZlQ3R4KSA6IGFjdGl2ZUN0eDtcblxuICAgIGNvbnN0IHNwYW5PcHRpb25zID0gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihuYW1lLCBzcGFuT3B0aW9ucywgY3R4LCBzcGFuID0+IHtcbiAgICAgIF9hcHBseVNlbnRyeUF0dHJpYnV0ZXNUb1NwYW4oc3Bhbiwgb3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBjb3JlLmhhbmRsZUNhbGxiYWNrRXJyb3JzKFxuICAgICAgICAoKSA9PiBjYWxsYmFjayhzcGFuKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgc2V0IHRoZSBzcGFuIHN0YXR1cyB0byBFUlJPUiB3aGVuIHRoZXJlIHdhc24ndCBhbnkgc3RhdHVzIHNldCBiZWZvcmUsIGluIG9yZGVyIHRvIGF2b2lkIHN0b21waW5nIHVzZWZ1bCBzcGFuIHN0YXR1c2VzXG4gICAgICAgICAgaWYgKGNvcmUuc3BhblRvSlNPTihzcGFuKS5zdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGkuU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiBzcGFuLmVuZCgpLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgU2VudHJ5LnN0YXJ0U3BhbmAuIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHNwYW4sIGJ1dCBkb2VzIG5vdCBmaW5pc2ggdGhlIHNwYW5cbiAqIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBkb25lIGF1dG9tYXRpY2FsbHkuIFlvdSdsbCBoYXZlIHRvIGNhbGwgYHNwYW4uZW5kKClgIG1hbnVhbGx5LlxuICpcbiAqIFRoZSBjcmVhdGVkIHNwYW4gaXMgdGhlIGFjdGl2ZSBzcGFuIGFuZCB3aWxsIGJlIHVzZWQgYXMgcGFyZW50IGJ5IG90aGVyIHNwYW5zIGNyZWF0ZWQgaW5zaWRlIHRoZSBmdW5jdGlvblxuICogYW5kIGNhbiBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLCBhcyBsb25nIGFzIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGlsZSB0aGUgc2NvcGUgaXMgYWN0aXZlLlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuTWFudWFsKFxuICBvcHRpb25zLFxuICBjYWxsYmFjayxcbikge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCwgc3BhbiA9PiB7XG4gICAgICBfYXBwbHlTZW50cnlBdHRyaWJ1dGVzVG9TcGFuKHNwYW4sIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gY29yZS5oYW5kbGVDYWxsYmFja0Vycm9ycyhcbiAgICAgICAgKCkgPT4gY2FsbGJhY2soc3BhbiwgKCkgPT4gc3Bhbi5lbmQoKSksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgc3BhbiBzdGF0dXMgdG8gRVJST1Igd2hlbiB0aGVyZSB3YXNuJ3QgYW55IHN0YXR1cyBzZXQgYmVmb3JlLCBpbiBvcmRlciB0byBhdm9pZCBzdG9tcGluZyB1c2VmdWwgc3BhbiBzdGF0dXNlc1xuICAgICAgICAgIGlmIChjb3JlLnNwYW5Ub0pTT04oc3Bhbikuc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzcGFuLiBUaGlzIHNwYW4gaXMgbm90IHNldCBhcyBhY3RpdmUsIHNvIHdpbGwgbm90IGdldCBhdXRvbWF0aWMgaW5zdHJ1bWVudGF0aW9uIHNwYW5zXG4gKiBhcyBjaGlsZHJlbiBvciBiZSBhYmxlIHRvIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgc3BhbiB0aGF0IGlzIHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRTcGFufS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJldHVybiBhIHNwYW4sXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydEluYWN0aXZlU3BhbihvcHRpb25zKSB7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuXG4gIGNvbnN0IHsgbmFtZSwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSBnZXRDb250ZXh0KG9wdGlvbnMuc2NvcGUsIG9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhYXBpLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBjdHggPSBzaG91bGRTa2lwU3BhbiA/IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYWN0aXZlQ3R4KSA6IGFjdGl2ZUN0eDtcblxuICAgIGNvbnN0IHNwYW5PcHRpb25zID0gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzcGFuID0gdHJhY2VyLnN0YXJ0U3BhbihuYW1lLCBzcGFuT3B0aW9ucywgY3R4KTtcblxuICAgIF9hcHBseVNlbnRyeUF0dHJpYnV0ZXNUb1NwYW4oc3Bhbiwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gc3BhbjtcbiAgfSk7XG59XG5cbi8qKlxuICogRm9ya3MgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHNldHMgdGhlIHByb3ZpZGVkIHNwYW4gYXMgYWN0aXZlIHNwYW4gaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLiBDYW4gYmVcbiAqIHBhc3NlZCBgbnVsbGAgdG8gc3RhcnQgYW4gZW50aXJlbHkgbmV3IHNwYW4gdHJlZS5cbiAqXG4gKiBAcGFyYW0gc3BhbiBTcGFucyBzdGFydGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGNoaWxkcmVuIG9mIHRoaXMgc3Bhbi4gSWYgYG51bGxgIGlzIHBhc3NlZCxcbiAqIHNwYW5zIHN0YXJ0ZWQgd2l0aGluIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJvb3Qgc3BhbnMuXG4gKiBAcGFyYW0gY2FsbGJhY2sgRXhlY3V0aW9uIGNvbnRleHQgaW4gd2hpY2ggdGhlIHByb3ZpZGVkIHNwYW4gd2lsbCBiZSBhY3RpdmUuIElzIHBhc3NlZCB0aGUgbmV3bHkgZm9ya2VkIHNjb3BlLlxuICogQHJldHVybnMgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB3aXRoQWN0aXZlU3BhbihzcGFuLCBjYWxsYmFjaykge1xuICBjb25zdCBuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4gPSBzcGFuID8gYXBpLnRyYWNlLnNldFNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pIDogYXBpLnRyYWNlLmRlbGV0ZVNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCkpO1xuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4sICgpID0+IGNhbGxiYWNrKGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2VyKCkge1xuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICByZXR1cm4gKGNsaWVudCAmJiBjbGllbnQudHJhY2VyKSB8fCBhcGkudHJhY2UuZ2V0VHJhY2VyKCdAc2VudHJ5L29wZW50ZWxlbWV0cnknLCBjb3JlLlNES19WRVJTSU9OKTtcbn1cblxuZnVuY3Rpb24gX2FwcGx5U2VudHJ5QXR0cmlidXRlc1RvU3BhbihzcGFuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgb3AgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKG9wKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QLCBvcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB7IHN0YXJ0VGltZSwgYXR0cmlidXRlcywga2luZCB9ID0gb3B0aW9ucztcblxuICAvLyBPVEVMIGV4cGVjdHMgdGltZXN0YW1wcyBpbiBtcywgbm90IHNlY29uZHNcbiAgY29uc3QgZml4ZWRTdGFydFRpbWUgPSB0eXBlb2Ygc3RhcnRUaW1lID09PSAnbnVtYmVyJyA/IGVuc3VyZVRpbWVzdGFtcEluTWlsbGlzZWNvbmRzKHN0YXJ0VGltZSkgOiBzdGFydFRpbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGtpbmQsXG4gICAgc3RhcnRUaW1lOiBmaXhlZFN0YXJ0VGltZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlVGltZXN0YW1wSW5NaWxsaXNlY29uZHModGltZXN0YW1wKSB7XG4gIGNvbnN0IGlzTXMgPSB0aW1lc3RhbXAgPCA5OTk5OTk5OTk5O1xuICByZXR1cm4gaXNNcyA/IHRpbWVzdGFtcCAqIDEwMDAgOiB0aW1lc3RhbXA7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoc2NvcGUsIGZvcmNlVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgY29uc3QgYWN0dWFsU2NvcGUgPSBfb3B0aW9uYWxDaGFpbiQ1KFtnZXRTY29wZXNGcm9tQ29udGV4dCwgJ2NhbGwnLCBfID0+IF8oY3R4KSwgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuc2NvcGVdKTtcblxuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY3R4KTtcblxuICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgbm8gcGFyZW50IHNwYW4sIHdlIG5lZWQgdG8gXCJzaW11bGF0ZVwiIG9uZSB0byBlbnN1cmUgdGhlIHByb3BhZ2F0aW9uIGNvbnRleHQgaXMgY29ycmVjdFxuICBpZiAoIXBhcmVudFNwYW4pIHtcbiAgICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuXG4gICAgaWYgKGFjdHVhbFNjb3BlICYmIGNsaWVudCkge1xuICAgICAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gYWN0dWFsU2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG5cbiAgICAgIC8vIFdlIHN0b3JlIHRoZSBEU0MgYXMgT1RFTCB0cmFjZSBzdGF0ZSBvbiB0aGUgc3BhbiBjb250ZXh0XG4gICAgICBjb25zdCB0cmFjZVN0YXRlID0gbWFrZVRyYWNlU3RhdGUoe1xuICAgICAgICBwYXJlbnRTcGFuSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5wYXJlbnRTcGFuSWQsXG4gICAgICAgIC8vIE5vdCBkZWZpbmVkIHlldCwgd2Ugd2FudCB0byBwaWNrIHRoaXMgdXAgb24tZGVtYW5kIG9ubHlcbiAgICAgICAgZHNjOiB1bmRlZmluZWQsXG4gICAgICAgIHNhbXBsZWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5zYW1wbGVkLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgICB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCxcbiAgICAgICAgc3BhbklkOiBwcm9wYWdhdGlvbkNvbnRleHQucGFyZW50U3BhbklkIHx8IHByb3BhZ2F0aW9uQ29udGV4dC5zcGFuSWQsXG4gICAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgICB0cmFjZUZsYWdzOiBwcm9wYWdhdGlvbkNvbnRleHQuc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgICAgICB0cmFjZVN0YXRlLFxuICAgICAgfTtcblxuICAgICAgLy8gQWRkIHJlbW90ZSBwYXJlbnQgc3BhbiBjb250ZXh0LFxuICAgICAgcmV0dXJuIGFwaS50cmFjZS5zZXRTcGFuQ29udGV4dChjdHgsIHNwYW5PcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vIHNjb3BlIG9yIGNsaWVudCwgd2UganVzdCByZXR1cm4gdGhlIGNvbnRleHQgYXMtaXNcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLy8gSWYgd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBhIHRyYW5zYWN0aW9uLCBhbmQgd2UgaGF2ZSBhIHBhcmVudCBzcGFuLCBhbGwgZ29vZCwgd2UganVzdCByZXR1cm4gYXMtaXMhXG4gIGlmICghZm9yY2VUcmFuc2FjdGlvbikge1xuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICAvLyBFbHNlLCBpZiB3ZSBkbyBoYXZlIGEgcGFyZW50IHNwYW4gYnV0IHdhbnQgdG8gZm9yY2UgYSB0cmFuc2FjdGlvbiwgd2UgaGF2ZSB0byBzaW11bGF0ZSBhIFwicm9vdFwiIGNvbnRleHRcblxuICAvLyBFbHNlLCB3ZSBuZWVkIHRvIGRvIHR3byB0aGluZ3M6XG4gIC8vIDEuIFVuc2V0IHRoZSBwYXJlbnQgc3BhbiBmcm9tIHRoZSBjb250ZXh0LCBzbyB3ZSdsbCBjcmVhdGUgYSBuZXcgcm9vdCBzcGFuXG4gIC8vIDIuIEVuc3VyZSB0aGUgcHJvcGFnYXRpb24gY29udGV4dCBpcyBjb3JyZWN0LCBzbyB3ZSdsbCBjb250aW51ZSBmcm9tIHRoZSBwYXJlbnQgc3BhblxuICBjb25zdCBjdHhXaXRob3V0U3BhbiA9IGFwaS50cmFjZS5kZWxldGVTcGFuKGN0eCk7XG5cbiAgY29uc3QgeyBzcGFuSWQsIHRyYWNlSWQgfSA9IHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKTtcbiAgY29uc3Qgc2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24ocGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpKTtcblxuICAvLyBJbiB0aGlzIGNhc2UsIHdoZW4gd2UgYXJlIGZvcmNpbmcgYSB0cmFuc2FjdGlvbiwgd2Ugd2FudCB0byB0cmVhdCB0aGlzIGxpa2UgY29udGludWluZyBhbiBpbmNvbWluZyB0cmFjZVxuICAvLyBzbyB3ZSBzZXQgdGhlIHRyYWNlU3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByb290IHNwYW5cbiAgY29uc3Qgcm9vdFNwYW4gPSBjb3JlLmdldFJvb3RTcGFuKHBhcmVudFNwYW4pO1xuICBjb25zdCBkc2MgPSBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3Bhbihyb290U3Bhbik7XG5cbiAgY29uc3QgdHJhY2VTdGF0ZSA9IG1ha2VUcmFjZVN0YXRlKHtcbiAgICBkc2MsXG4gICAgcGFyZW50U3BhbklkOiBzcGFuSWQgIT09IGFwaS5JTlZBTElEX1NQQU5JRCA/IHNwYW5JZCA6IHVuZGVmaW5lZCxcbiAgICBzYW1wbGVkLFxuICB9KTtcblxuICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5JZCxcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICB0cmFjZUZsYWdzOiBzYW1wbGVkID8gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCA6IGFwaS5UcmFjZUZsYWdzLk5PTkUsXG4gICAgdHJhY2VTdGF0ZSxcbiAgfTtcblxuICBjb25zdCBjdHhXaXRoU3BhbkNvbnRleHQgPSBhcGkudHJhY2Uuc2V0U3BhbkNvbnRleHQoY3R4V2l0aG91dFNwYW4sIHNwYW5PcHRpb25zKTtcblxuICByZXR1cm4gY3R4V2l0aFNwYW5Db250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSk7XG4gICAgaWYgKGN0eCkge1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG59XG5cbi8qKlxuICogQ29udGludWUgYSB0cmFjZSBmcm9tIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgdmFsdWVzLlxuICogVGhlc2UgdmFsdWVzIGNhbiBiZSBvYnRhaW5lZCBmcm9tIGluY29taW5nIHJlcXVlc3QgaGVhZGVycywgb3IgaW4gdGhlIGJyb3dzZXIgZnJvbSBgPG1ldGEgbmFtZT1cInNlbnRyeS10cmFjZVwiPmBcbiAqIGFuZCBgPG1ldGEgbmFtZT1cImJhZ2dhZ2VcIj5gIEhUTUwgdGFncy5cbiAqXG4gKiBTcGFucyBzdGFydGVkIHdpdGggYHN0YXJ0U3BhbmAsIGBzdGFydFNwYW5NYW51YWxgIGFuZCBgc3RhcnRJbmFjdGl2ZVNwYW5gLCB3aXRoaW4gdGhlIGNhbGxiYWNrIHdpbGwgYXV0b21hdGljYWxseVxuICogYmUgYXR0YWNoZWQgdG8gdGhlIGluY29taW5nIHRyYWNlLlxuICpcbiAqIFRoaXMgaXMgYSBjdXN0b20gdmVyc2lvbiBvZiBgY29udGludWVUcmFjZWAgdGhhdCBpcyB1c2VkIGluIE9URUwtcG93ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBJdCBwcm9wYWdhdGVzIHRoZSB0cmFjZSBhcyBhIHJlbW90ZSBzcGFuLCBpbiBhZGRpdGlvbiB0byBzZXR0aW5nIGl0IG9uIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBjb250aW51ZVRyYWNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjb3JlLmNvbnRpbnVlVHJhY2Uob3B0aW9ucywgKCkgPT4ge1xuICAgIHJldHVybiBjb250aW51ZVRyYWNlQXNSZW1vdGVTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVTcGFuV3JhcHBlcihwYXJlbnRTcGFuKSB7XG4gIHJldHVybiBwYXJlbnRTcGFuXG4gICAgPyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgLy8gV2UgY2FzdCB0aGlzLCBiZWNhdXNlIHRoZSBPVEVMIFNwYW4gaGFzIGEgZmV3IG1vcmUgbWV0aG9kcyB0aGFuIG91ciBTcGFuIGludGVyZmFjZVxuICAgICAgICAvLyBUT0RPOiBBZGQgdGhlc2UgbWlzc2luZyBtZXRob2RzIHRvIHRoZSBTcGFuIGludGVyZmFjZVxuICAgICAgICByZXR1cm4gd2l0aEFjdGl2ZVNwYW4ocGFyZW50U3BhbiAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICA6IChjYWxsYmFjaykgPT4gY2FsbGJhY2soKTtcbn1cblxuLyoqIFN1cHByZXNzIHRyYWNpbmcgaW4gdGhlIGdpdmVuIGNhbGxiYWNrLCBlbnN1cmluZyBubyBzcGFucyBhcmUgZ2VuZXJhdGVkIGluc2lkZSBvZiBpdC4gKi9cbmZ1bmN0aW9uIHN1cHByZXNzVHJhY2luZyhjYWxsYmFjaykge1xuICBjb25zdCBjdHggPSBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFwaS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDQob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cbi8qKiBFbnN1cmUgdGhlIGB0cmFjZWAgY29udGV4dCBpcyBzZXQgb24gYWxsIGV2ZW50cy4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRDb250ZXh0VHJhY2UoY2xpZW50KSB7XG4gIGNsaWVudC5vbigncHJlcHJvY2Vzc0V2ZW50JywgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNwYW4gPSBnZXRBY3RpdmVTcGFuKCk7XG4gICAgLy8gRm9yIHRyYW5zYWN0aW9uIGV2ZW50cywgdGhpcyBpcyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAvLyBCZWNhdXNlIHRoZSBhY3RpdmUgc3BhbiBtYXkgbm90IGJlIHRoZSBzcGFuIHRoYXQgaXMgYWN0dWFsbHkgdGhlIHRyYW5zYWN0aW9uIGV2ZW50XG4gICAgaWYgKCFzcGFuIHx8IGV2ZW50LnR5cGUgPT09ICd0cmFuc2FjdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBwYXJlbnQgc3BhbiBpZCBmcm9tIHRyYWNlIHN0YXRlLCB1c2UgdGhhdCAoJycgbWVhbnMgbm8gcGFyZW50IHNob3VsZCBiZSB1c2VkKVxuICAgIC8vIEVsc2UsIHBpY2sgdGhlIG9uZSBmcm9tIHRoZSBzcGFuXG4gICAgY29uc3QgcGFyZW50U3BhbklkRnJvbVRyYWNlU3RhdGUgPSBfb3B0aW9uYWxDaGFpbiQ0KFtzcGFuQ29udGV4dCwgJ2FjY2VzcycsIF8gPT4gXy50cmFjZVN0YXRlLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMiA9PiBfMi5nZXQsICdjYWxsJywgXzMgPT4gXzMoU0VOVFJZX1RSQUNFX1NUQVRFX1BBUkVOVF9TUEFOX0lEKV0pO1xuICAgIGNvbnN0IHBhcmVudF9zcGFuX2lkID1cbiAgICAgIHR5cGVvZiBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSB8fCB1bmRlZmluZWRcbiAgICAgICAgOiBzcGFuSGFzUGFyZW50SWQoc3BhbilcbiAgICAgICAgICA/IHNwYW4ucGFyZW50U3BhbklkXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiBldmVudCBoYXMgYWxyZWFkeSBzZXQgYHRyYWNlYCBjb250ZXh0LCB1c2UgdGhhdCBvbmUuXG4gICAgZXZlbnQuY29udGV4dHMgPSB7XG4gICAgICB0cmFjZTogdXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgICAgICB0cmFjZV9pZDogc3BhbkNvbnRleHQudHJhY2VJZCxcbiAgICAgICAgc3Bhbl9pZDogc3BhbkNvbnRleHQuc3BhbklkLFxuICAgICAgICBwYXJlbnRfc3Bhbl9pZCxcbiAgICAgIH0pLFxuICAgICAgLi4uZXZlbnQuY29udGV4dHMsXG4gICAgfTtcblxuICAgIGNvbnN0IHJvb3RTcGFuID0gY29yZS5nZXRSb290U3BhbihzcGFuKTtcblxuICAgIGV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQ6IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHJvb3RTcGFuKSxcbiAgICAgIC4uLmV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBhc3luYyBjb250ZXh0IHN0cmF0ZWd5IHRvIHVzZSBmb2xsb3cgdGhlIE9URUwgY29udGV4dCB1bmRlciB0aGUgaG9vZC5cbiAqIFdlIGhhbmRsZSBmb3JraW5nIGEgaHViIGluc2lkZSBvZiBvdXIgY3VzdG9tIE9URUwgQ29udGV4dCBNYW5hZ2VyICguL290ZWxDb250ZXh0TWFuYWdlci50cylcbiAqL1xuZnVuY3Rpb24gc2V0T3BlblRlbGVtZXRyeUNvbnRleHRBc3luY0NvbnRleHRTdHJhdGVneSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2NvcGVzKCkge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KGN0eCk7XG5cbiAgICBpZiAoc2NvcGVzKSB7XG4gICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIGJlaGF2aW9yOlxuICAgIC8vIGlmLCBmb3Igd2hhdGV2ZXIgcmVhc29uLCB3ZSBjYW4ndCBmaW5kIHNjb3BlcyBvbiB0aGUgY29udGV4dCBoZXJlLCB3ZSBoYXZlIHRvIGZpeCB0aGlzIHNvbWVob3dcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IGNvcmUuZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpLFxuICAgICAgaXNvbGF0aW9uU2NvcGU6IGNvcmUuZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTY29wZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICAvLyBhcyBieSBkZWZhdWx0LCB3ZSBkb24ndCB3YW50IHRvIGZvcmsgdGhpcywgdW5sZXNzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGB3aXRoU2NvcGVgXG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0Q3VycmVudFNjb3BlKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFNldFNjb3BlKHNjb3BlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCBwaWNrcyB1cCB0aGlzIHNjb3BlIGFzIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LnNldFZhbHVlKFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSwgc2NvcGUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soc2NvcGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aElzb2xhdGlvblNjb3BlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHVzZXMgdGhlIHByZXNlbmNlIG9mIHRoaXMga2V5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGRcbiAgICAvLyBmb3JrIHRoZSBpc29sYXRpb24gc2NvcGUsIG9yIG5vdFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVksIHRydWUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0SXNvbGF0aW9uU2NvcGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoU2V0SXNvbGF0aW9uU2NvcGUoaXNvbGF0aW9uU2NvcGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHVzZXMgdGhlIHByZXNlbmNlIG9mIHRoaXMga2V5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGRcbiAgICAvLyBmb3JrIHRoZSBpc29sYXRpb24gc2NvcGUsIG9yIG5vdFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZLCBpc29sYXRpb25TY29wZSksICgpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhnZXRJc29sYXRpb25TY29wZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKCkuc2NvcGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc29sYXRpb25TY29wZSgpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKCkuaXNvbGF0aW9uU2NvcGU7XG4gIH1cblxuICBjb3JlLnNldEFzeW5jQ29udGV4dFN0cmF0ZWd5KHtcbiAgICB3aXRoU2NvcGUsXG4gICAgd2l0aFNldFNjb3BlLFxuICAgIHdpdGhTZXRJc29sYXRpb25TY29wZSxcbiAgICB3aXRoSXNvbGF0aW9uU2NvcGUsXG4gICAgZ2V0Q3VycmVudFNjb3BlLFxuICAgIGdldElzb2xhdGlvblNjb3BlLFxuICAgIHN0YXJ0U3BhbixcbiAgICBzdGFydFNwYW5NYW51YWwsXG4gICAgc3RhcnRJbmFjdGl2ZVNwYW4sXG4gICAgZ2V0QWN0aXZlU3BhbixcbiAgICAvLyBUaGUgdHlwZXMgaGVyZSBkb24ndCBmdWxseSBhbGlnbiwgYmVjYXVzZSBvdXIgb3duIGBTcGFuYCB0eXBlIGlzIG5hcnJvd2VyXG4gICAgLy8gdGhhbiB0aGUgT1RFTCBvbmUgLSBidXQgdGhpcyBpcyBPSyBmb3IgaGVyZSwgYXMgd2Ugbm93IHdlJ2xsIG9ubHkgaGF2ZSBPVEVMIHNwYW5zIHBhc3NlZCBhcm91bmRcbiAgICB3aXRoQWN0aXZlU3Bhbjogd2l0aEFjdGl2ZVNwYW4gLFxuICAgIHN1cHByZXNzVHJhY2luZzogc3VwcHJlc3NUcmFjaW5nLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kMyhvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG4vKipcbiAqIFdyYXAgYW4gT3BlblRlbGVtZXRyeSBDb250ZXh0TWFuYWdlciBpbiBhIHdheSB0aGF0IGVuc3VyZXMgdGhlIGNvbnRleHQgaXMga2VwdCBpbiBzeW5jIHdpdGggdGhlIFNlbnRyeSBTY29wZS5cbiAqXG4gKiBVc2FnZTpcbiAqIGltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIgfSBmcm9tICdAb3BlbnRlbGVtZXRyeS9jb250ZXh0LWFzeW5jLWhvb2tzJztcbiAqIGNvbnN0IFNlbnRyeUNvbnRleHRNYW5hZ2VyID0gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MoQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlcik7XG4gKiBjb25zdCBjb250ZXh0TWFuYWdlciA9IG5ldyBTZW50cnlDb250ZXh0TWFuYWdlcigpO1xuICovXG5mdW5jdGlvbiB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcyhcbiAgQ29udGV4dE1hbmFnZXJDbGFzcyxcbikge1xuICAvKipcbiAgICogVGhpcyBpcyBhIGN1c3RvbSBDb250ZXh0TWFuYWdlciBmb3IgT3BlblRlbGVtZXRyeSwgd2hpY2ggZXh0ZW5kcyB0aGUgZGVmYXVsdCBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyLlxuICAgKiBJdCBlbnN1cmVzIHRoYXQgd2UgY3JlYXRlIG5ldyBzY29wZXMgcGVyIGNvbnRleHQsIHNvIHRoYXQgdGhlIE9URUwgQ29udGV4dCAmIHRoZSBTZW50cnkgU2NvcGUgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2UgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBBc3luY0hvb2tzIHdpdGggdGhpcyxcbiAgICogYnV0IHNpbmNlIHRoaXMgc2hvdWxkIHdvcmsgZm9yIE5vZGUgMTQrIGFueWhvdyB0aGF0IHNob3VsZCBiZSBnb29kIGVub3VnaC5cbiAgICovXG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBkb2VzIG5vdCBsaWtlIHRoaXMsIGJ1dCB3ZSBrbm93IHRoaXMgaXMgZmluZVxuICBjbGFzcyBTZW50cnlDb250ZXh0TWFuYWdlciBleHRlbmRzIENvbnRleHRNYW5hZ2VyQ2xhc3Mge1xuICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIHNldElzU2V0dXAoJ1NlbnRyeUNvbnRleHRNYW5hZ2VyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZSB3aXRoKCkgb2YgdGhlIG9yaWdpbmFsIEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXJcbiAgICAgKiB0byBlbnN1cmUgd2UgYWxzbyBjcmVhdGUgbmV3IHNjb3BlcyBwZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICAgd2l0aChcbiAgICAgIGNvbnRleHQsXG4gICAgICBmbixcbiAgICAgIHRoaXNBcmcsXG4gICAgICAuLi5hcmdzXG4gICAgKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBfb3B0aW9uYWxDaGFpbiQzKFtjdXJyZW50U2NvcGVzLCAnb3B0aW9uYWxBY2Nlc3MnLCBfID0+IF8uc2NvcGVdKSB8fCBjb3JlLmdldEN1cnJlbnRTY29wZSgpO1xuICAgICAgY29uc3QgY3VycmVudElzb2xhdGlvblNjb3BlID0gX29wdGlvbmFsQ2hhaW4kMyhbY3VycmVudFNjb3BlcywgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuaXNvbGF0aW9uU2NvcGVdKSB8fCBjb3JlLmdldElzb2xhdGlvblNjb3BlKCk7XG5cbiAgICAgIGNvbnN0IHNob3VsZEZvcmtJc29sYXRpb25TY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKSA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IHNjb3BlID0gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkpIDtcbiAgICAgIGNvbnN0IGlzb2xhdGlvblNjb3BlID0gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKSA7XG5cbiAgICAgIGNvbnN0IG5ld0N1cnJlbnRTY29wZSA9IHNjb3BlIHx8IGN1cnJlbnRTY29wZS5jbG9uZSgpO1xuICAgICAgY29uc3QgbmV3SXNvbGF0aW9uU2NvcGUgPVxuICAgICAgICBpc29sYXRpb25TY29wZSB8fCAoc2hvdWxkRm9ya0lzb2xhdGlvblNjb3BlID8gY3VycmVudElzb2xhdGlvblNjb3BlLmNsb25lKCkgOiBjdXJyZW50SXNvbGF0aW9uU2NvcGUpO1xuICAgICAgY29uc3Qgc2NvcGVzID0geyBzY29wZTogbmV3Q3VycmVudFNjb3BlLCBpc29sYXRpb25TY29wZTogbmV3SXNvbGF0aW9uU2NvcGUgfTtcblxuICAgICAgY29uc3QgY3R4MSA9IHNldFNjb3Blc09uQ29udGV4dChjb250ZXh0LCBzY29wZXMpO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIHVubmVlZGVkIHZhbHVlcyBhZ2FpblxuICAgICAgY29uc3QgY3R4MiA9IGN0eDFcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSlcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSlcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpO1xuXG4gICAgICBzZXRDb250ZXh0T25TY29wZShuZXdDdXJyZW50U2NvcGUsIGN0eDIpO1xuXG4gICAgICByZXR1cm4gc3VwZXIud2l0aChjdHgyLCBmbiwgdGhpc0FyZywgLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFNlbnRyeUNvbnRleHRNYW5hZ2VyIDtcbn1cblxuLyoqIElmIHRoaXMgYXR0cmlidXRlIGlzIHRydWUsIGl0IG1lYW5zIHRoYXQgdGhlIHBhcmVudCBpcyBhIHJlbW90ZSBzcGFuLiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFID0gJ3NlbnRyeS5wYXJlbnRJc1JlbW90ZSc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBydW5zIHRocm91Z2ggYSBsaXN0IG9mIE9URUwgU3BhbnMsIGFuZCB3cmFwcyB0aGVtIGluIGFuIGBTcGFuTm9kZWBcbiAqIHdoZXJlIGVhY2ggbm9kZSBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGVpciBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBTcGFuc1dpdGhQYXJlbnRzKHNwYW5zKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgY3JlYXRlT3JVcGRhdGVTcGFuTm9kZUFuZFJlZnMobm9kZU1hcCwgc3Bhbik7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShub2RlTWFwLCBmdW5jdGlvbiAoW19pZCwgc3Bhbk5vZGVdKSB7XG4gICAgcmV0dXJuIHNwYW5Ob2RlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHJldHVybnMgdGhlIF9sb2NhbF8gcGFyZW50IElEIC0gYHBhcmVudElkYCBvbiB0aGUgc3BhbiBtYXkgcG9pbnQgdG8gYSByZW1vdGUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKSB7XG4gIGNvbnN0IHBhcmVudElzUmVtb3RlID0gc3Bhbi5hdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URV0gPT09IHRydWU7XG4gIC8vIElmIHRoZSBwYXJlbnRJZCBpcyB0aGUgdHJhY2UgcGFyZW50IElELCB3ZSBwcmV0ZW5kIGl0J3MgdW5kZWZpbmVkXG4gIC8vIEFzIHRoaXMgbWVhbnMgdGhlIHBhcmVudCBleGlzdHMgc29tZXdoZXJlIGVsc2VcbiAgcmV0dXJuICFwYXJlbnRJc1JlbW90ZSA/IHNwYW4ucGFyZW50U3BhbklkIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVNwYW5Ob2RlQW5kUmVmcyhub2RlTWFwLCBzcGFuKSB7XG4gIGNvbnN0IGlkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgY29uc3QgcGFyZW50SWQgPSBnZXRMb2NhbFBhcmVudElkKHNwYW4pO1xuXG4gIGlmICghcGFyZW50SWQpIHtcbiAgICBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgeyBpZCwgc3BhbiwgY2hpbGRyZW46IFtdIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVsc2UgbWFrZSBzdXJlIHRvIGNyZWF0ZSBwYXJlbnQgbm9kZSBhcyB3ZWxsXG4gIC8vIE5vdGUgdGhhdCB0aGUgcGFyZW50IG1heSBub3Qga25vdyBpdCdzIHBhcmVudCBfeWV0XywgdGhpcyBtYXkgYmUgdXBkYXRlZCBpbiBhIGxhdGVyIHBhc3NcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGNyZWF0ZU9yR2V0UGFyZW50Tm9kZShub2RlTWFwLCBwYXJlbnRJZCk7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgeyBpZCwgc3BhbiwgcGFyZW50Tm9kZSwgY2hpbGRyZW46IFtdIH0pO1xuICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yR2V0UGFyZW50Tm9kZShub2RlTWFwLCBpZCkge1xuICBjb25zdCBleGlzdGluZyA9IG5vZGVNYXAuZ2V0KGlkKTtcblxuICBpZiAoZXhpc3RpbmcpIHtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIGNoaWxkcmVuOiBbXSB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHNwYW5Ob2RlKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gbm9kZU1hcC5nZXQoc3Bhbk5vZGUuaWQpO1xuXG4gIC8vIElmIHNwYW4gaXMgYWxyZWFkeSBzZXQsIG5vdGhpbmcgdG8gZG8gaGVyZVxuICBpZiAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc3Bhbikge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIC8vIElmIGl0IGV4aXN0cyBidXQgc3BhbiBpcyBub3Qgc2V0IHlldCwgd2UgdXBkYXRlIGl0XG4gIGlmIChleGlzdGluZyAmJiAhZXhpc3Rpbmcuc3Bhbikge1xuICAgIGV4aXN0aW5nLnNwYW4gPSBzcGFuTm9kZS5zcGFuO1xuICAgIGV4aXN0aW5nLnBhcmVudE5vZGUgPSBzcGFuTm9kZS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIC8vIEVsc2UsIHdlIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgbm9kZU1hcC5zZXQoc3Bhbk5vZGUuaWQsIHNwYW5Ob2RlKTtcbiAgcmV0dXJuIHNwYW5Ob2RlO1xufVxuXG4vLyBjYW5vbmljYWxDb2Rlc0dycGNNYXAgbWFwcyBzb21lIEdSUEMgY29kZXMgdG8gU2VudHJ5J3Mgc3BhbiBzdGF0dXNlcy4gU2VlIGRlc2NyaXB0aW9uIGluIGdycGMgZG9jdW1lbnRhdGlvbi5cbmNvbnN0IGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwID0ge1xuICAnMSc6ICdjYW5jZWxsZWQnLFxuICAnMic6ICd1bmtub3duX2Vycm9yJyxcbiAgJzMnOiAnaW52YWxpZF9hcmd1bWVudCcsXG4gICc0JzogJ2RlYWRsaW5lX2V4Y2VlZGVkJyxcbiAgJzUnOiAnbm90X2ZvdW5kJyxcbiAgJzYnOiAnYWxyZWFkeV9leGlzdHMnLFxuICAnNyc6ICdwZXJtaXNzaW9uX2RlbmllZCcsXG4gICc4JzogJ3Jlc291cmNlX2V4aGF1c3RlZCcsXG4gICc5JzogJ2ZhaWxlZF9wcmVjb25kaXRpb24nLFxuICAnMTAnOiAnYWJvcnRlZCcsXG4gICcxMSc6ICdvdXRfb2ZfcmFuZ2UnLFxuICAnMTInOiAndW5pbXBsZW1lbnRlZCcsXG4gICcxMyc6ICdpbnRlcm5hbF9lcnJvcicsXG4gICcxNCc6ICd1bmF2YWlsYWJsZScsXG4gICcxNSc6ICdkYXRhX2xvc3MnLFxuICAnMTYnOiAndW5hdXRoZW50aWNhdGVkJyxcbn0gO1xuXG5jb25zdCBpc1N0YXR1c0Vycm9yTWVzc2FnZVZhbGlkID0gKG1lc3NhZ2UpID0+IHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXApLmluY2x1ZGVzKG1lc3NhZ2UgKTtcbn07XG5cbi8qKlxuICogR2V0IGEgU2VudHJ5IHNwYW4gc3RhdHVzIGZyb20gYW4gb3RlbCBzcGFuLlxuICovXG5mdW5jdGlvbiBtYXBTdGF0dXMoc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikgPyBzcGFuLmF0dHJpYnV0ZXMgOiB7fTtcbiAgY29uc3Qgc3RhdHVzID0gc3Bhbkhhc1N0YXR1cyhzcGFuKSA/IHNwYW4uc3RhdHVzIDogdW5kZWZpbmVkO1xuXG4gIGlmIChzdGF0dXMpIHtcbiAgICAvLyBTaW5jZSBzcGFuIHN0YXR1cyBPSyBpcyBub3Qgc2V0IGJ5IGRlZmF1bHQsIHdlIGdpdmUgaXQgcHJpb3JpdHk6IGh0dHBzOi8vb3BlbnRlbGVtZXRyeS5pby9kb2NzL2NvbmNlcHRzL3NpZ25hbHMvdHJhY2VzLyNzcGFuLXN0YXR1c1xuICAgIGlmIChzdGF0dXMuY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLk9LKSB7XG4gICAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX09LIH07XG4gICAgICAvLyBJZiB0aGUgc3BhbiBpcyBhbHJlYWR5IG1hcmtlZCBhcyBlcnJvbmVvdXMgd2UgcmV0dXJuIHRoYXQgZXhhY3Qgc3RhdHVzXG4gICAgfSBlbHNlIGlmIChzdGF0dXMuY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXR1cy5tZXNzYWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBpbmZlcnJlZFN0YXR1cyA9IGluZmVyU3RhdHVzRnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChpbmZlcnJlZFN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBpbmZlcnJlZFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHVzLm1lc3NhZ2UgJiYgaXNTdGF0dXNFcnJvck1lc3NhZ2VWYWxpZChzdGF0dXMubWVzc2FnZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogc3RhdHVzLm1lc3NhZ2UgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBzcGFuIHN0YXR1cyBpcyBVTlNFVCwgd2UgdHJ5IHRvIGluZmVyIGl0IGZyb20gSFRUUCBvciBHUlBDIHN0YXR1cyBjb2Rlcy5cbiAgY29uc3QgaW5mZXJyZWRTdGF0dXMgPSBpbmZlclN0YXR1c0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuXG4gIGlmIChpbmZlcnJlZFN0YXR1cykge1xuICAgIHJldHVybiBpbmZlcnJlZFN0YXR1cztcbiAgfVxuXG4gIC8vIFdlIGRlZmF1bHQgdG8gc2V0dGluZyB0aGUgc3BhbnMgc3RhdHVzIHRvIG9rLlxuICBpZiAoc3RhdHVzICYmIHN0YXR1cy5jb2RlID09PSBhcGkuU3BhblN0YXR1c0NvZGUuVU5TRVQpIHtcbiAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX09LIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Vua25vd25fZXJyb3InIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5mZXJTdGF0dXNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gIC8vIElmIHRoZSBzcGFuIHN0YXR1cyBpcyBVTlNFVCwgd2UgdHJ5IHRvIGluZmVyIGl0IGZyb20gSFRUUCBvciBHUlBDIHN0YXR1cyBjb2Rlcy5cblxuICBjb25zdCBodHRwQ29kZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgY29uc3QgZ3JwY0NvZGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfUlBDX0dSUENfU1RBVFVTX0NPREVdO1xuXG4gIGNvbnN0IG51bWJlckh0dHBDb2RlID1cbiAgICB0eXBlb2YgaHR0cENvZGVBdHRyaWJ1dGUgPT09ICdudW1iZXInXG4gICAgICA/IGh0dHBDb2RlQXR0cmlidXRlXG4gICAgICA6IHR5cGVvZiBodHRwQ29kZUF0dHJpYnV0ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBwYXJzZUludChodHRwQ29kZUF0dHJpYnV0ZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHR5cGVvZiBudW1iZXJIdHRwQ29kZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29yZS5nZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlKG51bWJlckh0dHBDb2RlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ3JwY0NvZGVBdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXBbZ3JwY0NvZGVBdHRyaWJ1dGVdIHx8ICd1bmtub3duX2Vycm9yJyB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kMihvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG5jb25zdCBNQVhfU1BBTl9DT1VOVCA9IDEwMDA7XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSAzMDA7IC8vIDUgbWluXG5cbi8qKlxuICogQSBTZW50cnktc3BlY2lmaWMgZXhwb3J0ZXIgdGhhdCBjb252ZXJ0cyBPcGVuVGVsZW1ldHJ5IFNwYW5zIHRvIFNlbnRyeSBTcGFucyAmIFRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgU2VudHJ5U3BhbkV4cG9ydGVyIHtcblxuICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICB0aGlzLl90aW1lb3V0ID0gX29wdGlvbmFsQ2hhaW4kMihbb3B0aW9ucywgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnRpbWVvdXRdKSB8fCBERUZBVUxUX1RJTUVPVVQ7XG4gIH1cblxuICAvKiogRXhwb3J0IGEgc2luZ2xlIHNwYW4uICovXG4gICBleHBvcnQoc3Bhbikge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMucHVzaChzcGFuKTtcblxuICAgIC8vIElmIHRoZSBzcGFuIGhhcyBhIGxvY2FsIHBhcmVudCBJRCwgd2UgZG9uJ3QgbmVlZCB0byBleHBvcnQgYW55dGhpbmcganVzdCB5ZXRcbiAgICBpZiAoZ2V0TG9jYWxQYXJlbnRJZChzcGFuKSkge1xuICAgICAgY29uc3Qgb3BlblNwYW5Db3VudCA9IHRoaXMuX2ZpbmlzaGVkU3BhbnMubGVuZ3RoO1xuICAgICAgREVCVUdfQlVJTEQgJiYgdXRpbHMubG9nZ2VyLmxvZyhgU3BhbkV4cG9ydGVyIGhhcyAke29wZW5TcGFuQ291bnR9IHVuc2VudCBzcGFucyByZW1haW5pbmdgKTtcbiAgICAgIHRoaXMuX2NsZWFudXBPbGRTcGFucygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgLy8gSWYgd2UgZ290IGEgcGFyZW50IHNwYW4sIHdlIHRyeSB0byBzZW5kIHRoZSBzcGFuIHRyZWVcbiAgICAvLyBXYWl0IGEgdGljayBmb3IgdGhpcywgdG8gZW5zdXJlIHdlIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgIHRoaXMuX2ZsdXNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH0sIDEpO1xuICB9XG5cbiAgLyoqIFRyeSB0byBmbHVzaCBhbnkgcGVuZGluZyBzcGFucyBpbW1lZGlhdGVseS4gKi9cbiAgIGZsdXNoKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgY29uc3Qgb3BlblNwYW5Db3VudCA9IHRoaXMuX2ZpbmlzaGVkU3BhbnMubGVuZ3RoO1xuXG4gICAgY29uc3QgcmVtYWluaW5nU3BhbnMgPSBtYXliZVNlbmQodGhpcy5fZmluaXNoZWRTcGFucyk7XG5cbiAgICBjb25zdCByZW1haW5pbmdPcGVuU3BhbkNvdW50ID0gcmVtYWluaW5nU3BhbnMubGVuZ3RoO1xuICAgIGNvbnN0IHNlbnRTcGFuQ291bnQgPSBvcGVuU3BhbkNvdW50IC0gcmVtYWluaW5nT3BlblNwYW5Db3VudDtcblxuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICB1dGlscy5sb2dnZXIubG9nKGBTcGFuRXhwb3J0ZXIgZXhwb3J0ZWQgJHtzZW50U3BhbkNvdW50fSBzcGFucywgJHtyZW1haW5pbmdPcGVuU3BhbkNvdW50fSB1bnNlbnQgc3BhbnMgcmVtYWluaW5nYCk7XG5cbiAgICB0aGlzLl9jbGVhbnVwT2xkU3BhbnMocmVtYWluaW5nU3BhbnMpO1xuICB9XG5cbiAgLyoqIENsZWFyIHRoZSBleHBvcnRlci4gKi9cbiAgIGNsZWFyKCkge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgfVxuXG4gIC8qKiBDbGVhciB0aGUgZmx1c2ggdGltZW91dC4gKi9cbiAgIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2ZsdXNoVGltZW91dCk7XG4gICAgICB0aGlzLl9mbHVzaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgc3BhbiB0aGF0IGlzIG9sZGVyIHRoYW4gNW1pbi5cbiAgICogV2UgZG8gdGhpcyB0byBhdm9pZCBsZWFraW5nIG1lbW9yeS5cbiAgICovXG4gICBfY2xlYW51cE9sZFNwYW5zKHNwYW5zID0gdGhpcy5fZmluaXNoZWRTcGFucykge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBzcGFucy5maWx0ZXIoc3BhbiA9PiB7XG4gICAgICBjb25zdCBzaG91bGREcm9wID0gc2hvdWxkQ2xlYW51cFNwYW4oc3BhbiwgdGhpcy5fdGltZW91dCk7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBzaG91bGREcm9wICYmXG4gICAgICAgIHV0aWxzLmxvZ2dlci5sb2coXG4gICAgICAgICAgYFNwYW5FeHBvcnRlciBkcm9wcGluZyBzcGFuICR7c3Bhbi5uYW1lfSAoJHtcbiAgICAgICAgICAgIHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWRcbiAgICAgICAgICB9KSBiZWNhdXNlIGl0IGlzIHBlbmRpbmcgZm9yIG1vcmUgdGhhbiA1IG1pbnV0ZXMuYCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiAhc2hvdWxkRHJvcDtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGhlIGdpdmVuIHNwYW5zLCBidXQgb25seSBpZiB0aGV5IGFyZSBwYXJ0IG9mIGEgZmluaXNoZWQgdHJhbnNhY3Rpb24uXG4gKlxuICogUmV0dXJucyB0aGUgdW5zZW50IHNwYW5zLlxuICogU3BhbnMgcmVtYWluIHVuc2VudCB3aGVuIHRoZWlyIHBhcmVudCBzcGFuIGlzIG5vdCB5ZXQgZmluaXNoZWQuXG4gKiBUaGlzIHdpbGwgaGFwcGVuIHJlZ3VsYXJseSwgYXMgY2hpbGQgc3BhbnMgYXJlIGdlbmVyYWxseSBmaW5pc2hlZCBiZWZvcmUgdGhlaXIgcGFyZW50cy5cbiAqIEJ1dCBpdCBfY291bGRfIGFsc28gaGFwcGVuIGJlY2F1c2UsIGZvciB3aGF0ZXZlciByZWFzb24sIGEgcGFyZW50IHNwYW4gd2FzIGxvc3QuXG4gKiBJbiB0aGlzIGNhc2UsIHdlJ2xsIGV2ZW50dWFsbHkgbmVlZCB0byBjbGVhbiB0aGlzIHVwLlxuICovXG5mdW5jdGlvbiBtYXliZVNlbmQoc3BhbnMpIHtcbiAgY29uc3QgZ3JvdXBlZCA9IGdyb3VwU3BhbnNXaXRoUGFyZW50cyhzcGFucyk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IG5ldyBTZXQoZ3JvdXBlZCk7XG5cbiAgY29uc3Qgcm9vdE5vZGVzID0gZ2V0Q29tcGxldGVkUm9vdE5vZGVzKGdyb3VwZWQpO1xuXG4gIHJvb3ROb2Rlcy5mb3JFYWNoKHJvb3QgPT4ge1xuICAgIHJlbWFpbmluZy5kZWxldGUocm9vdCk7XG4gICAgY29uc3Qgc3BhbiA9IHJvb3Quc3BhbjtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25Gb3JPdGVsU3BhbihzcGFuKTtcblxuICAgIC8vIFdlJ2xsIHJlY3Vyc2l2ZWx5IGFkZCBhbGwgdGhlIGNoaWxkIHNwYW5zIHRvIHRoaXMgYXJyYXlcbiAgICBjb25zdCBzcGFucyA9IHRyYW5zYWN0aW9uRXZlbnQuc3BhbnMgfHwgW107XG5cbiAgICByb290LmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgcmVtYWluaW5nKTtcbiAgICB9KTtcblxuICAgIC8vIHNwYW5zLnNvcnQoKSBtdXRhdGVzIHRoZSBhcnJheSwgYnV0IHdlIGRvIG5vdCB1c2UgdGhpcyBhbnltb3JlIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IG11dGF0ZSBpdCBoZXJlXG4gICAgdHJhbnNhY3Rpb25FdmVudC5zcGFucyA9XG4gICAgICBzcGFucy5sZW5ndGggPiBNQVhfU1BBTl9DT1VOVFxuICAgICAgICA/IHNwYW5zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRfdGltZXN0YW1wIC0gYi5zdGFydF90aW1lc3RhbXApLnNsaWNlKDAsIE1BWF9TUEFOX0NPVU5UKVxuICAgICAgICA6IHNwYW5zO1xuXG4gICAgY29uc3QgbWVhc3VyZW1lbnRzID0gY29yZS50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzKHNwYW4uZXZlbnRzKTtcbiAgICBpZiAobWVhc3VyZW1lbnRzKSB7XG4gICAgICB0cmFuc2FjdGlvbkV2ZW50Lm1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cztcbiAgICB9XG5cbiAgICBjb3JlLmNhcHR1cmVFdmVudCh0cmFuc2FjdGlvbkV2ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVtYWluaW5nKVxuICAgIC5tYXAobm9kZSA9PiBub2RlLnNwYW4pXG4gICAgLmZpbHRlcigoc3BhbikgPT4gISFzcGFuKTtcbn1cblxuZnVuY3Rpb24gbm9kZUlzQ29tcGxldGVkUm9vdE5vZGUobm9kZSkge1xuICByZXR1cm4gISFub2RlLnNwYW4gJiYgIW5vZGUucGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcGxldGVkUm9vdE5vZGVzKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5maWx0ZXIobm9kZUlzQ29tcGxldGVkUm9vdE5vZGUpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDbGVhbnVwU3BhbihzcGFuLCBtYXhTdGFydFRpbWVPZmZzZXRTZWNvbmRzKSB7XG4gIGNvbnN0IGN1dG9mZiA9IERhdGUubm93KCkgLyAxMDAwIC0gbWF4U3RhcnRUaW1lT2Zmc2V0U2Vjb25kcztcbiAgcmV0dXJuIGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzcGFuLnN0YXJ0VGltZSkgPCBjdXRvZmY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3BhbihzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuLmF0dHJpYnV0ZXM7XG5cbiAgY29uc3Qgb3JpZ2luID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXSA7XG4gIGNvbnN0IG9wID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdIDtcbiAgY29uc3Qgc291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA7XG5cbiAgcmV0dXJuIHsgb3JpZ2luLCBvcCwgc291cmNlIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uRm9yT3RlbFNwYW4oc3Bhbikge1xuICBjb25zdCB7IG9wLCBkZXNjcmlwdGlvbiwgZGF0YSwgb3JpZ2luID0gJ21hbnVhbCcsIHNvdXJjZSB9ID0gZ2V0U3BhbkRhdGEoc3Bhbik7XG4gIGNvbnN0IGNhcHR1cmVkU3BhblNjb3BlcyA9IGNvcmUuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3BhbiApO1xuXG4gIGNvbnN0IHNhbXBsZVJhdGUgPSBzcGFuLmF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXSA7XG5cbiAgY29uc3QgYXR0cmlidXRlcyA9IHV0aWxzLmRyb3BVbmRlZmluZWRLZXlzKHtcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06IHNvdXJjZSxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTogc2FtcGxlUmF0ZSxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogb3AsXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBvcmlnaW4sXG4gICAgLi4uZGF0YSxcbiAgICAuLi5yZW1vdmVTZW50cnlBdHRyaWJ1dGVzKHNwYW4uYXR0cmlidXRlcyksXG4gIH0pO1xuXG4gIGNvbnN0IHsgdHJhY2VJZDogdHJhY2VfaWQsIHNwYW5JZDogc3Bhbl9pZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuXG4gIGNvbnN0IHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlID0gX29wdGlvbmFsQ2hhaW4kMihbc3BhbiwgJ2FjY2VzcycsIF8yID0+IF8yLnNwYW5Db250ZXh0LCAnY2FsbCcsIF8zID0+IF8zKCksICdhY2Nlc3MnLCBfNCA9PiBfNC50cmFjZVN0YXRlLCAnb3B0aW9uYWxBY2Nlc3MnLCBfNSA9PiBfNS5nZXQsICdjYWxsJywgXzYgPT4gXzYoU0VOVFJZX1RSQUNFX1NUQVRFX1BBUkVOVF9TUEFOX0lEKV0pO1xuXG4gIC8vIElmIHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlIGlzIGRlZmluZWQgYXQgYWxsLCB3ZSB3YW50IGl0IHRvIHRha2UgcHJlc2VkZW5jZVxuICAvLyBJbiB0aGF0IGNhc2UsIGFuIGVtcHR5IHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgXCJubyBwYXJlbnQgc3BhbiBpZFwiLFxuICAvLyBldmVuIGlmIGBzcGFuLnBhcmVudFNwYW5JZGAgaXMgc2V0XG4gIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB3ZSBhcmUgc3RhcnRpbmcgYSBuZXcgdHJhY2UsIHdoZXJlIHdlIGhhdmUgYSB2aXJ0dWFsIHNwYW4gYmFzZWQgb24gdGhlIHByb3BhZ2F0aW9uQ29udGV4dFxuICAvLyBXZSBvbmx5IHdhbnQgdG8gY29udGludWUgdGhlIHRyYWNlSWQgaW4gdGhpcyBjYXNlLCBidXQgaWdub3JlIHRoZSBwYXJlbnQgc3BhblxuICBjb25zdCBwYXJlbnRfc3Bhbl9pZCA9XG4gICAgdHlwZW9mIHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlID09PSAnc3RyaW5nJyA/IHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlIHx8IHVuZGVmaW5lZCA6IHNwYW4ucGFyZW50U3BhbklkO1xuXG4gIGNvbnN0IHN0YXR1cyA9IG1hcFN0YXR1cyhzcGFuKTtcblxuICBjb25zdCB0cmFjZUNvbnRleHQgPSB1dGlscy5kcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgcGFyZW50X3NwYW5faWQsXG4gICAgc3Bhbl9pZCxcbiAgICB0cmFjZV9pZCxcbiAgICBkYXRhOiBhdHRyaWJ1dGVzLFxuICAgIG9yaWdpbixcbiAgICBvcCxcbiAgICBzdGF0dXM6IGNvcmUuZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLCAvLyBBcyBwZXIgcHJvdG9jb2wsIHNwYW4gc3RhdHVzIGlzIGFsbG93ZWQgdG8gYmUgdW5kZWZpbmVkXG4gIH0pO1xuXG4gIGNvbnN0IHRyYW5zYWN0aW9uRXZlbnQgPSB7XG4gICAgY29udGV4dHM6IHtcbiAgICAgIHRyYWNlOiB0cmFjZUNvbnRleHQsXG4gICAgICBvdGVsOiB7XG4gICAgICAgIHJlc291cmNlOiBzcGFuLnJlc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICB9LFxuICAgIH0sXG4gICAgc3BhbnM6IFtdLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHNwYW4uc3RhcnRUaW1lKSxcbiAgICB0aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzcGFuLmVuZFRpbWUpLFxuICAgIHRyYW5zYWN0aW9uOiBkZXNjcmlwdGlvbixcbiAgICB0eXBlOiAndHJhbnNhY3Rpb24nLFxuICAgIHNka1Byb2Nlc3NpbmdNZXRhZGF0YToge1xuICAgICAgLi4udXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgICAgICBjYXB0dXJlZFNwYW5TY29wZTogY2FwdHVyZWRTcGFuU2NvcGVzLnNjb3BlLFxuICAgICAgICBjYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZTogY2FwdHVyZWRTcGFuU2NvcGVzLmlzb2xhdGlvblNjb3BlLFxuICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuICksXG4gICAgICB9KSxcbiAgICB9LFxuICAgIC4uLihzb3VyY2UgJiYge1xuICAgICAgdHJhbnNhY3Rpb25faW5mbzoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICB9LFxuICAgIH0pLFxuICAgIF9tZXRyaWNzX3N1bW1hcnk6IGNvcmUuZ2V0TWV0cmljU3VtbWFyeUpzb25Gb3JTcGFuKHNwYW4gKSxcbiAgfTtcblxuICByZXR1cm4gdHJhbnNhY3Rpb25FdmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKG5vZGUsIHNwYW5zLCByZW1haW5pbmcpIHtcbiAgcmVtYWluaW5nLmRlbGV0ZShub2RlKTtcbiAgY29uc3Qgc3BhbiA9IG5vZGUuc3BhbjtcblxuICBjb25zdCBzaG91bGREcm9wID0gIXNwYW47XG5cbiAgLy8gSWYgdGhpcyBzcGFuIHNob3VsZCBiZSBkcm9wcGVkLCB3ZSBzdGlsbCB3YW50IHRvIGNyZWF0ZSBzcGFucyBmb3IgdGhlIGNoaWxkcmVuIG9mIHRoaXNcbiAgaWYgKHNob3VsZERyb3ApIHtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgcmVtYWluaW5nKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzcGFuX2lkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgY29uc3QgdHJhY2VfaWQgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZDtcblxuICBjb25zdCB7IGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSwgZW5kVGltZSwgcGFyZW50U3BhbklkIH0gPSBzcGFuO1xuXG4gIGNvbnN0IHsgb3AsIGRlc2NyaXB0aW9uLCBkYXRhLCBvcmlnaW4gPSAnbWFudWFsJyB9ID0gZ2V0U3BhbkRhdGEoc3Bhbik7XG4gIGNvbnN0IGFsbERhdGEgPSB1dGlscy5kcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBvcmlnaW4sXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IG9wLFxuICAgIC4uLnJlbW92ZVNlbnRyeUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgLi4uZGF0YSxcbiAgfSk7XG5cbiAgY29uc3Qgc3RhdHVzID0gbWFwU3RhdHVzKHNwYW4pO1xuXG4gIGNvbnN0IHNwYW5KU09OID0gdXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgZGF0YTogYWxsRGF0YSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBwYXJlbnRfc3Bhbl9pZDogcGFyZW50U3BhbklkLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHN0YXJ0VGltZSksXG4gICAgLy8gVGhpcyBpcyBbMCwwXSBieSBkZWZhdWx0IGluIE9URUwsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbnRlcnByZXQgdGhpcyBhcyBubyBlbmQgdGltZVxuICAgIHRpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKGVuZFRpbWUpIHx8IHVuZGVmaW5lZCxcbiAgICBzdGF0dXM6IGNvcmUuZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLCAvLyBBcyBwZXIgcHJvdG9jb2wsIHNwYW4gc3RhdHVzIGlzIGFsbG93ZWQgdG8gYmUgdW5kZWZpbmVkXG4gICAgb3AsXG4gICAgb3JpZ2luLFxuICAgIF9tZXRyaWNzX3N1bW1hcnk6IGNvcmUuZ2V0TWV0cmljU3VtbWFyeUpzb25Gb3JTcGFuKHNwYW4gKSxcbiAgICBtZWFzdXJlbWVudHM6IGNvcmUudGltZWRFdmVudHNUb01lYXN1cmVtZW50cyhzcGFuLmV2ZW50cyksXG4gIH0pO1xuXG4gIHNwYW5zLnB1c2goc3BhbkpTT04pO1xuXG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgcmVtYWluaW5nKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5EYXRhKHNwYW4pXG5cbiB7XG4gIGNvbnN0IHsgb3A6IGRlZmluZWRPcCwgc291cmNlOiBkZWZpbmVkU291cmNlLCBvcmlnaW4gfSA9IHBhcnNlU3BhbihzcGFuKTtcbiAgY29uc3QgeyBvcDogaW5mZXJyZWRPcCwgZGVzY3JpcHRpb24sIHNvdXJjZTogaW5mZXJyZWRTb3VyY2UsIGRhdGE6IGluZmVycmVkRGF0YSB9ID0gcGFyc2VTcGFuRGVzY3JpcHRpb24oc3Bhbik7XG5cbiAgY29uc3Qgb3AgPSBkZWZpbmVkT3AgfHwgaW5mZXJyZWRPcDtcbiAgY29uc3Qgc291cmNlID0gZGVmaW5lZFNvdXJjZSB8fCBpbmZlcnJlZFNvdXJjZTtcblxuICBjb25zdCBkYXRhID0geyAuLi5pbmZlcnJlZERhdGEsIC4uLmdldERhdGEoc3BhbikgfTtcblxuICByZXR1cm4ge1xuICAgIG9wLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHNvdXJjZSxcbiAgICBvcmlnaW4sXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgY3VzdG9tIGBzZW50cnkuYCBhdHRyaWJ0dWVzIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQuXG4gKiBUaGVzZSBhcmUgbW9yZSBjYXJyaWVyIGF0dHJpYnV0ZXMgd2UgdXNlIGluc2lkZSBvZiB0aGUgU0RLLCB3ZSBkbyBub3QgbmVlZCB0byBzZW5kIHRoZW0gdG8gdGhlIEFQSS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2VudHJ5QXR0cmlidXRlcyhkYXRhKSB7XG4gIGNvbnN0IGNsZWFuZWREYXRhID0geyAuLi5kYXRhIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlICovXG4gIGRlbGV0ZSBjbGVhbmVkRGF0YVtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdO1xuICBkZWxldGUgY2xlYW5lZERhdGFbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFXTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGUgKi9cblxuICByZXR1cm4gY2xlYW5lZERhdGE7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbi5hdHRyaWJ1dGVzO1xuICBjb25zdCBkYXRhID0ge1xuICAgICdvdGVsLmtpbmQnOiBhcGkuU3BhbktpbmRbc3Bhbi5raW5kXSxcbiAgfTtcblxuICBpZiAoYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdKSB7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXSA7XG4gICAgZGF0YVsnaHR0cC5yZXNwb25zZS5zdGF0dXNfY29kZSddID0gc3RhdHVzQ29kZTtcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3REYXRhID0gZ2V0UmVxdWVzdFNwYW5EYXRhKHNwYW4pO1xuXG4gIGlmIChyZXF1ZXN0RGF0YS51cmwpIHtcbiAgICBkYXRhLnVybCA9IHJlcXVlc3REYXRhLnVybDtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0RGF0YVsnaHR0cC5xdWVyeSddKSB7XG4gICAgZGF0YVsnaHR0cC5xdWVyeSddID0gcmVxdWVzdERhdGFbJ2h0dHAucXVlcnknXS5zbGljZSgxKTtcbiAgfVxuICBpZiAocmVxdWVzdERhdGFbJ2h0dHAuZnJhZ21lbnQnXSkge1xuICAgIGRhdGFbJ2h0dHAuZnJhZ21lbnQnXSA9IHJlcXVlc3REYXRhWydodHRwLmZyYWdtZW50J10uc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kMShvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBvblNwYW5TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KSB7XG4gIC8vIFRoaXMgaXMgYSByZWxpYWJsZSB3YXkgdG8gZ2V0IHRoZSBwYXJlbnQgc3BhbiAtIGJlY2F1c2UgdGhpcyBpcyBleGFjdGx5IGhvdyB0aGUgcGFyZW50IGlzIGlkZW50aWZpZWQgaW4gdGhlIE9URUwgU0RLXG4gIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3BhbihwYXJlbnRDb250ZXh0KTtcblxuICBsZXQgc2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQocGFyZW50Q29udGV4dCk7XG5cbiAgLy8gV2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBzcGFuIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gbW92ZSB1cCB0aGUgc3BhbiB0cmVlIGZvciBicmVhZGNydW1ic1xuICBpZiAocGFyZW50U3BhbiAmJiAhcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgY29yZS5hZGRDaGlsZFNwYW5Ub1NwYW4ocGFyZW50U3Bhbiwgc3Bhbik7XG4gIH1cblxuICAvLyBXZSBuZWVkIHRoaXMgaW4gdGhlIHNwYW4gZXhwb3J0ZXJcbiAgaWYgKHBhcmVudFNwYW4gJiYgcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFLCB0cnVlKTtcbiAgfVxuXG4gIC8vIFRoZSByb290IGNvbnRleHQgZG9lcyBub3QgaGF2ZSBzY29wZXMgc3RvcmVkLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBzcGVjaWZpY2FsbHlcbiAgLy8gQXMgZmFsbGJhY2sgd2UgYXR0YWNoIHRoZSBnbG9iYWwgc2NvcGVzXG4gIGlmIChwYXJlbnRDb250ZXh0ID09PSBhcGkuUk9PVF9DT05URVhUKSB7XG4gICAgc2NvcGVzID0ge1xuICAgICAgc2NvcGU6IGNvcmUuZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpLFxuICAgICAgaXNvbGF0aW9uU2NvcGU6IGNvcmUuZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdGhlIHNjb3BlIGF0IHRpbWUgb2Ygc3BhbiBjcmVhdGlvbiBpbiBvcmRlciB0byBhcHBseSBpdCB0byB0aGUgZXZlbnQgd2hlbiB0aGUgc3BhbiBpcyBmaW5pc2hlZFxuICBpZiAoc2NvcGVzKSB7XG4gICAgY29yZS5zZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuLCBzY29wZXMuc2NvcGUsIHNjb3Blcy5pc29sYXRpb25TY29wZSk7XG4gIH1cblxuICBjb3JlLmxvZ1NwYW5TdGFydChzcGFuKTtcblxuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICBfb3B0aW9uYWxDaGFpbiQxKFtjbGllbnQsICdvcHRpb25hbEFjY2VzcycsIF8gPT4gXy5lbWl0LCAnY2FsbCcsIF8yID0+IF8yKCdzcGFuU3RhcnQnLCBzcGFuKV0pO1xufVxuXG5mdW5jdGlvbiBvblNwYW5FbmQoc3Bhbikge1xuICBjb3JlLmxvZ1NwYW5FbmQoc3Bhbik7XG5cbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgX29wdGlvbmFsQ2hhaW4kMShbY2xpZW50LCAnb3B0aW9uYWxBY2Nlc3MnLCBfMyA9PiBfMy5lbWl0LCAnY2FsbCcsIF80ID0+IF80KCdzcGFuRW5kJywgc3BhbildKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBPcGVuVGVsZW1ldHJ5IFNwYW5zIHRvIFNlbnRyeSBTcGFucyBhbmQgc2VuZHMgdGhlbSB0byBTZW50cnkgdmlhXG4gKiB0aGUgU2VudHJ5IFNESy5cbiAqL1xuY2xhc3MgU2VudHJ5U3BhblByb2Nlc3NvciAge1xuXG4gICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc2V0SXNTZXR1cCgnU2VudHJ5U3BhblByb2Nlc3NvcicpO1xuICAgIHRoaXMuX2V4cG9ydGVyID0gbmV3IFNlbnRyeVNwYW5FeHBvcnRlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFzeW5jIGZvcmNlRmx1c2goKSB7XG4gICAgdGhpcy5fZXhwb3J0ZXIuZmx1c2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFzeW5jIHNodXRkb3duKCkge1xuICAgIHRoaXMuX2V4cG9ydGVyLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBvblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpIHtcbiAgICBvblNwYW5TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgb25FbmQoc3Bhbikge1xuICAgIG9uU3BhbkVuZChzcGFuKTtcblxuICAgIHRoaXMuX2V4cG9ydGVyLmV4cG9ydChzcGFuKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY3VzdG9tIE9URUwgc2FtcGxlciB0aGF0IHVzZXMgU2VudHJ5IHNhbXBsaW5nIHJhdGVzIHRvIG1ha2UgaXRzIGRlY2lzaW9uXG4gKi9cbmNsYXNzIFNlbnRyeVNhbXBsZXIgIHtcblxuICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVNhbXBsZXInKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgc2hvdWxkU2FtcGxlKFxuICAgIGNvbnRleHQsXG4gICAgdHJhY2VJZCxcbiAgICBzcGFuTmFtZSxcbiAgICBzcGFuS2luZCxcbiAgICBzcGFuQXR0cmlidXRlcyxcbiAgICBfbGlua3MsXG4gICkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9jbGllbnQuZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudENvbnRleHQgPSBfb3B0aW9uYWxDaGFpbihbcGFyZW50U3BhbiwgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnNwYW5Db250ZXh0LCAnY2FsbCcsIF8yID0+IF8yKCldKTtcblxuICAgIGlmICghY29yZS5oYXNUcmFjaW5nRW5hYmxlZChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGh0dHAuY2xpZW50IHNwYW4gdGhhdCBoYXMgbm8gbG9jYWwgcGFyZW50LCB3ZSBuZXZlciB3YW50IHRvIHNhbXBsZSBpdFxuICAgIC8vIGJ1dCB3ZSB3YW50IHRvIGxlYXZlIGRvd25zdHJlYW0gc2FtcGxpbmcgZGVjaXNpb25zIHVwIHRvIHRoZSBzZXJ2ZXJcbiAgICBpZiAoXG4gICAgICBzcGFuS2luZCA9PT0gYXBpLlNwYW5LaW5kLkNMSUVOVCAmJlxuICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF0gJiZcbiAgICAgICghcGFyZW50U3BhbiB8fCBfb3B0aW9uYWxDaGFpbihbcGFyZW50Q29udGV4dCwgJ29wdGlvbmFsQWNjZXNzJywgXzMgPT4gXzMuaXNSZW1vdGVdKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBwYXJlbnRTcGFuID8gZ2V0UGFyZW50U2FtcGxlZChwYXJlbnRTcGFuLCB0cmFjZUlkLCBzcGFuTmFtZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbiA9IHsgZGVjaXNpb246IHRydWUgfTtcbiAgICB0aGlzLl9jbGllbnQuZW1pdChcbiAgICAgICdiZWZvcmVTYW1wbGluZycsXG4gICAgICB7XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzOiBzcGFuQXR0cmlidXRlcyxcbiAgICAgICAgc3Bhbk5hbWU6IHNwYW5OYW1lLFxuICAgICAgICBwYXJlbnRTYW1wbGVkOiBwYXJlbnRTYW1wbGVkLFxuICAgICAgICBwYXJlbnRDb250ZXh0OiBwYXJlbnRDb250ZXh0LFxuICAgICAgfSxcbiAgICAgIG11dGFibGVTYW1wbGluZ0RlY2lzaW9uLFxuICAgICk7XG4gICAgaWYgKCFtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbi5kZWNpc2lvbikge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgW3NhbXBsZWQsIHNhbXBsZVJhdGVdID0gY29yZS5zYW1wbGVTcGFuKG9wdGlvbnMsIHtcbiAgICAgIG5hbWU6IHNwYW5OYW1lLFxuICAgICAgYXR0cmlidXRlczogc3BhbkF0dHJpYnV0ZXMsXG4gICAgICB0cmFuc2FjdGlvbkNvbnRleHQ6IHtcbiAgICAgICAgbmFtZTogc3Bhbk5hbWUsXG4gICAgICAgIHBhcmVudFNhbXBsZWQsXG4gICAgICB9LFxuICAgICAgcGFyZW50U2FtcGxlZCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTogc2FtcGxlUmF0ZSxcbiAgICB9O1xuXG4gICAgY29uc3QgbWV0aG9kID0gYCR7c3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF19YC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChtZXRob2QgPT09ICdPUFRJT05TJyB8fCBtZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgREVCVUdfQlVJTEQgJiYgdXRpbHMubG9nZ2VyLmxvZyhgW1RyYWNpbmddIE5vdCBzYW1wbGluZyBzcGFuIGJlY2F1c2UgSFRUUCBtZXRob2QgaXMgJyR7bWV0aG9kfScgZm9yICR7c3Bhbk5hbWV9YCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLndyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pLFxuICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXNhbXBsZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLndyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pLFxuICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLndyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSksXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgIH07XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgc2FtcGxlciBuYW1lIG9yIHNob3J0IGRlc2NyaXB0aW9uIHdpdGggdGhlIGNvbmZpZ3VyYXRpb24uICovXG4gICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NlbnRyeVNhbXBsZXInO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFJlbW90ZVNhbXBsZWQocGFyZW50U3Bhbikge1xuICBjb25zdCB0cmFjZUlkID0gcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQ7XG4gIGNvbnN0IHRyYWNlcGFyZW50RGF0YSA9IGdldFByb3BhZ2F0aW9uQ29udGV4dEZyb21TcGFuKHBhcmVudFNwYW4pO1xuXG4gIC8vIE9ubHkgaW5oZXJpdCBzYW1wbGVkIGlmIGB0cmFjZUlkYCBpcyB0aGUgc2FtZVxuICByZXR1cm4gdHJhY2VwYXJlbnREYXRhICYmIHRyYWNlSWQgPT09IHRyYWNlcGFyZW50RGF0YS50cmFjZUlkID8gdHJhY2VwYXJlbnREYXRhLnNhbXBsZWQgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFNhbXBsZWQocGFyZW50U3BhbiwgdHJhY2VJZCwgc3Bhbk5hbWUpIHtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9IHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAvLyBPbmx5IGluaGVyaXQgc2FtcGxlIHJhdGUgaWYgYHRyYWNlSWRgIGlzIHRoZSBzYW1lXG4gIC8vIE5vdGUgZm9yIHRlc3Rpbmc6IGBpc1NwYW5Db250ZXh0VmFsaWQoKWAgY2hlY2tzIHRoZSBmb3JtYXQgb2YgdGhlIHRyYWNlSWQvc3BhbklkLCBzbyB3ZSBuZWVkIHRvIHBhc3MgdmFsaWQgb25lc1xuICBpZiAoYXBpLmlzU3BhbkNvbnRleHRWYWxpZChwYXJlbnRDb250ZXh0KSAmJiBwYXJlbnRDb250ZXh0LnRyYWNlSWQgPT09IHRyYWNlSWQpIHtcbiAgICBpZiAocGFyZW50Q29udGV4dC5pc1JlbW90ZSkge1xuICAgICAgY29uc3QgcGFyZW50U2FtcGxlZCA9IGdldFBhcmVudFJlbW90ZVNhbXBsZWQocGFyZW50U3Bhbik7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICB1dGlscy5sb2dnZXIubG9nKGBbVHJhY2luZ10gSW5oZXJpdGluZyByZW1vdGUgcGFyZW50J3Mgc2FtcGxlZCBkZWNpc2lvbiBmb3IgJHtzcGFuTmFtZX06ICR7cGFyZW50U2FtcGxlZH1gKTtcbiAgICAgIHJldHVybiBwYXJlbnRTYW1wbGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHBhcmVudENvbnRleHQpO1xuICAgIERFQlVHX0JVSUxEICYmIHV0aWxzLmxvZ2dlci5sb2coYFtUcmFjaW5nXSBJbmhlcml0aW5nIHBhcmVudCdzIHNhbXBsZWQgZGVjaXNpb24gZm9yICR7c3Bhbk5hbWV9OiAke3BhcmVudFNhbXBsZWR9YCk7XG4gICAgcmV0dXJuIHBhcmVudFNhbXBsZWQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdyYXAgYSBzYW1wbGluZyBkZWNpc2lvbiB3aXRoIGRhdGEgdGhhdCBTZW50cnkgbmVlZHMgdG8gd29yayBwcm9wZXJseSB3aXRoIGl0LlxuICogSWYgeW91IHBhc3MgYGRlY2lzaW9uOiB1bmRlZmluZWRgLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYE5PVF9SRUNPUkRJTkdgLCBidXQgaW4gY29udHJhc3QgdG8gcGFzc2luZyBgTk9UX1JFQ09SRElOR2BcbiAqIGl0IHdpbGwgbm90IHByb3BhZ2F0ZSB0aGlzIGRlY2lzaW9uIHRvIGRvd25zdHJlYW0gU2VudHJ5IFNES3MuXG4gKi9cbmZ1bmN0aW9uIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHtcbiAgZGVjaXNpb24sXG4gIGNvbnRleHQsXG4gIHNwYW5BdHRyaWJ1dGVzLFxufSkge1xuICBjb25zdCB0cmFjZVN0YXRlID0gZ2V0QmFzZVRyYWNlU3RhdGUoY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMpO1xuXG4gIC8vIElmIHRoZSBkZWNpc2lvbiBpcyB1bmRlZmluZWQsIHdlIHRyZWF0IGl0IGFzIE5PVF9SRUNPUkRJTkcsIGJ1dCB3ZSBkb24ndCBwcm9wYWdhdGUgdGhpcyBkZWNpc2lvbiB0byBkb3duc3RyZWFtIFNES3NcbiAgLy8gV2hpY2ggaXMgZG9uZSBieSBub3Qgc2V0dGluZyBgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElOR2AgdHJhY2VTdGF0ZVxuICBpZiAoZGVjaXNpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsIHRyYWNlU3RhdGUgfTtcbiAgfVxuXG4gIGlmIChkZWNpc2lvbiA9PT0gc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCkge1xuICAgIHJldHVybiB7IGRlY2lzaW9uLCB0cmFjZVN0YXRlOiB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HLCAnMScpIH07XG4gIH1cblxuICByZXR1cm4geyBkZWNpc2lvbiwgdHJhY2VTdGF0ZSB9O1xufVxuXG5mdW5jdGlvbiBnZXRCYXNlVHJhY2VTdGF0ZShjb250ZXh0LCBzcGFuQXR0cmlidXRlcykge1xuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBfb3B0aW9uYWxDaGFpbihbcGFyZW50U3BhbiwgJ29wdGlvbmFsQWNjZXNzJywgXzQgPT4gXzQuc3BhbkNvbnRleHQsICdjYWxsJywgXzUgPT4gXzUoKV0pO1xuXG4gIGxldCB0cmFjZVN0YXRlID0gX29wdGlvbmFsQ2hhaW4oW3BhcmVudENvbnRleHQsICdvcHRpb25hbEFjY2VzcycsIF82ID0+IF82LnRyYWNlU3RhdGVdKSB8fCBuZXcgY29yZSQxLlRyYWNlU3RhdGUoKTtcblxuICAvLyBXZSBhbHdheXMga2VlcCB0aGUgVVJMIG9uIHRoZSB0cmFjZSBzdGF0ZSwgc28gd2UgY2FuIGFjY2VzcyBpdCBpbiB0aGUgcHJvcGFnYXRvclxuICBjb25zdCB1cmwgPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXTtcbiAgaWYgKHVybCAmJiB0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIHRyYWNlU3RhdGUgPSB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfVVJMLCB1cmwpO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNlU3RhdGU7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgYW4gT3BlblRlbGVtZXRyeSBpbnN0cnVtZW50YXRpb24gb3JcbiAqIGFycmF5IG9mIGluc3RydW1lbnRhdGlvbnMgYW5kIHJlZ2lzdGVycyB0aGVtIHdpdGggT3BlblRlbGVtZXRyeS5cbiAqL1xuZnVuY3Rpb24gYWRkT3BlblRlbGVtZXRyeUluc3RydW1lbnRhdGlvbiguLi5pbnN0cnVtZW50YXRpb25zKSB7XG4gIGluc3RydW1lbnRhdGlvbi5yZWdpc3Rlckluc3RydW1lbnRhdGlvbnMoe1xuICAgIGluc3RydW1lbnRhdGlvbnMsXG4gIH0pO1xufVxuXG5leHBvcnRzLmdldENsaWVudCA9IGNvcmUuZ2V0Q2xpZW50O1xuZXhwb3J0cy5nZXRDdXJyZW50SHViU2hpbSA9IGNvcmUuZ2V0Q3VycmVudEh1YlNoaW07XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuO1xuZXhwb3J0cy5TZW50cnlQcm9wYWdhdG9yID0gU2VudHJ5UHJvcGFnYXRvcjtcbmV4cG9ydHMuU2VudHJ5U2FtcGxlciA9IFNlbnRyeVNhbXBsZXI7XG5leHBvcnRzLlNlbnRyeVNwYW5Qcm9jZXNzb3IgPSBTZW50cnlTcGFuUHJvY2Vzc29yO1xuZXhwb3J0cy5hZGRPcGVuVGVsZW1ldHJ5SW5zdHJ1bWVudGF0aW9uID0gYWRkT3BlblRlbGVtZXRyeUluc3RydW1lbnRhdGlvbjtcbmV4cG9ydHMuY29udGludWVUcmFjZSA9IGNvbnRpbnVlVHJhY2U7XG5leHBvcnRzLmVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZSA9IGVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZTtcbmV4cG9ydHMuZ2V0QWN0aXZlU3BhbiA9IGdldEFjdGl2ZVNwYW47XG5leHBvcnRzLmdldFJlcXVlc3RTcGFuRGF0YSA9IGdldFJlcXVlc3RTcGFuRGF0YTtcbmV4cG9ydHMuZ2V0U2NvcGVzRnJvbUNvbnRleHQgPSBnZXRTY29wZXNGcm9tQ29udGV4dDtcbmV4cG9ydHMuZ2V0U3BhbktpbmQgPSBnZXRTcGFuS2luZDtcbmV4cG9ydHMuaXNTZW50cnlSZXF1ZXN0U3BhbiA9IGlzU2VudHJ5UmVxdWVzdFNwYW47XG5leHBvcnRzLm9wZW5UZWxlbWV0cnlTZXR1cENoZWNrID0gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2s7XG5leHBvcnRzLnNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3kgPSBzZXRPcGVuVGVsZW1ldHJ5Q29udGV4dEFzeW5jQ29udGV4dFN0cmF0ZWd5O1xuZXhwb3J0cy5zZXR1cEV2ZW50Q29udGV4dFRyYWNlID0gc2V0dXBFdmVudENvbnRleHRUcmFjZTtcbmV4cG9ydHMuc3Bhbkhhc0F0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcztcbmV4cG9ydHMuc3Bhbkhhc0V2ZW50cyA9IHNwYW5IYXNFdmVudHM7XG5leHBvcnRzLnNwYW5IYXNLaW5kID0gc3Bhbkhhc0tpbmQ7XG5leHBvcnRzLnNwYW5IYXNOYW1lID0gc3Bhbkhhc05hbWU7XG5leHBvcnRzLnNwYW5IYXNQYXJlbnRJZCA9IHNwYW5IYXNQYXJlbnRJZDtcbmV4cG9ydHMuc3Bhbkhhc1N0YXR1cyA9IHNwYW5IYXNTdGF0dXM7XG5leHBvcnRzLnN0YXJ0SW5hY3RpdmVTcGFuID0gc3RhcnRJbmFjdGl2ZVNwYW47XG5leHBvcnRzLnN0YXJ0U3BhbiA9IHN0YXJ0U3BhbjtcbmV4cG9ydHMuc3RhcnRTcGFuTWFudWFsID0gc3RhcnRTcGFuTWFudWFsO1xuZXhwb3J0cy5zdXBwcmVzc1RyYWNpbmcgPSBzdXBwcmVzc1RyYWNpbmc7XG5leHBvcnRzLndpdGhBY3RpdmVTcGFuID0gd2l0aEFjdGl2ZVNwYW47XG5leHBvcnRzLndyYXBDbGllbnRDbGFzcyA9IHdyYXBDbGllbnRDbGFzcztcbmV4cG9ydHMud3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MgPSB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcztcbmV4cG9ydHMud3JhcFNhbXBsaW5nRGVjaXNpb24gPSB3cmFwU2FtcGxpbmdEZWNpc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var {\n  _optionalChain\n} = __webpack_require__(/*! @sentry/utils */ \"(instrument)/./node_modules/.pnpm/@sentry+utils@8.17.0/node_modules/@sentry/utils/build/cjs/index.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst semanticConventions = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.25.1/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst utils = __webpack_require__(/*! @sentry/utils */ \"(instrument)/./node_modules/.pnpm/@sentry+utils@8.17.0/node_modules/@sentry/utils/build/cjs/index.js\");\nconst api = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core = __webpack_require__(/*! @sentry/core */ \"(instrument)/./node_modules/.pnpm/@sentry+core@8.17.0/node_modules/@sentry/core/build/cjs/index.js\");\nconst core$1 = __webpack_require__(/*! @opentelemetry/core */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+core@1.25.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst sdkTraceBase = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.25.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nconst instrumentation = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(instrument)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.52.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nfunction spanHasAttributes(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasKind(span) {\n  const castSpan = span ;\n  return !!castSpan.kind;\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasStatus(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasName(span) {\n  const castSpan = span ;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasParentId(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.parentSpanId;\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasEvents(\n  span,\n) {\n  const castSpan = span ;\n  return Array.isArray(castSpan.events);\n}\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nfunction getRequestSpanData(span) {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  const data = {\n    url: span.attributes[semanticConventions.SEMATTRS_HTTP_URL] ,\n    'http.method': span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD] ,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    const urlStr = span.attributes[semanticConventions.SEMATTRS_HTTP_URL];\n    if (typeof urlStr === 'string') {\n      const url = utils.parseUrl(urlStr);\n\n      data.url = utils.getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  return data;\n}\n\nfunction _optionalChain$8(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client with things we need for OpenTelemetry support.\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nfunction wrapClientClass\n\n(ClientClass) {\n  class OpenTelemetryClient extends ClientClass  {\n\n     constructor(...args) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n     get tracer() {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = core.SDK_VERSION;\n      const tracer = api.trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n     async flush(timeout) {\n      const provider = this.traceProvider;\n      const spanProcessor = _optionalChain$8([provider, 'optionalAccess', _ => _.activeSpanProcessor]);\n\n      if (spanProcessor) {\n        await spanProcessor.forceFlush();\n      }\n\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nfunction getSpanKind(span) {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return api.SpanKind.INTERNAL;\n}\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\nconst SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nconst SENTRY_TRACE_STATE_PARENT_SPAN_ID = 'sentry.parent_span_id';\nconst SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nconst SENTRY_TRACE_STATE_URL = 'sentry.url';\n\nconst SENTRY_SCOPES_CONTEXT_KEY = api.createContextKey('sentry_scopes');\n\nconst SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_isolation_scope');\n\nconst SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_scope');\n\nconst SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_isolation_scope');\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nfunction getScopesFromContext(context) {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) ;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nfunction setScopesOnContext(context, scopes) {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nfunction setContextOnScope(scope, context) {\n  utils.addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n * TODO v8: Use this for the `trace` functions.\n * */\nfunction getContextFromScope(scope) {\n  return (scope )[SCOPE_CONTEXT_FIELD];\n}\n\n/**\n *\n * @param otelSpan Checks wheter a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nfunction isSentryRequestSpan(span) {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return core.isSentryRequestUrl(httpUrl.toString(), core.getClient());\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nfunction parseSpanDescription(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n\n  // This attribute is intentionally exported as a SEMATTR constant because it should stay intimite API\n  if (attributes['sentry.skip_span_data_inference']) {\n    return {\n      op: undefined,\n      description: name,\n      source: 'custom',\n      data: {\n        // Suggest to callers of `parseSpanDescription` to wipe the hint because it is unnecessary data in the end.\n        'sentry.skip_span_data_inference': undefined,\n      },\n    };\n  }\n\n  // if http.method exists, this is an http request span\n  //\n  // TODO: Referencing `http.request.method` is a temporary workaround until the semantic\n  // conventions export an attribute key for it.\n  const httpMethod = attributes['http.request.method'] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name, kind: getSpanKind(span) }, httpMethod);\n  }\n\n  const dbSystem = attributes[semanticConventions.SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name });\n  }\n\n  // If rpc.service exists then this is a rpc call span.\n  const rpcService = attributes[semanticConventions.SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      op: 'rpc',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  const messagingSystem = attributes[semanticConventions.SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      op: 'message',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  const faasTrigger = attributes[semanticConventions.SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return { op: faasTrigger.toString(), description: name, source: 'route' };\n  }\n\n  return { op: undefined, description: name, source: 'custom' };\n}\n\nfunction descriptionForDbSystem({ attributes, name }) {\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  const statement = attributes[semanticConventions.SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nfunction descriptionForHttpMethod(\n  { name, kind, attributes },\n  httpMethod,\n) {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case api.SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case api.SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { op: opParts.join('.'), description: name, source: 'custom' };\n  }\n\n  // Ex. description=\"GET /api/users\".\n  const description = `${httpMethod} ${urlPath}`;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const source = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\n/** Exported for tests only */\nfunction getSanitizedUrl(\n  attributes,\n  kind,\n)\n\n {\n  // This is the relative path of the URL, e.g. /sub\n  const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[semanticConventions.SEMATTRS_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? utils.parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? utils.getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl && parsedUrl.search ? parsedUrl.search : undefined;\n  const fragment = parsedUrl && parsedUrl.hash ? parsedUrl.hash : undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === api.SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: utils.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: utils.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nfunction enhanceDscWithOpenTelemetryRootSpanName(client) {\n  client.on('createDsc', (dsc, rootSpan) => {\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n    if (rootSpan) {\n      const jsonSpan = core.spanToJSON(rootSpan);\n      const attributes = jsonSpan.data || {};\n      const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n      const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n      if (source !== 'url' && description) {\n        dsc.transaction = description;\n      }\n    }\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  return api.trace.getActiveSpan();\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = ( false || false);\n\nfunction _optionalChain$7(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nfunction getSamplingDecision(spanContext) {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === api.TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? utils.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (_optionalChain$7([dsc, 'optionalAccess', _ => _.sampled]) === 'true') {\n    return true;\n  }\n  if (_optionalChain$7([dsc, 'optionalAccess', _2 => _2.sampled]) === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n\nconst setupElements = new Set();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nfunction openTelemetrySetupCheck() {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nfunction setIsSetup(element) {\n  setupElements.add(element);\n}\n\nfunction _optionalChain$6(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/** Get the Sentry propagation context from a span context. */\nfunction getPropagationContextFromSpan(span) {\n  const spanContext = span.spanContext();\n  const { traceId, spanId, traceState } = spanContext;\n\n  // When we have a dsc trace state, it means this came from the incoming trace\n  // Then this takes presedence over the root span\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const traceStateDsc = dscString ? utils.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  const parentSpanId = traceState ? traceState.get(SENTRY_TRACE_STATE_PARENT_SPAN_ID) || undefined : undefined;\n\n  const sampled = getSamplingDecision(spanContext);\n\n  // No trace state? --> Take DSC from root span\n  const dsc = traceStateDsc || core.getDynamicSamplingContextFromSpan(core.getRootSpan(span));\n\n  return {\n    traceId,\n    spanId,\n    sampled,\n    parentSpanId,\n    dsc,\n  };\n}\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nclass SentryPropagator extends core$1.W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n\n   constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new utils.LRUMap(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   inject(context, carrier, setter) {\n    if (core$1.isTracingSuppressed(context)) {\n      DEBUG_BUILD && utils.logger.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = api.trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = _optionalChain$6([core.getClient, 'call', _ => _(), 'optionalAccess', _2 => _2.getOptions, 'call', _3 => _3(), 'optionalAccess', _4 => _4.tracePropagationTargets]);\n    if (\n      typeof url === 'string' &&\n      tracePropagationTargets &&\n      !this._shouldInjectTraceData(tracePropagationTargets, url)\n    ) {\n      DEBUG_BUILD &&\n        utils.logger.log(\n          '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:',\n          url,\n        );\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = api.propagation.getBaggage(context) || api.propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = utils.parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${utils.SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== api.INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, utils.generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(api.propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   extract(context, carrier, getter) {\n    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    const propagationContext = utils.propagationContextFromHeaders(sentryTrace, baggage);\n\n    // Add remote parent span context\n    const ctxWithSpanContext = getContextWithRemoteActiveSpan(context, { sentryTrace, baggage });\n\n    // Also update the scope on the context (to be sure this is picked up everywhere)\n    const scopes = getScopesFromContext(ctxWithSpanContext);\n    const newScopes = {\n      scope: scopes ? scopes.scope.clone() : core.getCurrentScope().clone(),\n      isolationScope: scopes ? scopes.isolationScope : core.getIsolationScope(),\n    };\n    newScopes.scope.setPropagationContext(propagationContext);\n\n    return setScopesOnContext(ctxWithSpanContext, newScopes);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   fields() {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n\n  /** If we want to inject trace data for a given URL. */\n   _shouldInjectTraceData(tracePropagationTargets, url) {\n    if (tracePropagationTargets === undefined) {\n      return true;\n    }\n\n    const cachedDecision = this._urlMatchesTargetsMap.get(url);\n    if (cachedDecision !== undefined) {\n      return cachedDecision;\n    }\n\n    const decision = utils.stringMatchesSomePattern(url, tracePropagationTargets);\n    this._urlMatchesTargetsMap.set(url, decision);\n    return decision;\n  }\n}\n\n/** Exported for tests. */\nfunction makeTraceState({\n  parentSpanId,\n  dsc,\n  sampled,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? utils.dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  // We _always_ set the parent span ID, even if it is empty\n  // If we'd set this to 'undefined' we could not know if the trace state was set, but there was no parentSpanId,\n  // vs the trace state was not set at all (in which case we want to do fallback handling)\n  // If `''`, it should be considered \"no parent\"\n  const traceStateBase = new core$1.TraceState().set(SENTRY_TRACE_STATE_PARENT_SPAN_ID, parentSpanId || '');\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n\nfunction getInjectionData(context)\n\n {\n  const span = core.hasTracingEnabled() ? api.trace.getSpan(context) : undefined;\n  const spanIsRemote = _optionalChain$6([span, 'optionalAccess', _5 => _5.spanContext, 'call', _6 => _6(), 'access', _7 => _7.isRemote]);\n\n  // If we have a local span, we can just pick everything from it\n  if (span && !spanIsRemote) {\n    const spanContext = span.spanContext();\n\n    const propagationContext = getPropagationContextFromSpan(span);\n    const dynamicSamplingContext = getDynamicSamplingContext(propagationContext, spanContext.traceId);\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext),\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  const scope = _optionalChain$6([getScopesFromContext, 'call', _8 => _8(context), 'optionalAccess', _9 => _9.scope]) || core.getCurrentScope();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = getDynamicSamplingContext(propagationContext, propagationContext.traceId);\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.spanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\n/** Get the DSC from a context, or fall back to use the one from the client. */\nfunction getDynamicSamplingContext(\n  propagationContext,\n  traceId,\n) {\n  // If we have a DSC on the propagation context, we just use it\n  if (_optionalChain$6([propagationContext, 'optionalAccess', _10 => _10.dsc])) {\n    return propagationContext.dsc;\n  }\n\n  // Else, we try to generate a new one\n  const client = core.getClient();\n\n  if (client) {\n    return core.getDynamicSamplingContextFromClient(traceId || propagationContext.traceId, client);\n  }\n\n  return undefined;\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx,\n  { sentryTrace, baggage },\n) {\n  const propagationContext = utils.propagationContextFromHeaders(sentryTrace, baggage);\n\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    parentSpanId: propagationContext.parentSpanId,\n    dsc: propagationContext.dsc,\n    sampled: propagationContext.sampled,\n  });\n\n  const spanContext = {\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.parentSpanId || '',\n    isRemote: true,\n    traceFlags: propagationContext.sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  return api.trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nfunction continueTraceAsRemoteSpan(\n  ctx,\n  options,\n  callback,\n) {\n  const ctxWithSpanContext = getContextWithRemoteActiveSpan(ctx, options);\n\n  return api.context.with(ctxWithSpanContext, callback);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier) {\n  try {\n    const baggage = (carrier )[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span) {\n  const urlAttribute = _optionalChain$6([core.spanToJSON, 'call', _11 => _11(span), 'access', _12 => _12.data, 'optionalAccess', _13 => _13[semanticConventions.SEMATTRS_HTTP_URL]]);\n  if (urlAttribute) {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = _optionalChain$6([span, 'access', _14 => _14.spanContext, 'call', _15 => _15(), 'access', _16 => _16.traceState, 'optionalAccess', _17 => _17.get, 'call', _18 => _18(SENTRY_TRACE_STATE_URL)]);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction _optionalChain$5(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      _applySentryAttributesToSpan(span, options);\n\n      return core.handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(\n  options,\n  callback,\n) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      _applySentryAttributesToSpan(span, options);\n\n      return core.handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    _applySentryAttributesToSpan(span, options);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const newContextWithActiveSpan = span ? api.trace.setSpan(api.context.active(), span) : api.trace.deleteSpan(api.context.active());\n  return api.context.with(newContextWithActiveSpan, () => callback(core.getCurrentScope()));\n}\n\nfunction getTracer() {\n  const client = core.getClient();\n  return (client && client.tracer) || api.trace.getTracer('@sentry/opentelemetry', core.SDK_VERSION);\n}\n\nfunction _applySentryAttributesToSpan(span, options) {\n  const { op } = options;\n\n  if (op) {\n    span.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_OP, op);\n  }\n}\n\nfunction getSpanOptions(options) {\n  const { startTime, attributes, kind } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes,\n    kind,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp) {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope, forceTransaction) {\n  const ctx = getContextForScope(scope);\n  const actualScope = _optionalChain$5([getScopesFromContext, 'call', _ => _(ctx), 'optionalAccess', _2 => _2.scope]);\n\n  const parentSpan = api.trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we need to \"simulate\" one to ensure the propagation context is correct\n  if (!parentSpan) {\n    const client = core.getClient();\n\n    if (actualScope && client) {\n      const propagationContext = actualScope.getPropagationContext();\n\n      // We store the DSC as OTEL trace state on the span context\n      const traceState = makeTraceState({\n        parentSpanId: propagationContext.parentSpanId,\n        // Not defined yet, we want to pick this up on-demand only\n        dsc: undefined,\n        sampled: propagationContext.sampled,\n      });\n\n      const spanOptions = {\n        traceId: propagationContext.traceId,\n        spanId: propagationContext.parentSpanId || propagationContext.spanId,\n        isRemote: true,\n        traceFlags: propagationContext.sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n        traceState,\n      };\n\n      // Add remote parent span context,\n      return api.trace.setSpanContext(ctx, spanOptions);\n    }\n\n    // if we have no scope or client, we just return the context as-is\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = api.trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = core.getRootSpan(parentSpan);\n  const dsc = core.getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    parentSpanId: spanId !== api.INVALID_SPANID ? spanId : undefined,\n    sampled,\n  });\n\n  const spanOptions = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = api.trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope) {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return api.context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nfunction continueTrace(options, callback) {\n  return core.continueTrace(options, () => {\n    return continueTraceAsRemoteSpan(api.context.active(), options, callback);\n  });\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan\n    ? (callback) => {\n        // We cast this, because the OTEL Span has a few more methods than our Span interface\n        // TODO: Add these missing methods to the Span interface\n        return withActiveSpan(parentSpan , callback);\n      }\n    : (callback) => callback();\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const ctx = core$1.suppressTracing(api.context.active());\n  return api.context.with(ctx, callback);\n}\n\nfunction _optionalChain$4(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n/** Ensure the `trace` context is set on all events. */\nfunction setupEventContextTrace(client) {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    const spanContext = span.spanContext();\n\n    // If we have a parent span id from trace state, use that ('' means no parent should be used)\n    // Else, pick the one from the span\n    const parentSpanIdFromTraceState = _optionalChain$4([spanContext, 'access', _ => _.traceState, 'optionalAccess', _2 => _2.get, 'call', _3 => _3(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);\n    const parent_span_id =\n      typeof parentSpanIdFromTraceState === 'string'\n        ? parentSpanIdFromTraceState || undefined\n        : spanHasParentId(span)\n          ? span.parentSpanId\n          : undefined;\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: utils.dropUndefinedKeys({\n        trace_id: spanContext.traceId,\n        span_id: spanContext.spanId,\n        parent_span_id,\n      }),\n      ...event.contexts,\n    };\n\n    const rootSpan = core.getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nfunction setOpenTelemetryContextAsyncContextStrategy() {\n  function getScopes() {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope(scope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope(isolationScope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope() {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope() {\n    return getScopes().isolationScope;\n  }\n\n  core.setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan ,\n    suppressTracing: suppressTracing,\n  });\n}\n\nfunction _optionalChain$3(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nfunction wrapContextManagerClass(\n  ContextManagerClass,\n) {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n     constructor(...args) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n     with(\n      context,\n      fn,\n      thisArg,\n      ...args\n    ) {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = _optionalChain$3([currentScopes, 'optionalAccess', _ => _.scope]) || core.getCurrentScope();\n      const currentIsolationScope = _optionalChain$3([currentScopes, 'optionalAccess', _2 => _2.isolationScope]) || core.getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) ;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) ;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager ;\n}\n\n/** If this attribute is true, it means that the parent is a remote span. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nfunction groupSpansWithParents(spans) {\n  const nodeMap = new Map();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nfunction getLocalParentId(span) {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? span.parentSpanId : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap, span) {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap, id) {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap, spanNode) {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing && existing.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} ;\n\nconst isStatusErrorMessageValid = (message) => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message );\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nfunction mapStatus(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === api.SpanStatusCode.OK) {\n      return { code: core.SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === api.SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: core.SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status && status.code === api.SpanStatusCode.UNSET) {\n    return { code: core.SPAN_STATUS_OK };\n  } else {\n    return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes) {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  const httpCodeAttribute = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  const grpcCodeAttribute = attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return core.getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: core.SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n\nfunction _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nclass SentrySpanExporter {\n\n   constructor(options) {\n    this._finishedSpans = [];\n    this._timeout = _optionalChain$2([options, 'optionalAccess', _ => _.timeout]) || DEFAULT_TIMEOUT;\n  }\n\n  /** Export a single span. */\n   export(span) {\n    this._finishedSpans.push(span);\n\n    // If the span has a local parent ID, we don't need to export anything just yet\n    if (getLocalParentId(span)) {\n      const openSpanCount = this._finishedSpans.length;\n      DEBUG_BUILD && utils.logger.log(`SpanExporter has ${openSpanCount} unsent spans remaining`);\n      this._cleanupOldSpans();\n      return;\n    }\n\n    this._clearTimeout();\n\n    // If we got a parent span, we try to send the span tree\n    // Wait a tick for this, to ensure we avoid race conditions\n    this._flushTimeout = setTimeout(() => {\n      this.flush();\n    }, 1);\n  }\n\n  /** Try to flush any pending spans immediately. */\n   flush() {\n    this._clearTimeout();\n\n    const openSpanCount = this._finishedSpans.length;\n\n    const remainingSpans = maybeSend(this._finishedSpans);\n\n    const remainingOpenSpanCount = remainingSpans.length;\n    const sentSpanCount = openSpanCount - remainingOpenSpanCount;\n\n    DEBUG_BUILD &&\n      utils.logger.log(`SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} unsent spans remaining`);\n\n    this._cleanupOldSpans(remainingSpans);\n  }\n\n  /** Clear the exporter. */\n   clear() {\n    this._finishedSpans = [];\n    this._clearTimeout();\n  }\n\n  /** Clear the flush timeout. */\n   _clearTimeout() {\n    if (this._flushTimeout) {\n      clearTimeout(this._flushTimeout);\n      this._flushTimeout = undefined;\n    }\n  }\n\n  /**\n   * Remove any span that is older than 5min.\n   * We do this to avoid leaking memory.\n   */\n   _cleanupOldSpans(spans = this._finishedSpans) {\n    this._finishedSpans = spans.filter(span => {\n      const shouldDrop = shouldCleanupSpan(span, this._timeout);\n      DEBUG_BUILD &&\n        shouldDrop &&\n        utils.logger.log(\n          `SpanExporter dropping span ${span.name} (${\n            span.spanContext().spanId\n          }) because it is pending for more than 5 minutes.`,\n        );\n      return !shouldDrop;\n    });\n  }\n}\n\n/**\n * Send the given spans, but only if they are part of a finished transaction.\n *\n * Returns the unsent spans.\n * Spans remain unsent when their parent span is not yet finished.\n * This will happen regularly, as child spans are generally finished before their parents.\n * But it _could_ also happen because, for whatever reason, a parent span was lost.\n * In this case, we'll eventually need to clean this up.\n */\nfunction maybeSend(spans) {\n  const grouped = groupSpansWithParents(spans);\n  const remaining = new Set(grouped);\n\n  const rootNodes = getCompletedRootNodes(grouped);\n\n  rootNodes.forEach(root => {\n    remaining.delete(root);\n    const span = root.span;\n    const transactionEvent = createTransactionForOtelSpan(span);\n\n    // We'll recursively add all the child spans to this array\n    const spans = transactionEvent.spans || [];\n\n    root.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, remaining);\n    });\n\n    // spans.sort() mutates the array, but we do not use this anymore after this point\n    // so we can safely mutate it here\n    transactionEvent.spans =\n      spans.length > MAX_SPAN_COUNT\n        ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n        : spans;\n\n    const measurements = core.timedEventsToMeasurements(span.events);\n    if (measurements) {\n      transactionEvent.measurements = measurements;\n    }\n\n    core.captureEvent(transactionEvent);\n  });\n\n  return Array.from(remaining)\n    .map(node => node.span)\n    .filter((span) => !!span);\n}\n\nfunction nodeIsCompletedRootNode(node) {\n  return !!node.span && !node.parentNode;\n}\n\nfunction getCompletedRootNodes(nodes) {\n  return nodes.filter(nodeIsCompletedRootNode);\n}\n\nfunction shouldCleanupSpan(span, maxStartTimeOffsetSeconds) {\n  const cutoff = Date.now() / 1000 - maxStartTimeOffsetSeconds;\n  return core.spanTimeInputToSeconds(span.startTime) < cutoff;\n}\n\nfunction parseSpan(span) {\n  const attributes = span.attributes;\n\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ;\n  const op = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] ;\n  const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n  return { origin, op, source };\n}\n\nfunction createTransactionForOtelSpan(span) {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = core.getCapturedScopesOnSpan(span );\n\n  const sampleRate = span.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ;\n\n  const attributes = utils.dropUndefinedKeys({\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  });\n\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  const parentSpanIdFromTraceState = _optionalChain$2([span, 'access', _2 => _2.spanContext, 'call', _3 => _3(), 'access', _4 => _4.traceState, 'optionalAccess', _5 => _5.get, 'call', _6 => _6(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take presedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id =\n    typeof parentSpanIdFromTraceState === 'string' ? parentSpanIdFromTraceState || undefined : span.parentSpanId;\n\n  const status = mapStatus(span);\n\n  const traceContext = utils.dropUndefinedKeys({\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n  });\n\n  const transactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n    },\n    spans: [],\n    start_timestamp: core.spanTimeInputToSeconds(span.startTime),\n    timestamp: core.spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      ...utils.dropUndefinedKeys({\n        capturedSpanScope: capturedSpanScopes.scope,\n        capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n        sampleRate,\n        dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(span ),\n      }),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n    _metrics_summary: core.getMetricSummaryJsonForSpan(span ),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node, spans, remaining) {\n  remaining.delete(node);\n  const span = node.span;\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, remaining);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n\n  const { attributes, startTime, endTime, parentSpanId } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = utils.dropUndefinedKeys({\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  });\n\n  const status = mapStatus(span);\n\n  const spanJSON = utils.dropUndefinedKeys({\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: core.spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: core.spanTimeInputToSeconds(endTime) || undefined,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    _metrics_summary: core.getMetricSummaryJsonForSpan(span ),\n    measurements: core.timedEventsToMeasurements(span.events),\n  });\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, remaining);\n  });\n}\n\nfunction getSpanData(span)\n\n {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attribtues we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data) {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span) {\n  const attributes = span.attributes;\n  const data = {\n    'otel.kind': api.SpanKind[span.kind],\n  };\n\n  if (attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE]) {\n    const statusCode = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE] ;\n    data['http.response.status_code'] = statusCode;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n\nfunction _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nfunction onSpanStart(span, parentContext) {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = api.trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    core.addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan && parentSpan.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === api.ROOT_CONTEXT) {\n    scopes = {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    core.setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  core.logSpanStart(span);\n\n  const client = core.getClient();\n  _optionalChain$1([client, 'optionalAccess', _ => _.emit, 'call', _2 => _2('spanStart', span)]);\n}\n\nfunction onSpanEnd(span) {\n  core.logSpanEnd(span);\n\n  const client = core.getClient();\n  _optionalChain$1([client, 'optionalAccess', _3 => _3.emit, 'call', _4 => _4('spanEnd', span)]);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nclass SentrySpanProcessor  {\n\n   constructor(options) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async forceFlush() {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async shutdown() {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   onStart(span, parentContext) {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n   onEnd(span) {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nclass SentrySampler  {\n\n   constructor(client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n   shouldSample(\n    context,\n    traceId,\n    spanName,\n    spanKind,\n    spanAttributes,\n    _links,\n  ) {\n    const options = this._client.getOptions();\n\n    const parentSpan = api.trace.getSpan(context);\n    const parentContext = _optionalChain([parentSpan, 'optionalAccess', _ => _.spanContext, 'call', _2 => _2()]);\n\n    if (!core.hasTracingEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (\n      spanKind === api.SpanKind.CLIENT &&\n      spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD] &&\n      (!parentSpan || _optionalChain([parentContext, 'optionalAccess', _3 => _3.isRemote]))\n    ) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: spanAttributes,\n        spanName: spanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const [sampled, sampleRate] = core.sampleSpan(options, {\n      name: spanName,\n      attributes: spanAttributes,\n      transactionContext: {\n        name: spanName,\n        parentSampled,\n      },\n      parentSampled,\n    });\n\n    const attributes = {\n      [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    };\n\n    const method = `${spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD]}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && utils.logger.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return {\n        ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.NOT_RECORD, context, spanAttributes }),\n        attributes,\n      };\n    }\n\n    if (!sampled) {\n      return {\n        ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.NOT_RECORD, context, spanAttributes }),\n        attributes,\n      };\n    }\n    return {\n      ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED, context, spanAttributes }),\n      attributes,\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n   toString() {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentRemoteSampled(parentSpan) {\n  const traceId = parentSpan.spanContext().traceId;\n  const traceparentData = getPropagationContextFromSpan(parentSpan);\n\n  // Only inherit sampled if `traceId` is the same\n  return traceparentData && traceId === traceparentData.traceId ? traceparentData.sampled : undefined;\n}\n\nfunction getParentSampled(parentSpan, traceId, spanName) {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (api.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getParentRemoteSampled(parentSpan);\n      DEBUG_BUILD &&\n        utils.logger.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && utils.logger.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nfunction wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n}) {\n  const traceState = getBaseTraceState(context, spanAttributes);\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === sdkTraceBase.SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context, spanAttributes) {\n  const parentSpan = api.trace.getSpan(context);\n  const parentContext = _optionalChain([parentSpan, 'optionalAccess', _4 => _4.spanContext, 'call', _5 => _5()]);\n\n  let traceState = _optionalChain([parentContext, 'optionalAccess', _6 => _6.traceState]) || new core$1.TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  const url = spanAttributes[semanticConventions.SEMATTRS_HTTP_URL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * This method takes an OpenTelemetry instrumentation or\n * array of instrumentations and registers them with OpenTelemetry.\n */\nfunction addOpenTelemetryInstrumentation(...instrumentations) {\n  instrumentation.registerInstrumentations({\n    instrumentations,\n  });\n}\n\nexports.getClient = core.getClient;\nexports.getCurrentHubShim = core.getCurrentHubShim;\nexports.getDynamicSamplingContextFromSpan = core.getDynamicSamplingContextFromSpan;\nexports.SentryPropagator = SentryPropagator;\nexports.SentrySampler = SentrySampler;\nexports.SentrySpanProcessor = SentrySpanProcessor;\nexports.addOpenTelemetryInstrumentation = addOpenTelemetryInstrumentation;\nexports.continueTrace = continueTrace;\nexports.enhanceDscWithOpenTelemetryRootSpanName = enhanceDscWithOpenTelemetryRootSpanName;\nexports.getActiveSpan = getActiveSpan;\nexports.getRequestSpanData = getRequestSpanData;\nexports.getScopesFromContext = getScopesFromContext;\nexports.getSpanKind = getSpanKind;\nexports.isSentryRequestSpan = isSentryRequestSpan;\nexports.openTelemetrySetupCheck = openTelemetrySetupCheck;\nexports.setOpenTelemetryContextAsyncContextStrategy = setOpenTelemetryContextAsyncContextStrategy;\nexports.setupEventContextTrace = setupEventContextTrace;\nexports.spanHasAttributes = spanHasAttributes;\nexports.spanHasEvents = spanHasEvents;\nexports.spanHasKind = spanHasKind;\nexports.spanHasName = spanHasName;\nexports.spanHasParentId = spanHasParentId;\nexports.spanHasStatus = spanHasStatus;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\nexports.wrapClientClass = wrapClientClass;\nexports.wrapContextManagerClass = wrapContextManagerClass;\nexports.wrapSamplingDecision = wrapSamplingDecision;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrb3BlbnRlbGVtZXRyeUA4LjE3LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wX0BvcGVudGVsZW1ldHJ5K2NvcmVAMS4yNS4xX0BvcGVudGVsZW1ldF9vdzdjMzdkbTNsNGJ5bWM3aTRldGlwem1hYS9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L2J1aWxkL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkhBQWU7O0FBRTNCLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsNEJBQTRCLG1CQUFPLENBQUMsNkxBQXFDO0FBQ3pFLGNBQWMsbUJBQU8sQ0FBQywySEFBZTtBQUNyQyxZQUFZLG1CQUFPLENBQUMseUlBQW9CO0FBQ3hDLGFBQWEsbUJBQU8sQ0FBQyx3SEFBYztBQUNuQyxlQUFlLG1CQUFPLENBQUMsc0tBQXFCO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLG9NQUErQjtBQUM1RCx3QkFBd0IsbUJBQU8sQ0FBQyx1TUFBZ0M7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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cUJBQXFCO0FBQ3JCLHlCQUF5QjtBQUN6QixpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8tcHJvamVjdC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2VudHJ5K29wZW50ZWxlbWV0cnlAOC4xNy4wX0BvcGVudGVsZW1ldHJ5K2FwaUAxLjkuMF9Ab3BlbnRlbGVtZXRyeStjb3JlQDEuMjUuMV9Ab3BlbnRlbGVtZXRfb3c3YzM3ZG0zbDRieW1jN2k0ZXRpcHptYWEvbm9kZV9tb2R1bGVzL0BzZW50cnkvb3BlbnRlbGVtZXRyeS9idWlsZC9janMvaW5kZXguanM/NDFjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIge1xuICBfb3B0aW9uYWxDaGFpblxufSA9IHJlcXVpcmUoJ0BzZW50cnkvdXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuY29uc3Qgc2VtYW50aWNDb252ZW50aW9ucyA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJ0BzZW50cnkvdXRpbHMnKTtcbmNvbnN0IGFwaSA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2FwaScpO1xuY29uc3QgY29yZSA9IHJlcXVpcmUoJ0BzZW50cnkvY29yZScpO1xuY29uc3QgY29yZSQxID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvY29yZScpO1xuY29uc3Qgc2RrVHJhY2VCYXNlID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2UnKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJ0BvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvbicpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYXR0cmlidXRlcy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhdHRyaWJ1dGVzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgdGhlbS5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0F0dHJpYnV0ZXMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4uYXR0cmlidXRlcyAmJiB0eXBlb2YgY2FzdFNwYW4uYXR0cmlidXRlcyA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIGtpbmQuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBraW5kLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNLaW5kKHNwYW4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4ua2luZDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEgc3RhdHVzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEgc3RhdHVzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNTdGF0dXMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4uc3RhdHVzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBuYW1lLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGEgbmFtZSxcbiAqIHNvIGluIHBsYWNlcyB3aGVyZSB3ZSBhcmUgcGFzc2VkIGEgZ2VuZXJpYyBzcGFuLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIHdhbnQgdG8gYWNjZXNzIGl0LlxuICovXG5mdW5jdGlvbiBzcGFuSGFzTmFtZShzcGFuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLm5hbWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIGtpbmQuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBraW5kLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNQYXJlbnRJZChcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5wYXJlbnRTcGFuSWQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBldmVudHMuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgZXZlbnRzLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNFdmVudHMoXG4gIHNwYW4sXG4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2FzdFNwYW4uZXZlbnRzKTtcbn1cblxuLyoqXG4gKiBHZXQgc2FuaXRpemllZCByZXF1ZXN0IGRhdGEgZnJvbSBhbiBPVEVMIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGdldFJlcXVlc3RTcGFuRGF0YShzcGFuKSB7XG4gIC8vIFRoZSBiYXNlIGBTcGFuYCB0eXBlIGhhcyBubyBgYXR0cmlidXRlc2AsIHNvIHdlIG5lZWQgdG8gZ3VhcmQgaGVyZSBhZ2FpbnN0IHRoYXRcbiAgaWYgKCFzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdXJsOiBzcGFuLmF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF0gLFxuICAgICdodHRwLm1ldGhvZCc6IHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXSAsXG4gIH07XG5cbiAgLy8gRGVmYXVsdCB0byBHRVQgaWYgVVJMIGlzIHNldCBidXQgbWV0aG9kIGlzIG5vdFxuICBpZiAoIWRhdGFbJ2h0dHAubWV0aG9kJ10gJiYgZGF0YS51cmwpIHtcbiAgICBkYXRhWydodHRwLm1ldGhvZCddID0gJ0dFVCc7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHVybFN0ciA9IHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXTtcbiAgICBpZiAodHlwZW9mIHVybFN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHVybCA9IHV0aWxzLnBhcnNlVXJsKHVybFN0cik7XG5cbiAgICAgIGRhdGEudXJsID0gdXRpbHMuZ2V0U2FuaXRpemVkVXJsU3RyaW5nKHVybCk7XG5cbiAgICAgIGlmICh1cmwuc2VhcmNoKSB7XG4gICAgICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHVybC5zZWFyY2g7XG4gICAgICB9XG4gICAgICBpZiAodXJsLmhhc2gpIHtcbiAgICAgICAgZGF0YVsnaHR0cC5mcmFnbWVudCddID0gdXJsLmhhc2g7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlXG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kOChvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG4vLyBUeXBlc2NyaXB0IGNvbXBsYWlucyBpZiB3ZSBkbyBub3QgdXNlIGAuLi5hcmdzOiBhbnlbXWAgZm9yIHRoZSBtaXhpbiwgd2l0aDpcbi8vIEEgbWl4aW4gY2xhc3MgbXVzdCBoYXZlIGEgY29uc3RydWN0b3Igd2l0aCBhIHNpbmdsZSByZXN0IHBhcmFtZXRlciBvZiB0eXBlICdhbnlbXScudHMoMjU0NSlcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuLyoqXG4gKiBXcmFwIGFuIENsaWVudCB3aXRoIHRoaW5ncyB3ZSBuZWVkIGZvciBPcGVuVGVsZW1ldHJ5IHN1cHBvcnQuXG4gKlxuICogVXNhZ2U6XG4gKiBjb25zdCBPcGVuVGVsZW1ldHJ5Q2xpZW50ID0gZ2V0V3JhcHBlZENsaWVudENsYXNzKE5vZGVDbGllbnQpO1xuICogY29uc3QgY2xpZW50ID0gbmV3IE9wZW5UZWxlbWV0cnlDbGllbnQob3B0aW9ucyk7XG4gKi9cbmZ1bmN0aW9uIHdyYXBDbGllbnRDbGFzc1xuXG4oQ2xpZW50Q2xhc3MpIHtcbiAgY2xhc3MgT3BlblRlbGVtZXRyeUNsaWVudCBleHRlbmRzIENsaWVudENsYXNzICB7XG5cbiAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgT1RFTCB0cmFjZXIuICovXG4gICAgIGdldCB0cmFjZXIoKSB7XG4gICAgICBpZiAodGhpcy5fdHJhY2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjZXI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5hbWUgPSAnQHNlbnRyeS9vcGVudGVsZW1ldHJ5JztcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBjb3JlLlNES19WRVJTSU9OO1xuICAgICAgY29uc3QgdHJhY2VyID0gYXBpLnRyYWNlLmdldFRyYWNlcihuYW1lLCB2ZXJzaW9uKTtcbiAgICAgIHRoaXMuX3RyYWNlciA9IHRyYWNlcjtcblxuICAgICAgcmV0dXJuIHRyYWNlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgICBhc3luYyBmbHVzaCh0aW1lb3V0KSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMudHJhY2VQcm92aWRlcjtcbiAgICAgIGNvbnN0IHNwYW5Qcm9jZXNzb3IgPSBfb3B0aW9uYWxDaGFpbiQ4KFtwcm92aWRlciwgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLmFjdGl2ZVNwYW5Qcm9jZXNzb3JdKTtcblxuICAgICAgaWYgKHNwYW5Qcm9jZXNzb3IpIHtcbiAgICAgICAgYXdhaXQgc3BhblByb2Nlc3Nvci5mb3JjZUZsdXNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBlci5mbHVzaCh0aW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT3BlblRlbGVtZXRyeUNsaWVudCA7XG59XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuLyoqXG4gKiBHZXQgdGhlIHNwYW4ga2luZCBmcm9tIGEgc3Bhbi5cbiAqIEZvciB3aGF0ZXZlciByZWFzb24sIHRoaXMgaXMgbm90IHB1YmxpYyBBUEkgb24gdGhlIGdlbmVyaWMgXCJTcGFuXCIgdHlwZSxcbiAqIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgYWN0dWFsbHkgaGF2ZSBhIGBTREtUcmFjZUJhc2VTcGFuYCB3aGVyZSB3ZSBjYW4gZmV0Y2ggdGhpcyBmcm9tLlxuICogT3RoZXJ3aXNlLCB3ZSBmYWxsIGJhY2sgdG8gYFNwYW5LaW5kLklOVEVSTkFMYC5cbiAqL1xuZnVuY3Rpb24gZ2V0U3BhbktpbmQoc3Bhbikge1xuICBpZiAoc3Bhbkhhc0tpbmQoc3BhbikpIHtcbiAgICByZXR1cm4gc3Bhbi5raW5kO1xuICB9XG5cbiAgcmV0dXJuIGFwaS5TcGFuS2luZC5JTlRFUk5BTDtcbn1cblxuY29uc3QgU0VOVFJZX1RSQUNFX0hFQURFUiA9ICdzZW50cnktdHJhY2UnO1xuY29uc3QgU0VOVFJZX0JBR0dBR0VfSEVBREVSID0gJ2JhZ2dhZ2UnO1xuXG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfRFNDID0gJ3NlbnRyeS5kc2MnO1xuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX1BBUkVOVF9TUEFOX0lEID0gJ3NlbnRyeS5wYXJlbnRfc3Bhbl9pZCc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HID0gJ3NlbnRyeS5zYW1wbGVkX25vdF9yZWNvcmRpbmcnO1xuY29uc3QgU0VOVFJZX1RSQUNFX1NUQVRFX1VSTCA9ICdzZW50cnkudXJsJztcblxuY29uc3QgU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfc2NvcGVzJyk7XG5cbmNvbnN0IFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSA9IGFwaS5jcmVhdGVDb250ZXh0S2V5KCdzZW50cnlfZm9ya19pc29sYXRpb25fc2NvcGUnKTtcblxuY29uc3QgU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX3NldF9zY29wZScpO1xuXG5jb25zdCBTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX3NldF9pc29sYXRpb25fc2NvcGUnKTtcblxuY29uc3QgU0NPUEVfQ09OVEVYVF9GSUVMRCA9ICdfc2NvcGVDb250ZXh0JztcblxuLyoqXG4gKiBUcnkgdG8gZ2V0IHRoZSBjdXJyZW50IHNjb3BlcyBmcm9tIHRoZSBnaXZlbiBPVEVMIGNvbnRleHQuXG4gKiBUaGlzIHJlcXVpcmVzIGEgQ29udGV4dCBNYW5hZ2VyIHRoYXQgd2FzIHdyYXBwZWQgd2l0aCBnZXRXcmFwcGVkQ29udGV4dE1hbmFnZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpIHtcbiAgcmV0dXJuIGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSkgO1xufVxuXG4vKipcbiAqIFNldCB0aGUgY3VycmVudCBzY29wZXMgb24gYW4gT1RFTCBjb250ZXh0LlxuICogVGhpcyB3aWxsIHJldHVybiBhIGZvcmtlZCBjb250ZXh0IHdpdGggdGhlIFByb3BhZ2F0aW9uIENvbnRleHQgc2V0LlxuICovXG5mdW5jdGlvbiBzZXRTY29wZXNPbkNvbnRleHQoY29udGV4dCwgc2NvcGVzKSB7XG4gIHJldHVybiBjb250ZXh0LnNldFZhbHVlKFNFTlRSWV9TQ09QRVNfQ09OVEVYVF9LRVksIHNjb3Blcyk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjb250ZXh0IG9uIHRoZSBzY29wZSBzbyB3ZSBjYW4gbGF0ZXIgbG9vayBpdCB1cC5cbiAqIFdlIG5lZWQgdGhpcyB0byBnZXQgdGhlIGNvbnRleHQgZnJvbSB0aGUgc2NvcGUgaW4gdGhlIGB0cmFjZWAgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBzZXRDb250ZXh0T25TY29wZShzY29wZSwgY29udGV4dCkge1xuICB1dGlscy5hZGROb25FbnVtZXJhYmxlUHJvcGVydHkoc2NvcGUsIFNDT1BFX0NPTlRFWFRfRklFTEQsIGNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGV4dCByZWxhdGVkIHRvIGEgc2NvcGUuXG4gKiBUT0RPIHY4OiBVc2UgdGhpcyBmb3IgdGhlIGB0cmFjZWAgZnVuY3Rpb25zLlxuICogKi9cbmZ1bmN0aW9uIGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpIHtcbiAgcmV0dXJuIChzY29wZSApW1NDT1BFX0NPTlRFWFRfRklFTERdO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gb3RlbFNwYW4gQ2hlY2tzIHdoZXRlciBhIGdpdmVuIE9URUwgU3BhbiBpcyBhbiBodHRwIHJlcXVlc3QgdG8gc2VudHJ5LlxuICogQHJldHVybnMgYm9vbGVhblxuICovXG5mdW5jdGlvbiBpc1NlbnRyeVJlcXVlc3RTcGFuKHNwYW4pIHtcbiAgaWYgKCFzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHsgYXR0cmlidXRlcyB9ID0gc3BhbjtcblxuICBjb25zdCBodHRwVXJsID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXTtcblxuICBpZiAoIWh0dHBVcmwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gY29yZS5pc1NlbnRyeVJlcXVlc3RVcmwoaHR0cFVybC50b1N0cmluZygpLCBjb3JlLmdldENsaWVudCgpKTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGJldHRlciBvcC9kZXNjcmlwdGlvbiBmcm9tIGFuIG90ZWwgc3Bhbi5cbiAqXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1jb2xsZWN0b3ItY29udHJpYi9ibG9iLzc0MjJjZTJhMDYzMzdmNjhhNTliNTUyYjhjNWEyYWMxMjVkNmJhZTUvZXhwb3J0ZXIvc2VudHJ5ZXhwb3J0ZXIvc2VudHJ5X2V4cG9ydGVyLmdvI0wzMDZcbiAqL1xuZnVuY3Rpb24gcGFyc2VTcGFuRGVzY3JpcHRpb24oc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikgPyBzcGFuLmF0dHJpYnV0ZXMgOiB7fTtcbiAgY29uc3QgbmFtZSA9IHNwYW5IYXNOYW1lKHNwYW4pID8gc3Bhbi5uYW1lIDogJzx1bmtub3duPic7XG5cbiAgLy8gVGhpcyBhdHRyaWJ1dGUgaXMgaW50ZW50aW9uYWxseSBleHBvcnRlZCBhcyBhIFNFTUFUVFIgY29uc3RhbnQgYmVjYXVzZSBpdCBzaG91bGQgc3RheSBpbnRpbWl0ZSBBUElcbiAgaWYgKGF0dHJpYnV0ZXNbJ3NlbnRyeS5za2lwX3NwYW5fZGF0YV9pbmZlcmVuY2UnXSkge1xuICAgIHJldHVybiB7XG4gICAgICBvcDogdW5kZWZpbmVkLFxuICAgICAgZGVzY3JpcHRpb246IG5hbWUsXG4gICAgICBzb3VyY2U6ICdjdXN0b20nLFxuICAgICAgZGF0YToge1xuICAgICAgICAvLyBTdWdnZXN0IHRvIGNhbGxlcnMgb2YgYHBhcnNlU3BhbkRlc2NyaXB0aW9uYCB0byB3aXBlIHRoZSBoaW50IGJlY2F1c2UgaXQgaXMgdW5uZWNlc3NhcnkgZGF0YSBpbiB0aGUgZW5kLlxuICAgICAgICAnc2VudHJ5LnNraXBfc3Bhbl9kYXRhX2luZmVyZW5jZSc6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIGlmIGh0dHAubWV0aG9kIGV4aXN0cywgdGhpcyBpcyBhbiBodHRwIHJlcXVlc3Qgc3BhblxuICAvL1xuICAvLyBUT0RPOiBSZWZlcmVuY2luZyBgaHR0cC5yZXF1ZXN0Lm1ldGhvZGAgaXMgYSB0ZW1wb3Jhcnkgd29ya2Fyb3VuZCB1bnRpbCB0aGUgc2VtYW50aWNcbiAgLy8gY29udmVudGlvbnMgZXhwb3J0IGFuIGF0dHJpYnV0ZSBrZXkgZm9yIGl0LlxuICBjb25zdCBodHRwTWV0aG9kID0gYXR0cmlidXRlc1snaHR0cC5yZXF1ZXN0Lm1ldGhvZCddIHx8IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF07XG4gIGlmIChodHRwTWV0aG9kKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uRm9ySHR0cE1ldGhvZCh7IGF0dHJpYnV0ZXMsIG5hbWUsIGtpbmQ6IGdldFNwYW5LaW5kKHNwYW4pIH0sIGh0dHBNZXRob2QpO1xuICB9XG5cbiAgY29uc3QgZGJTeXN0ZW0gPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfREJfU1lTVEVNXTtcbiAgY29uc3Qgb3BJc0NhY2hlID1cbiAgICB0eXBlb2YgYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdID09PSAnc3RyaW5nJyAmJlxuICAgIGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXS5zdGFydHNXaXRoKCdjYWNoZS4nKTtcblxuICAvLyBJZiBkYi50eXBlIGV4aXN0cyB0aGVuIHRoaXMgaXMgYSBkYXRhYmFzZSBjYWxsIHNwYW5cbiAgLy8gSWYgdGhlIFJlZGlzIERCIGlzIHVzZWQgYXMgYSBjYWNoZSwgdGhlIHNwYW4gZGVzY3JpcHRpb24gc2hvdWxkIG5vdCBiZSBjaGFuZ2VkXG4gIGlmIChkYlN5c3RlbSAmJiAhb3BJc0NhY2hlKSB7XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uRm9yRGJTeXN0ZW0oeyBhdHRyaWJ1dGVzLCBuYW1lIH0pO1xuICB9XG5cbiAgLy8gSWYgcnBjLnNlcnZpY2UgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIHJwYyBjYWxsIHNwYW4uXG4gIGNvbnN0IHJwY1NlcnZpY2UgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfUlBDX1NFUlZJQ0VdO1xuICBpZiAocnBjU2VydmljZSkge1xuICAgIHJldHVybiB7XG4gICAgICBvcDogJ3JwYycsXG4gICAgICBkZXNjcmlwdGlvbjogbmFtZSxcbiAgICAgIHNvdXJjZTogJ3JvdXRlJyxcbiAgICB9O1xuICB9XG5cbiAgLy8gSWYgbWVzc2FnaW5nLnN5c3RlbSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgbWVzc2FnaW5nIHN5c3RlbSBzcGFuLlxuICBjb25zdCBtZXNzYWdpbmdTeXN0ZW0gPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfTUVTU0FHSU5HX1NZU1RFTV07XG4gIGlmIChtZXNzYWdpbmdTeXN0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3A6ICdtZXNzYWdlJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBuYW1lLFxuICAgICAgc291cmNlOiAncm91dGUnLFxuICAgIH07XG4gIH1cblxuICAvLyBJZiBmYWFzLnRyaWdnZXIgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIGZ1bmN0aW9uIGFzIGEgc2VydmljZSBzcGFuLlxuICBjb25zdCBmYWFzVHJpZ2dlciA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19GQUFTX1RSSUdHRVJdO1xuICBpZiAoZmFhc1RyaWdnZXIpIHtcbiAgICByZXR1cm4geyBvcDogZmFhc1RyaWdnZXIudG9TdHJpbmcoKSwgZGVzY3JpcHRpb246IG5hbWUsIHNvdXJjZTogJ3JvdXRlJyB9O1xuICB9XG5cbiAgcmV0dXJuIHsgb3A6IHVuZGVmaW5lZCwgZGVzY3JpcHRpb246IG5hbWUsIHNvdXJjZTogJ2N1c3RvbScgfTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpcHRpb25Gb3JEYlN5c3RlbSh7IGF0dHJpYnV0ZXMsIG5hbWUgfSkge1xuICAvLyBVc2UgREIgc3RhdGVtZW50IChFeCBcIlNFTEVDVCAqIEZST00gdGFibGVcIikgaWYgcG9zc2libGUgYXMgZGVzY3JpcHRpb24uXG4gIGNvbnN0IHN0YXRlbWVudCA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19EQl9TVEFURU1FTlRdO1xuXG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gc3RhdGVtZW50ID8gc3RhdGVtZW50LnRvU3RyaW5nKCkgOiBuYW1lO1xuXG4gIHJldHVybiB7IG9wOiAnZGInLCBkZXNjcmlwdGlvbiwgc291cmNlOiAndGFzaycgfTtcbn1cblxuLyoqIE9ubHkgZXhwb3J0ZWQgZm9yIHRlc3RzLiAqL1xuZnVuY3Rpb24gZGVzY3JpcHRpb25Gb3JIdHRwTWV0aG9kKFxuICB7IG5hbWUsIGtpbmQsIGF0dHJpYnV0ZXMgfSxcbiAgaHR0cE1ldGhvZCxcbikge1xuICBjb25zdCBvcFBhcnRzID0gWydodHRwJ107XG5cbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSBhcGkuU3BhbktpbmQuQ0xJRU5UOlxuICAgICAgb3BQYXJ0cy5wdXNoKCdjbGllbnQnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYXBpLlNwYW5LaW5kLlNFUlZFUjpcbiAgICAgIG9wUGFydHMucHVzaCgnc2VydmVyJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGNvbnN0IHsgdXJsUGF0aCwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlIH0gPSBnZXRTYW5pdGl6ZWRVcmwoYXR0cmlidXRlcywga2luZCk7XG5cbiAgaWYgKCF1cmxQYXRoKSB7XG4gICAgcmV0dXJuIHsgb3A6IG9wUGFydHMuam9pbignLicpLCBkZXNjcmlwdGlvbjogbmFtZSwgc291cmNlOiAnY3VzdG9tJyB9O1xuICB9XG5cbiAgLy8gRXguIGRlc2NyaXB0aW9uPVwiR0VUIC9hcGkvdXNlcnNcIi5cbiAgY29uc3QgZGVzY3JpcHRpb24gPSBgJHtodHRwTWV0aG9kfSAke3VybFBhdGh9YDtcblxuICAvLyBJZiBgaHR0cFBhdGhgIGlzIGEgcm9vdCBwYXRoLCB0aGVuIHdlIGNhbiBjYXRlZ29yaXplIHRoZSB0cmFuc2FjdGlvbiBzb3VyY2UgYXMgcm91dGUuXG4gIGNvbnN0IHNvdXJjZSA9IGhhc1JvdXRlIHx8IHVybFBhdGggPT09ICcvJyA/ICdyb3V0ZScgOiAndXJsJztcblxuICBjb25zdCBkYXRhID0ge307XG5cbiAgaWYgKHVybCkge1xuICAgIGRhdGEudXJsID0gdXJsO1xuICB9XG4gIGlmIChxdWVyeSkge1xuICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHF1ZXJ5O1xuICB9XG4gIGlmIChmcmFnbWVudCkge1xuICAgIGRhdGFbJ2h0dHAuZnJhZ21lbnQnXSA9IGZyYWdtZW50O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcDogb3BQYXJ0cy5qb2luKCcuJyksXG4gICAgZGVzY3JpcHRpb24sXG4gICAgc291cmNlLFxuICAgIGRhdGEsXG4gIH07XG59XG5cbi8qKiBFeHBvcnRlZCBmb3IgdGVzdHMgb25seSAqL1xuZnVuY3Rpb24gZ2V0U2FuaXRpemVkVXJsKFxuICBhdHRyaWJ1dGVzLFxuICBraW5kLFxuKVxuXG4ge1xuICAvLyBUaGlzIGlzIHRoZSByZWxhdGl2ZSBwYXRoIG9mIHRoZSBVUkwsIGUuZy4gL3N1YlxuICBjb25zdCBodHRwVGFyZ2V0ID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVEFSR0VUXTtcbiAgLy8gVGhpcyBpcyB0aGUgZnVsbCBVUkwsIGluY2x1ZGluZyBob3N0ICYgcXVlcnkgcGFyYW1zIGV0Yy4sIGUuZy4gaHR0cHM6Ly9leGFtcGxlLmNvbS9zdWI/Zm9vPWJhclxuICBjb25zdCBodHRwVXJsID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXTtcbiAgLy8gVGhpcyBpcyB0aGUgbm9ybWFsaXplZCByb3V0ZSBuYW1lIC0gbWF5IG5vdCBhbHdheXMgYmUgYXZhaWxhYmxlIVxuICBjb25zdCBodHRwUm91dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9ST1VURV07XG5cbiAgY29uc3QgcGFyc2VkVXJsID0gdHlwZW9mIGh0dHBVcmwgPT09ICdzdHJpbmcnID8gdXRpbHMucGFyc2VVcmwoaHR0cFVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHVybCA9IHBhcnNlZFVybCA/IHV0aWxzLmdldFNhbml0aXplZFVybFN0cmluZyhwYXJzZWRVcmwpIDogdW5kZWZpbmVkO1xuICBjb25zdCBxdWVyeSA9IHBhcnNlZFVybCAmJiBwYXJzZWRVcmwuc2VhcmNoID8gcGFyc2VkVXJsLnNlYXJjaCA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZnJhZ21lbnQgPSBwYXJzZWRVcmwgJiYgcGFyc2VkVXJsLmhhc2ggPyBwYXJzZWRVcmwuaGFzaCA6IHVuZGVmaW5lZDtcblxuICBpZiAodHlwZW9mIGh0dHBSb3V0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiBodHRwUm91dGUsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogdHJ1ZSB9O1xuICB9XG5cbiAgaWYgKGtpbmQgPT09IGFwaS5TcGFuS2luZC5TRVJWRVIgJiYgdHlwZW9mIGh0dHBUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogdXRpbHMuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KGh0dHBUYXJnZXQpLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICBpZiAocGFyc2VkVXJsKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogdXJsLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICAvLyBmYWxsIGJhY2sgdG8gdGFyZ2V0IGV2ZW4gZm9yIGNsaWVudCBzcGFucywgaWYgbm8gVVJMIGlzIHByZXNlbnRcbiAgaWYgKHR5cGVvZiBodHRwVGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IHV0aWxzLnN0cmlwVXJsUXVlcnlBbmRGcmFnbWVudChodHRwVGFyZ2V0KSwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiBmYWxzZSB9O1xuICB9XG5cbiAgcmV0dXJuIHsgdXJsUGF0aDogdW5kZWZpbmVkLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG59XG5cbi8qKlxuICogU2V0dXAgYSBEU0MgaGFuZGxlciBvbiB0aGUgcGFzc2VkIGNsaWVudCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhlIHRyYW5zYWN0aW9uIG5hbWUgaXMgaW5mZXJyZWQgZnJvbSB0aGUgc3BhbiBjb3JyZWN0bHkuXG4gKi9cbmZ1bmN0aW9uIGVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZShjbGllbnQpIHtcbiAgY2xpZW50Lm9uKCdjcmVhdGVEc2MnLCAoZHNjLCByb290U3BhbikgPT4ge1xuICAgIC8vIFdlIHdhbnQgdG8gb3ZlcndyaXRlIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgRFNDIHRoYXQgaXMgY3JlYXRlZCBieSBkZWZhdWx0IGluIGNvcmVcbiAgICAvLyBUaGUgcmVhc29uIGZvciB0aGlzIGlzIHRoYXQgd2Ugd2FudCB0byBpbmZlciB0aGUgc3BhbiBuYW1lLCBub3QgdXNlIHRoZSBpbml0aWFsIG9uZVxuICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgZ2V0IG5hbWVzIGxpa2UgXCJHRVRcIiBpbnN0ZWFkIG9mIGUuZy4gXCJHRVQgL2Zvb1wiXG4gICAgLy8gYHBhcnNlU3BhbkRlc2NyaXB0aW9uYCB0YWtlcyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgc3BhbiBpbnRvIGFjY291bnQgZm9yIHRoZSBuYW1lXG4gICAgLy8gVGhpcyBtdXRhdGVzIHRoZSBwYXNzZWQtaW4gRFNDXG4gICAgaWYgKHJvb3RTcGFuKSB7XG4gICAgICBjb25zdCBqc29uU3BhbiA9IGNvcmUuc3BhblRvSlNPTihyb290U3Bhbik7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0ganNvblNwYW4uZGF0YSB8fCB7fTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV07XG5cbiAgICAgIGNvbnN0IHsgZGVzY3JpcHRpb24gfSA9IHNwYW5IYXNOYW1lKHJvb3RTcGFuKSA/IHBhcnNlU3BhbkRlc2NyaXB0aW9uKHJvb3RTcGFuKSA6IHsgZGVzY3JpcHRpb246IHVuZGVmaW5lZCB9O1xuICAgICAgaWYgKHNvdXJjZSAhPT0gJ3VybCcgJiYgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgZHNjLnRyYW5zYWN0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZVNwYW4oKSB7XG4gIHJldHVybiBhcGkudHJhY2UuZ2V0QWN0aXZlU3BhbigpO1xufVxuXG4vKipcbiAqIFRoaXMgc2VydmVzIGFzIGEgYnVpbGQgdGltZSBmbGFnIHRoYXQgd2lsbCBiZSB0cnVlIGJ5IGRlZmF1bHQsIGJ1dCBmYWxzZSBpbiBub24tZGVidWcgYnVpbGRzIG9yIGlmIHVzZXJzIHJlcGxhY2UgYF9fU0VOVFJZX0RFQlVHX19gIGluIHRoZWlyIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEFUVEVOVElPTjogVGhpcyBjb25zdGFudCBtdXN0IG5ldmVyIGNyb3NzIHBhY2thZ2UgYm91bmRhcmllcyAoaS5lLiBiZSBleHBvcnRlZCkgdG8gZ3VhcmFudGVlIHRoYXQgaXQgY2FuIGJlIHVzZWQgZm9yIHRyZWUgc2hha2luZy5cbiAqL1xuY29uc3QgREVCVUdfQlVJTEQgPSAodHlwZW9mIF9fU0VOVFJZX0RFQlVHX18gPT09ICd1bmRlZmluZWQnIHx8IF9fU0VOVFJZX0RFQlVHX18pO1xuXG5mdW5jdGlvbiBfb3B0aW9uYWxDaGFpbiQ3KG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9XG5cbi8qKlxuICogT3BlblRlbGVtZXRyeSBvbmx5IGtub3dzIGFib3V0IFNBTVBMRUQgb3IgTk9ORSBkZWNpc2lvbixcbiAqIGJ1dCBmb3IgdXMgaXQgaXMgaW1wb3J0YW50IHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB1bnNldCBhbmQgdW5zYW1wbGVkLlxuICpcbiAqIEJvdGggb2YgdGhlc2UgYXJlIGlkZW50aWZpZWQgYXMgYHRyYWNlRmxhZ3MgPT09IFRyYWNlZ0ZsYWdzLk5PTkVgLFxuICogYnV0IHdlIGFkZGl0aW9uYWxseSBsb29rIGF0IGEgc3BlY2lhbCB0cmFjZSBzdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gdGhlbS5cbiAqL1xuZnVuY3Rpb24gZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCkge1xuICBjb25zdCB7IHRyYWNlRmxhZ3MsIHRyYWNlU3RhdGUgfSA9IHNwYW5Db250ZXh0O1xuXG4gIGNvbnN0IHNhbXBsZWROb3RSZWNvcmRpbmcgPSB0cmFjZVN0YXRlID8gdHJhY2VTdGF0ZS5nZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORykgPT09ICcxJyA6IGZhbHNlO1xuXG4gIC8vIElmIHRyYWNlIGZsYWcgaXMgYFNBTVBMRURgLCB3ZSBpbnRlcnByZXQgdGhpcyBhcyBzYW1wbGVkXG4gIC8vIElmIGl0IGlzIGBOT05FYCwgaXQgY291bGQgbWVhbiBlaXRoZXIgaXQgd2FzIHNhbXBsZWQgdG8gYmUgbm90IHJlY29yZGVyLCBvciB0aGF0IGl0IHdhcyBub3Qgc2FtcGxlZCBhdCBhbGxcbiAgLy8gRm9yIHVzIHRoaXMgaXMgYW4gaW1wb3J0YW50IGRpZmZlcmVuY2UsIHNvdyBlIGxvb2sgYXQgdGhlIFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkdcbiAgLy8gdG8gaWRlbnRpZnkgd2hpY2ggaXQgaXNcbiAgaWYgKHRyYWNlRmxhZ3MgPT09IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChzYW1wbGVkTm90UmVjb3JkaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRmFsbCBiYWNrIHRvIERTQyBhcyBhIGxhc3QgcmVzb3J0LCB0aGF0IG1heSBhbHNvIGNvbnRhaW4gYHNhbXBsZWRgLi4uXG4gIGNvbnN0IGRzY1N0cmluZyA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZHNjID0gZHNjU3RyaW5nID8gdXRpbHMuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChkc2NTdHJpbmcpIDogdW5kZWZpbmVkO1xuXG4gIGlmIChfb3B0aW9uYWxDaGFpbiQ3KFtkc2MsICdvcHRpb25hbEFjY2VzcycsIF8gPT4gXy5zYW1wbGVkXSkgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChfb3B0aW9uYWxDaGFpbiQ3KFtkc2MsICdvcHRpb25hbEFjY2VzcycsIF8yID0+IF8yLnNhbXBsZWRdKSA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IHNldHVwRWxlbWVudHMgPSBuZXcgU2V0KCk7XG5cbi8qKiBHZXQgYWxsIHRoZSBPcGVuVGVsZW1ldHJ5IGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIHNldCB1cC4gKi9cbmZ1bmN0aW9uIG9wZW5UZWxlbWV0cnlTZXR1cENoZWNrKCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShzZXR1cEVsZW1lbnRzKTtcbn1cblxuLyoqIE1hcmsgYW4gT3BlblRlbGVtZXRyeSBlbGVtZW50IGFzIHNldHVwLiAqL1xuZnVuY3Rpb24gc2V0SXNTZXR1cChlbGVtZW50KSB7XG4gIHNldHVwRWxlbWVudHMuYWRkKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBfb3B0aW9uYWxDaGFpbiQ2KG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9XG5cbi8qKiBHZXQgdGhlIFNlbnRyeSBwcm9wYWdhdGlvbiBjb250ZXh0IGZyb20gYSBzcGFuIGNvbnRleHQuICovXG5mdW5jdGlvbiBnZXRQcm9wYWdhdGlvbkNvbnRleHRGcm9tU3BhbihzcGFuKSB7XG4gIGNvbnN0IHNwYW5Db250ZXh0ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuICBjb25zdCB7IHRyYWNlSWQsIHNwYW5JZCwgdHJhY2VTdGF0ZSB9ID0gc3BhbkNvbnRleHQ7XG5cbiAgLy8gV2hlbiB3ZSBoYXZlIGEgZHNjIHRyYWNlIHN0YXRlLCBpdCBtZWFucyB0aGlzIGNhbWUgZnJvbSB0aGUgaW5jb21pbmcgdHJhY2VcbiAgLy8gVGhlbiB0aGlzIHRha2VzIHByZXNlZGVuY2Ugb3ZlciB0aGUgcm9vdCBzcGFuXG4gIGNvbnN0IGRzY1N0cmluZyA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdHJhY2VTdGF0ZURzYyA9IGRzY1N0cmluZyA/IHV0aWxzLmJhZ2dhZ2VIZWFkZXJUb0R5bmFtaWNTYW1wbGluZ0NvbnRleHQoZHNjU3RyaW5nKSA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBwYXJlbnRTcGFuSWQgPSB0cmFjZVN0YXRlID8gdHJhY2VTdGF0ZS5nZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1BBUkVOVF9TUEFOX0lEKSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgc2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24oc3BhbkNvbnRleHQpO1xuXG4gIC8vIE5vIHRyYWNlIHN0YXRlPyAtLT4gVGFrZSBEU0MgZnJvbSByb290IHNwYW5cbiAgY29uc3QgZHNjID0gdHJhY2VTdGF0ZURzYyB8fCBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3Bhbihjb3JlLmdldFJvb3RTcGFuKHNwYW4pKTtcblxuICByZXR1cm4ge1xuICAgIHRyYWNlSWQsXG4gICAgc3BhbklkLFxuICAgIHNhbXBsZWQsXG4gICAgcGFyZW50U3BhbklkLFxuICAgIGRzYyxcbiAgfTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIGFuZCBleHRyYWN0cyBgc2VudHJ5LXRyYWNlYCBhbmQgYGJhZ2dhZ2VgIGhlYWRlcnMgZnJvbSBjYXJyaWVycy5cbiAqL1xuY2xhc3MgU2VudHJ5UHJvcGFnYXRvciBleHRlbmRzIGNvcmUkMS5XM0NCYWdnYWdlUHJvcGFnYXRvciB7XG4gIC8qKiBBIG1hcCBvZiBVUkxzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gY2hlY2tlZCBmb3IgaWYgdGhleSBtYXRjaCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cy4gKi9cblxuICAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzZXRJc1NldHVwKCdTZW50cnlQcm9wYWdhdG9yJyk7XG5cbiAgICAvLyBXZSdyZSBjYWNoaW5nIHJlc3VsdHMgc28gd2UgZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgcmVnZXhwIGV2ZXJ5IHRpbWUgd2UgY3JlYXRlIGEgcmVxdWVzdC5cbiAgICB0aGlzLl91cmxNYXRjaGVzVGFyZ2V0c01hcCA9IG5ldyB1dGlscy5MUlVNYXAoMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGluamVjdChjb250ZXh0LCBjYXJyaWVyLCBzZXR0ZXIpIHtcbiAgICBpZiAoY29yZSQxLmlzVHJhY2luZ1N1cHByZXNzZWQoY29udGV4dCkpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIHV0aWxzLmxvZ2dlci5sb2coJ1tUcmFjaW5nXSBOb3QgaW5qZWN0aW5nIHRyYWNlIGRhdGEgZm9yIHVybCBiZWNhdXNlIHRyYWNpbmcgaXMgc3VwcHJlc3NlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG4gICAgY29uc3QgdXJsID0gYWN0aXZlU3BhbiAmJiBnZXRDdXJyZW50VVJMKGFjdGl2ZVNwYW4pO1xuXG4gICAgY29uc3QgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMgPSBfb3B0aW9uYWxDaGFpbiQ2KFtjb3JlLmdldENsaWVudCwgJ2NhbGwnLCBfID0+IF8oKSwgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuZ2V0T3B0aW9ucywgJ2NhbGwnLCBfMyA9PiBfMygpLCAnb3B0aW9uYWxBY2Nlc3MnLCBfNCA9PiBfNC50cmFjZVByb3BhZ2F0aW9uVGFyZ2V0c10pO1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnICYmXG4gICAgICB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cyAmJlxuICAgICAgIXRoaXMuX3Nob3VsZEluamVjdFRyYWNlRGF0YSh0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cywgdXJsKVxuICAgICkge1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgdXRpbHMubG9nZ2VyLmxvZyhcbiAgICAgICAgICAnW1RyYWNpbmddIE5vdCBpbmplY3RpbmcgdHJhY2UgZGF0YSBmb3IgdXJsIGJlY2F1c2UgaXQgZG9lcyBub3QgbWF0Y2ggdHJhY2VQcm9wYWdhdGlvblRhcmdldHM6JyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdCYWdnYWdlSGVhZGVyID0gZ2V0RXhpc3RpbmdCYWdnYWdlKGNhcnJpZXIpO1xuICAgIGxldCBiYWdnYWdlID0gYXBpLnByb3BhZ2F0aW9uLmdldEJhZ2dhZ2UoY29udGV4dCkgfHwgYXBpLnByb3BhZ2F0aW9uLmNyZWF0ZUJhZ2dhZ2Uoe30pO1xuXG4gICAgY29uc3QgeyBkeW5hbWljU2FtcGxpbmdDb250ZXh0LCB0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQgfSA9IGdldEluamVjdGlvbkRhdGEoY29udGV4dCk7XG5cbiAgICBpZiAoZXhpc3RpbmdCYWdnYWdlSGVhZGVyKSB7XG4gICAgICBjb25zdCBiYWdnYWdlRW50cmllcyA9IHV0aWxzLnBhcnNlQmFnZ2FnZUhlYWRlcihleGlzdGluZ0JhZ2dhZ2VIZWFkZXIpO1xuXG4gICAgICBpZiAoYmFnZ2FnZUVudHJpZXMpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoYmFnZ2FnZUVudHJpZXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIGJhZ2dhZ2UgPSBiYWdnYWdlLnNldEVudHJ5KGtleSwgeyB2YWx1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpIHtcbiAgICAgIGJhZ2dhZ2UgPSBPYmplY3QuZW50cmllcyhkeW5hbWljU2FtcGxpbmdDb250ZXh0KS5yZWR1Y2UoKGIsIFtkc2NLZXksIGRzY1ZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAoZHNjVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYi5zZXRFbnRyeShgJHt1dGlscy5TRU5UUllfQkFHR0FHRV9LRVlfUFJFRklYfSR7ZHNjS2V5fWAsIHsgdmFsdWU6IGRzY1ZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSwgYmFnZ2FnZSk7XG4gICAgfVxuXG4gICAgLy8gV2UgYWxzbyB3YW50IHRvIGF2b2lkIHNldHRpbmcgdGhlIGRlZmF1bHQgT1RFTCB0cmFjZSBJRCwgaWYgd2UgZ2V0IHRoYXQgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgIGlmICh0cmFjZUlkICYmIHRyYWNlSWQgIT09IGFwaS5JTlZBTElEX1RSQUNFSUQpIHtcbiAgICAgIHNldHRlci5zZXQoY2FycmllciwgU0VOVFJZX1RSQUNFX0hFQURFUiwgdXRpbHMuZ2VuZXJhdGVTZW50cnlUcmFjZUhlYWRlcih0cmFjZUlkLCBzcGFuSWQsIHNhbXBsZWQpKTtcbiAgICB9XG5cbiAgICBzdXBlci5pbmplY3QoYXBpLnByb3BhZ2F0aW9uLnNldEJhZ2dhZ2UoY29udGV4dCwgYmFnZ2FnZSksIGNhcnJpZXIsIHNldHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBleHRyYWN0KGNvbnRleHQsIGNhcnJpZXIsIGdldHRlcikge1xuICAgIGNvbnN0IG1heWJlU2VudHJ5VHJhY2VIZWFkZXIgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIFNFTlRSWV9UUkFDRV9IRUFERVIpO1xuICAgIGNvbnN0IGJhZ2dhZ2UgPSBnZXR0ZXIuZ2V0KGNhcnJpZXIsIFNFTlRSWV9CQUdHQUdFX0hFQURFUik7XG5cbiAgICBjb25zdCBzZW50cnlUcmFjZSA9IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJcbiAgICAgID8gQXJyYXkuaXNBcnJheShtYXliZVNlbnRyeVRyYWNlSGVhZGVyKVxuICAgICAgICA/IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJbMF1cbiAgICAgICAgOiBtYXliZVNlbnRyeVRyYWNlSGVhZGVyXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHV0aWxzLnByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzKHNlbnRyeVRyYWNlLCBiYWdnYWdlKTtcblxuICAgIC8vIEFkZCByZW1vdGUgcGFyZW50IHNwYW4gY29udGV4dFxuICAgIGNvbnN0IGN0eFdpdGhTcGFuQ29udGV4dCA9IGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3Bhbihjb250ZXh0LCB7IHNlbnRyeVRyYWNlLCBiYWdnYWdlIH0pO1xuXG4gICAgLy8gQWxzbyB1cGRhdGUgdGhlIHNjb3BlIG9uIHRoZSBjb250ZXh0ICh0byBiZSBzdXJlIHRoaXMgaXMgcGlja2VkIHVwIGV2ZXJ5d2hlcmUpXG4gICAgY29uc3Qgc2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY3R4V2l0aFNwYW5Db250ZXh0KTtcbiAgICBjb25zdCBuZXdTY29wZXMgPSB7XG4gICAgICBzY29wZTogc2NvcGVzID8gc2NvcGVzLnNjb3BlLmNsb25lKCkgOiBjb3JlLmdldEN1cnJlbnRTY29wZSgpLmNsb25lKCksXG4gICAgICBpc29sYXRpb25TY29wZTogc2NvcGVzID8gc2NvcGVzLmlzb2xhdGlvblNjb3BlIDogY29yZS5nZXRJc29sYXRpb25TY29wZSgpLFxuICAgIH07XG4gICAgbmV3U2NvcGVzLnNjb3BlLnNldFByb3BhZ2F0aW9uQ29udGV4dChwcm9wYWdhdGlvbkNvbnRleHQpO1xuXG4gICAgcmV0dXJuIHNldFNjb3Blc09uQ29udGV4dChjdHhXaXRoU3BhbkNvbnRleHQsIG5ld1Njb3Blcyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBmaWVsZHMoKSB7XG4gICAgcmV0dXJuIFtTRU5UUllfVFJBQ0VfSEVBREVSLCBTRU5UUllfQkFHR0FHRV9IRUFERVJdO1xuICB9XG5cbiAgLyoqIElmIHdlIHdhbnQgdG8gaW5qZWN0IHRyYWNlIGRhdGEgZm9yIGEgZ2l2ZW4gVVJMLiAqL1xuICAgX3Nob3VsZEluamVjdFRyYWNlRGF0YSh0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cywgdXJsKSB7XG4gICAgaWYgKHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlZERlY2lzaW9uID0gdGhpcy5fdXJsTWF0Y2hlc1RhcmdldHNNYXAuZ2V0KHVybCk7XG4gICAgaWYgKGNhY2hlZERlY2lzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWREZWNpc2lvbjtcbiAgICB9XG5cbiAgICBjb25zdCBkZWNpc2lvbiA9IHV0aWxzLnN0cmluZ01hdGNoZXNTb21lUGF0dGVybih1cmwsIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzKTtcbiAgICB0aGlzLl91cmxNYXRjaGVzVGFyZ2V0c01hcC5zZXQodXJsLCBkZWNpc2lvbik7XG4gICAgcmV0dXJuIGRlY2lzaW9uO1xuICB9XG59XG5cbi8qKiBFeHBvcnRlZCBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBtYWtlVHJhY2VTdGF0ZSh7XG4gIHBhcmVudFNwYW5JZCxcbiAgZHNjLFxuICBzYW1wbGVkLFxufVxuXG4pIHtcbiAgLy8gV2Ugc3RvcmUgdGhlIERTQyBhcyBPVEVMIHRyYWNlIHN0YXRlIG9uIHRoZSBzcGFuIGNvbnRleHRcbiAgY29uc3QgZHNjU3RyaW5nID0gZHNjID8gdXRpbHMuZHluYW1pY1NhbXBsaW5nQ29udGV4dFRvU2VudHJ5QmFnZ2FnZUhlYWRlcihkc2MpIDogdW5kZWZpbmVkO1xuXG4gIC8vIFdlIF9hbHdheXNfIHNldCB0aGUgcGFyZW50IHNwYW4gSUQsIGV2ZW4gaWYgaXQgaXMgZW1wdHlcbiAgLy8gSWYgd2UnZCBzZXQgdGhpcyB0byAndW5kZWZpbmVkJyB3ZSBjb3VsZCBub3Qga25vdyBpZiB0aGUgdHJhY2Ugc3RhdGUgd2FzIHNldCwgYnV0IHRoZXJlIHdhcyBubyBwYXJlbnRTcGFuSWQsXG4gIC8vIHZzIHRoZSB0cmFjZSBzdGF0ZSB3YXMgbm90IHNldCBhdCBhbGwgKGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBkbyBmYWxsYmFjayBoYW5kbGluZylcbiAgLy8gSWYgYCcnYCwgaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgXCJubyBwYXJlbnRcIlxuICBjb25zdCB0cmFjZVN0YXRlQmFzZSA9IG5ldyBjb3JlJDEuVHJhY2VTdGF0ZSgpLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfUEFSRU5UX1NQQU5fSUQsIHBhcmVudFNwYW5JZCB8fCAnJyk7XG5cbiAgY29uc3QgdHJhY2VTdGF0ZVdpdGhEc2MgPSBkc2NTdHJpbmcgPyB0cmFjZVN0YXRlQmFzZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX0RTQywgZHNjU3RyaW5nKSA6IHRyYWNlU3RhdGVCYXNlO1xuXG4gIC8vIFdlIGFsc28gc3BlY2lmaWNhbGx5IHdhbnQgdG8gc3RvcmUgaWYgdGhpcyBpcyBzYW1wbGVkIHRvIGJlIG5vdCByZWNvcmRpbmcsXG4gIC8vIG9yIHVuc2FtcGxlZCAoPWNvdWxkIGJlIGVpdGhlciBzYW1wbGVkIG9yIG5vdClcbiAgcmV0dXJuIHNhbXBsZWQgPT09IGZhbHNlID8gdHJhY2VTdGF0ZVdpdGhEc2Muc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcsICcxJykgOiB0cmFjZVN0YXRlV2l0aERzYztcbn1cblxuZnVuY3Rpb24gZ2V0SW5qZWN0aW9uRGF0YShjb250ZXh0KVxuXG4ge1xuICBjb25zdCBzcGFuID0gY29yZS5oYXNUcmFjaW5nRW5hYmxlZCgpID8gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHNwYW5Jc1JlbW90ZSA9IF9vcHRpb25hbENoYWluJDYoW3NwYW4sICdvcHRpb25hbEFjY2VzcycsIF81ID0+IF81LnNwYW5Db250ZXh0LCAnY2FsbCcsIF82ID0+IF82KCksICdhY2Nlc3MnLCBfNyA9PiBfNy5pc1JlbW90ZV0pO1xuXG4gIC8vIElmIHdlIGhhdmUgYSBsb2NhbCBzcGFuLCB3ZSBjYW4ganVzdCBwaWNrIGV2ZXJ5dGhpbmcgZnJvbSBpdFxuICBpZiAoc3BhbiAmJiAhc3BhbklzUmVtb3RlKSB7XG4gICAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgICBjb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSBnZXRQcm9wYWdhdGlvbkNvbnRleHRGcm9tU3BhbihzcGFuKTtcbiAgICBjb25zdCBkeW5hbWljU2FtcGxpbmdDb250ZXh0ID0gZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dChwcm9wYWdhdGlvbkNvbnRleHQsIHNwYW5Db250ZXh0LnRyYWNlSWQpO1xuICAgIHJldHVybiB7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0LFxuICAgICAgdHJhY2VJZDogc3BhbkNvbnRleHQudHJhY2VJZCxcbiAgICAgIHNwYW5JZDogc3BhbkNvbnRleHQuc3BhbklkLFxuICAgICAgc2FtcGxlZDogZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCksXG4gICAgfTtcbiAgfVxuXG4gIC8vIEVsc2Ugd2UgdHJ5IHRvIHVzZSB0aGUgcHJvcGFnYXRpb24gY29udGV4dCBmcm9tIHRoZSBzY29wZVxuICBjb25zdCBzY29wZSA9IF9vcHRpb25hbENoYWluJDYoW2dldFNjb3Blc0Zyb21Db250ZXh0LCAnY2FsbCcsIF84ID0+IF84KGNvbnRleHQpLCAnb3B0aW9uYWxBY2Nlc3MnLCBfOSA9PiBfOS5zY29wZV0pIHx8IGNvcmUuZ2V0Q3VycmVudFNjb3BlKCk7XG5cbiAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gc2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0KHByb3BhZ2F0aW9uQ29udGV4dCwgcHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQpO1xuICByZXR1cm4ge1xuICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgdHJhY2VJZDogcHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQsXG4gICAgc3BhbklkOiBwcm9wYWdhdGlvbkNvbnRleHQuc3BhbklkLFxuICAgIHNhbXBsZWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5zYW1wbGVkLFxuICB9O1xufVxuXG4vKiogR2V0IHRoZSBEU0MgZnJvbSBhIGNvbnRleHQsIG9yIGZhbGwgYmFjayB0byB1c2UgdGhlIG9uZSBmcm9tIHRoZSBjbGllbnQuICovXG5mdW5jdGlvbiBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0KFxuICBwcm9wYWdhdGlvbkNvbnRleHQsXG4gIHRyYWNlSWQsXG4pIHtcbiAgLy8gSWYgd2UgaGF2ZSBhIERTQyBvbiB0aGUgcHJvcGFnYXRpb24gY29udGV4dCwgd2UganVzdCB1c2UgaXRcbiAgaWYgKF9vcHRpb25hbENoYWluJDYoW3Byb3BhZ2F0aW9uQ29udGV4dCwgJ29wdGlvbmFsQWNjZXNzJywgXzEwID0+IF8xMC5kc2NdKSkge1xuICAgIHJldHVybiBwcm9wYWdhdGlvbkNvbnRleHQuZHNjO1xuICB9XG5cbiAgLy8gRWxzZSwgd2UgdHJ5IHRvIGdlbmVyYXRlIGEgbmV3IG9uZVxuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuXG4gIGlmIChjbGllbnQpIHtcbiAgICByZXR1cm4gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbUNsaWVudCh0cmFjZUlkIHx8IHByb3BhZ2F0aW9uQ29udGV4dC50cmFjZUlkLCBjbGllbnQpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dFdpdGhSZW1vdGVBY3RpdmVTcGFuKFxuICBjdHgsXG4gIHsgc2VudHJ5VHJhY2UsIGJhZ2dhZ2UgfSxcbikge1xuICBjb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSB1dGlscy5wcm9wYWdhdGlvbkNvbnRleHRGcm9tSGVhZGVycyhzZW50cnlUcmFjZSwgYmFnZ2FnZSk7XG5cbiAgLy8gV2Ugc3RvcmUgdGhlIERTQyBhcyBPVEVMIHRyYWNlIHN0YXRlIG9uIHRoZSBzcGFuIGNvbnRleHRcbiAgY29uc3QgdHJhY2VTdGF0ZSA9IG1ha2VUcmFjZVN0YXRlKHtcbiAgICBwYXJlbnRTcGFuSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5wYXJlbnRTcGFuSWQsXG4gICAgZHNjOiBwcm9wYWdhdGlvbkNvbnRleHQuZHNjLFxuICAgIHNhbXBsZWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5zYW1wbGVkLFxuICB9KTtcblxuICBjb25zdCBzcGFuQ29udGV4dCA9IHtcbiAgICB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCxcbiAgICBzcGFuSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5wYXJlbnRTcGFuSWQgfHwgJycsXG4gICAgaXNSZW1vdGU6IHRydWUsXG4gICAgdHJhY2VGbGFnczogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQgPyBhcGkuVHJhY2VGbGFncy5TQU1QTEVEIDogYXBpLlRyYWNlRmxhZ3MuTk9ORSxcbiAgICB0cmFjZVN0YXRlLFxuICB9O1xuXG4gIHJldHVybiBhcGkudHJhY2Uuc2V0U3BhbkNvbnRleHQoY3R4LCBzcGFuQ29udGV4dCk7XG59XG5cbi8qKlxuICogVGFrZXMgdHJhY2Ugc3RyaW5ncyBhbmQgcHJvcGFnYXRlcyB0aGVtIGFzIGEgcmVtb3RlIGFjdGl2ZSBzcGFuLlxuICogVGhpcyBzaG91bGQgYmUgdXNlZCBpbiBhZGRpdGlvbiB0byBgY29udGludWVUcmFjZWAgaW4gT1RFTC1wb3dlcmVkIGVudmlyb25tZW50cy5cbiAqL1xuZnVuY3Rpb24gY29udGludWVUcmFjZUFzUmVtb3RlU3BhbihcbiAgY3R4LFxuICBvcHRpb25zLFxuICBjYWxsYmFjayxcbikge1xuICBjb25zdCBjdHhXaXRoU3BhbkNvbnRleHQgPSBnZXRDb250ZXh0V2l0aFJlbW90ZUFjdGl2ZVNwYW4oY3R4LCBvcHRpb25zKTtcblxuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHhXaXRoU3BhbkNvbnRleHQsIGNhbGxiYWNrKTtcbn1cblxuLyoqIFRyeSB0byBnZXQgdGhlIGV4aXN0aW5nIGJhZ2dhZ2UgaGVhZGVyIHNvIHdlIGNhbiBtZXJnZSB0aGlzIGluLiAqL1xuZnVuY3Rpb24gZ2V0RXhpc3RpbmdCYWdnYWdlKGNhcnJpZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBiYWdnYWdlID0gKGNhcnJpZXIgKVtTRU5UUllfQkFHR0FHRV9IRUFERVJdO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGJhZ2dhZ2UpID8gYmFnZ2FnZS5qb2luKCcsJykgOiBiYWdnYWdlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIEl0IGlzIHByZXR0eSB0cmlja3kgdG8gZ2V0IGFjY2VzcyB0byB0aGUgb3V0Z29pbmcgcmVxdWVzdCBVUkwgb2YgYSByZXF1ZXN0IGluIHRoZSBwcm9wYWdhdG9yLlxuICogQXMgd2Ugb25seSBoYXZlIGFjY2VzcyB0byB0aGUgY29udGV4dCBvZiB0aGUgc3BhbiB0byBiZSBzZW50IGFuZCB0aGUgY2FycmllciAoPWhlYWRlcnMpLFxuICogYnV0IHRoZSBzcGFuIG1heSBiZSB1bnNhbXBsZWQgYW5kIHRodXMgaGF2ZSBubyBhdHRyaWJ1dGVzLlxuICpcbiAqIFNvIHdlIHVzZSB0aGUgZm9sbG93aW5nIGxvZ2ljOlxuICogMS4gSWYgd2UgaGF2ZSBhbiBhY3RpdmUgc3Bhbiwgd2UgY2hlY2sgaWYgaXQgaGFzIGEgVVJMIGF0dHJpYnV0ZS5cbiAqIDIuIEVsc2UsIGlmIHRoZSBhY3RpdmUgc3BhbiBoYXMgbm8gVVJMIGF0dHJpYnV0ZSAoZS5nLiBpdCBpcyB1bnNhbXBsZWQpLCB3ZSBjaGVjayBhIHNwZWNpYWwgdHJhY2Ugc3RhdGUgKHdoaWNoIHdlIHNldCBpbiBvdXIgc2FtcGxlcikuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnJlbnRVUkwoc3Bhbikge1xuICBjb25zdCB1cmxBdHRyaWJ1dGUgPSBfb3B0aW9uYWxDaGFpbiQ2KFtjb3JlLnNwYW5Ub0pTT04sICdjYWxsJywgXzExID0+IF8xMShzcGFuKSwgJ2FjY2VzcycsIF8xMiA9PiBfMTIuZGF0YSwgJ29wdGlvbmFsQWNjZXNzJywgXzEzID0+IF8xM1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXV0pO1xuICBpZiAodXJsQXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIHVybEF0dHJpYnV0ZTtcbiAgfVxuXG4gIC8vIEFsc28gbG9vayBhdCB0aGUgdHJhY2VTdGF0ZSwgd2hpY2ggd2UgbWF5IHNldCBpbiB0aGUgc2FtcGxlciBldmVuIGZvciB1bnNhbXBsZWQgc3BhbnNcbiAgY29uc3QgdXJsVHJhY2VTdGF0ZSA9IF9vcHRpb25hbENoYWluJDYoW3NwYW4sICdhY2Nlc3MnLCBfMTQgPT4gXzE0LnNwYW5Db250ZXh0LCAnY2FsbCcsIF8xNSA9PiBfMTUoKSwgJ2FjY2VzcycsIF8xNiA9PiBfMTYudHJhY2VTdGF0ZSwgJ29wdGlvbmFsQWNjZXNzJywgXzE3ID0+IF8xNy5nZXQsICdjYWxsJywgXzE4ID0+IF8xOChTRU5UUllfVFJBQ0VfU1RBVEVfVVJMKV0pO1xuICBpZiAodXJsVHJhY2VTdGF0ZSkge1xuICAgIHJldHVybiB1cmxUcmFjZVN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kNShvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHRyYW5zYWN0aW9uL3NwYW4gYW5kIGZpbmlzaGVzIHRoZSBzcGFuIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBkb25lLlxuICogVGhlIGNyZWF0ZWQgc3BhbiBpcyB0aGUgYWN0aXZlIHNwYW4gYW5kIHdpbGwgYmUgdXNlZCBhcyBwYXJlbnQgYnkgb3RoZXIgc3BhbnMgY3JlYXRlZCBpbnNpZGUgdGhlIGZ1bmN0aW9uXG4gKiBhbmQgY2FuIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAsIGFzIGxvbmcgYXMgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdoaWxlIHRoZSBzY29wZSBpcyBhY3RpdmUuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgc3BhbiB0aGF0IGlzIG5vdCBzZXQgYXMgYWN0aXZlLCB1c2Uge0BsaW5rIHN0YXJ0SW5hY3RpdmVTcGFufS5cbiAqXG4gKiBZb3UnbGwgYWx3YXlzIGdldCBhIHNwYW4gcGFzc2VkIHRvIHRoZSBjYWxsYmFjayxcbiAqIGl0IG1heSBqdXN0IGJlIGEgbm9uLXJlY29yZGluZyBzcGFuIGlmIHRoZSBzcGFuIGlzIG5vdCBzYW1wbGVkIG9yIGlmIHRyYWNpbmcgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0U3BhbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCwgc3BhbiA9PiB7XG4gICAgICBfYXBwbHlTZW50cnlBdHRyaWJ1dGVzVG9TcGFuKHNwYW4sIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gY29yZS5oYW5kbGVDYWxsYmFja0Vycm9ycyhcbiAgICAgICAgKCkgPT4gY2FsbGJhY2soc3BhbiksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgc3BhbiBzdGF0dXMgdG8gRVJST1Igd2hlbiB0aGVyZSB3YXNuJ3QgYW55IHN0YXR1cyBzZXQgYmVmb3JlLCBpbiBvcmRlciB0byBhdm9pZCBzdG9tcGluZyB1c2VmdWwgc3BhbiBzdGF0dXNlc1xuICAgICAgICAgIGlmIChjb3JlLnNwYW5Ub0pTT04oc3Bhbikuc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gc3Bhbi5lbmQoKSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYFNlbnRyeS5zdGFydFNwYW5gLiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSBzcGFuLCBidXQgZG9lcyBub3QgZmluaXNoIHRoZSBzcGFuXG4gKiBhZnRlciB0aGUgZnVuY3Rpb24gaXMgZG9uZSBhdXRvbWF0aWNhbGx5LiBZb3UnbGwgaGF2ZSB0byBjYWxsIGBzcGFuLmVuZCgpYCBtYW51YWxseS5cbiAqXG4gKiBUaGUgY3JlYXRlZCBzcGFuIGlzIHRoZSBhY3RpdmUgc3BhbiBhbmQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBieSBvdGhlciBzcGFucyBjcmVhdGVkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIGFuZCBjYW4gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYCwgYXMgbG9uZyBhcyB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hpbGUgdGhlIHNjb3BlIGlzIGFjdGl2ZS5cbiAqXG4gKiBZb3UnbGwgYWx3YXlzIGdldCBhIHNwYW4gcGFzc2VkIHRvIHRoZSBjYWxsYmFjayxcbiAqIGl0IG1heSBqdXN0IGJlIGEgbm9uLXJlY29yZGluZyBzcGFuIGlmIHRoZSBzcGFuIGlzIG5vdCBzYW1wbGVkIG9yIGlmIHRyYWNpbmcgaXMgZGlzYWJsZWQuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0U3Bhbk1hbnVhbChcbiAgb3B0aW9ucyxcbiAgY2FsbGJhY2ssXG4pIHtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKCk7XG5cbiAgY29uc3QgeyBuYW1lLCBwYXJlbnRTcGFuOiBjdXN0b21QYXJlbnRTcGFuIH0gPSBvcHRpb25zO1xuXG4gIC8vIElmIGBvcHRpb25zLnBhcmVudFNwYW5gIGlzIGRlZmluZWQsIHdlIHdhbnQgdG8gd3JhcCB0aGUgY2FsbGJhY2sgaW4gYHdpdGhBY3RpdmVTcGFuYFxuICBjb25zdCB3cmFwcGVyID0gZ2V0QWN0aXZlU3BhbldyYXBwZXIoY3VzdG9tUGFyZW50U3Bhbik7XG5cbiAgcmV0dXJuIHdyYXBwZXIoKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUN0eCA9IGdldENvbnRleHQob3B0aW9ucy5zY29wZSwgb3B0aW9ucy5mb3JjZVRyYW5zYWN0aW9uKTtcbiAgICBjb25zdCBzaG91bGRTa2lwU3BhbiA9IG9wdGlvbnMub25seUlmUGFyZW50ICYmICFhcGkudHJhY2UuZ2V0U3BhbihhY3RpdmVDdHgpO1xuICAgIGNvbnN0IGN0eCA9IHNob3VsZFNraXBTcGFuID8gY29yZSQxLnN1cHByZXNzVHJhY2luZyhhY3RpdmVDdHgpIDogYWN0aXZlQ3R4O1xuXG4gICAgY29uc3Qgc3Bhbk9wdGlvbnMgPSBnZXRTcGFuT3B0aW9ucyhvcHRpb25zKTtcblxuICAgIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKG5hbWUsIHNwYW5PcHRpb25zLCBjdHgsIHNwYW4gPT4ge1xuICAgICAgX2FwcGx5U2VudHJ5QXR0cmlidXRlc1RvU3BhbihzcGFuLCBvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIGNvcmUuaGFuZGxlQ2FsbGJhY2tFcnJvcnMoXG4gICAgICAgICgpID0+IGNhbGxiYWNrKHNwYW4sICgpID0+IHNwYW4uZW5kKCkpLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgLy8gT25seSBzZXQgdGhlIHNwYW4gc3RhdHVzIHRvIEVSUk9SIHdoZW4gdGhlcmUgd2Fzbid0IGFueSBzdGF0dXMgc2V0IGJlZm9yZSwgaW4gb3JkZXIgdG8gYXZvaWQgc3RvbXBpbmcgdXNlZnVsIHNwYW4gc3RhdHVzZXNcbiAgICAgICAgICBpZiAoY29yZS5zcGFuVG9KU09OKHNwYW4pLnN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7IGNvZGU6IGFwaS5TcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3Bhbi4gVGhpcyBzcGFuIGlzIG5vdCBzZXQgYXMgYWN0aXZlLCBzbyB3aWxsIG5vdCBnZXQgYXV0b21hdGljIGluc3RydW1lbnRhdGlvbiBzcGFuc1xuICogYXMgY2hpbGRyZW4gb3IgYmUgYWJsZSB0byBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIGNyZWF0ZSBhIHNwYW4gdGhhdCBpcyBzZXQgYXMgYWN0aXZlLCB1c2Uge0BsaW5rIHN0YXJ0U3Bhbn0uXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGFsd2F5cyByZXR1cm4gYSBzcGFuLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRJbmFjdGl2ZVNwYW4ob3B0aW9ucykge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgY29uc3Qgc3BhbiA9IHRyYWNlci5zdGFydFNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCk7XG5cbiAgICBfYXBwbHlTZW50cnlBdHRyaWJ1dGVzVG9TcGFuKHNwYW4sIG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNwYW47XG4gIH0pO1xufVxuXG4vKipcbiAqIEZvcmtzIHRoZSBjdXJyZW50IHNjb3BlIGFuZCBzZXRzIHRoZSBwcm92aWRlZCBzcGFuIGFzIGFjdGl2ZSBzcGFuIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm92aWRlZCBjYWxsYmFjay4gQ2FuIGJlXG4gKiBwYXNzZWQgYG51bGxgIHRvIHN0YXJ0IGFuIGVudGlyZWx5IG5ldyBzcGFuIHRyZWUuXG4gKlxuICogQHBhcmFtIHNwYW4gU3BhbnMgc3RhcnRlZCBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgd2lsbCBiZSBjaGlsZHJlbiBvZiB0aGlzIHNwYW4uIElmIGBudWxsYCBpcyBwYXNzZWQsXG4gKiBzcGFucyBzdGFydGVkIHdpdGhpbiB0aGUgY2FsbGJhY2sgd2lsbCBiZSByb290IHNwYW5zLlxuICogQHBhcmFtIGNhbGxiYWNrIEV4ZWN1dGlvbiBjb250ZXh0IGluIHdoaWNoIHRoZSBwcm92aWRlZCBzcGFuIHdpbGwgYmUgYWN0aXZlLiBJcyBwYXNzZWQgdGhlIG5ld2x5IGZvcmtlZCBzY29wZS5cbiAqIEByZXR1cm5zIHRoZSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gd2l0aEFjdGl2ZVNwYW4oc3BhbiwgY2FsbGJhY2spIHtcbiAgY29uc3QgbmV3Q29udGV4dFdpdGhBY3RpdmVTcGFuID0gc3BhbiA/IGFwaS50cmFjZS5zZXRTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKSA6IGFwaS50cmFjZS5kZWxldGVTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgobmV3Q29udGV4dFdpdGhBY3RpdmVTcGFuLCAoKSA9PiBjYWxsYmFjayhjb3JlLmdldEN1cnJlbnRTY29wZSgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNlcigpIHtcbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgcmV0dXJuIChjbGllbnQgJiYgY2xpZW50LnRyYWNlcikgfHwgYXBpLnRyYWNlLmdldFRyYWNlcignQHNlbnRyeS9vcGVudGVsZW1ldHJ5JywgY29yZS5TREtfVkVSU0lPTik7XG59XG5cbmZ1bmN0aW9uIF9hcHBseVNlbnRyeUF0dHJpYnV0ZXNUb1NwYW4oc3Bhbiwgb3B0aW9ucykge1xuICBjb25zdCB7IG9wIH0gPSBvcHRpb25zO1xuXG4gIGlmIChvcCkge1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUCwgb3ApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5PcHRpb25zKG9wdGlvbnMpIHtcbiAgY29uc3QgeyBzdGFydFRpbWUsIGF0dHJpYnV0ZXMsIGtpbmQgfSA9IG9wdGlvbnM7XG5cbiAgLy8gT1RFTCBleHBlY3RzIHRpbWVzdGFtcHMgaW4gbXMsIG5vdCBzZWNvbmRzXG4gIGNvbnN0IGZpeGVkU3RhcnRUaW1lID0gdHlwZW9mIHN0YXJ0VGltZSA9PT0gJ251bWJlcicgPyBlbnN1cmVUaW1lc3RhbXBJbk1pbGxpc2Vjb25kcyhzdGFydFRpbWUpIDogc3RhcnRUaW1lO1xuXG4gIHJldHVybiB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBraW5kLFxuICAgIHN0YXJ0VGltZTogZml4ZWRTdGFydFRpbWUsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVRpbWVzdGFtcEluTWlsbGlzZWNvbmRzKHRpbWVzdGFtcCkge1xuICBjb25zdCBpc01zID0gdGltZXN0YW1wIDwgOTk5OTk5OTk5OTtcbiAgcmV0dXJuIGlzTXMgPyB0aW1lc3RhbXAgKiAxMDAwIDogdGltZXN0YW1wO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KHNjb3BlLCBmb3JjZVRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IGN0eCA9IGdldENvbnRleHRGb3JTY29wZShzY29wZSk7XG4gIGNvbnN0IGFjdHVhbFNjb3BlID0gX29wdGlvbmFsQ2hhaW4kNShbZ2V0U2NvcGVzRnJvbUNvbnRleHQsICdjYWxsJywgXyA9PiBfKGN0eCksICdvcHRpb25hbEFjY2VzcycsIF8yID0+IF8yLnNjb3BlXSk7XG5cbiAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGN0eCk7XG5cbiAgLy8gSW4gdGhlIGNhc2UgdGhhdCB3ZSBoYXZlIG5vIHBhcmVudCBzcGFuLCB3ZSBuZWVkIHRvIFwic2ltdWxhdGVcIiBvbmUgdG8gZW5zdXJlIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0IGlzIGNvcnJlY3RcbiAgaWYgKCFwYXJlbnRTcGFuKSB7XG4gICAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcblxuICAgIGlmIChhY3R1YWxTY29wZSAmJiBjbGllbnQpIHtcbiAgICAgIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IGFjdHVhbFNjb3BlLmdldFByb3BhZ2F0aW9uQ29udGV4dCgpO1xuXG4gICAgICAvLyBXZSBzdG9yZSB0aGUgRFNDIGFzIE9URUwgdHJhY2Ugc3RhdGUgb24gdGhlIHNwYW4gY29udGV4dFxuICAgICAgY29uc3QgdHJhY2VTdGF0ZSA9IG1ha2VUcmFjZVN0YXRlKHtcbiAgICAgICAgcGFyZW50U3BhbklkOiBwcm9wYWdhdGlvbkNvbnRleHQucGFyZW50U3BhbklkLFxuICAgICAgICAvLyBOb3QgZGVmaW5lZCB5ZXQsIHdlIHdhbnQgdG8gcGljayB0aGlzIHVwIG9uLWRlbWFuZCBvbmx5XG4gICAgICAgIGRzYzogdW5kZWZpbmVkLFxuICAgICAgICBzYW1wbGVkOiBwcm9wYWdhdGlvbkNvbnRleHQuc2FtcGxlZCxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICAgICAgdHJhY2VJZDogcHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQsXG4gICAgICAgIHNwYW5JZDogcHJvcGFnYXRpb25Db250ZXh0LnBhcmVudFNwYW5JZCB8fCBwcm9wYWdhdGlvbkNvbnRleHQuc3BhbklkLFxuICAgICAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICAgICAgdHJhY2VGbGFnczogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQgPyBhcGkuVHJhY2VGbGFncy5TQU1QTEVEIDogYXBpLlRyYWNlRmxhZ3MuTk9ORSxcbiAgICAgICAgdHJhY2VTdGF0ZSxcbiAgICAgIH07XG5cbiAgICAgIC8vIEFkZCByZW1vdGUgcGFyZW50IHNwYW4gY29udGV4dCxcbiAgICAgIHJldHVybiBhcGkudHJhY2Uuc2V0U3BhbkNvbnRleHQoY3R4LCBzcGFuT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBubyBzY29wZSBvciBjbGllbnQsIHdlIGp1c3QgcmV0dXJuIHRoZSBjb250ZXh0IGFzLWlzXG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuXG4gIC8vIElmIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgYSB0cmFuc2FjdGlvbiwgYW5kIHdlIGhhdmUgYSBwYXJlbnQgc3BhbiwgYWxsIGdvb2QsIHdlIGp1c3QgcmV0dXJuIGFzLWlzIVxuICBpZiAoIWZvcmNlVHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLy8gRWxzZSwgaWYgd2UgZG8gaGF2ZSBhIHBhcmVudCBzcGFuIGJ1dCB3YW50IHRvIGZvcmNlIGEgdHJhbnNhY3Rpb24sIHdlIGhhdmUgdG8gc2ltdWxhdGUgYSBcInJvb3RcIiBjb250ZXh0XG5cbiAgLy8gRWxzZSwgd2UgbmVlZCB0byBkbyB0d28gdGhpbmdzOlxuICAvLyAxLiBVbnNldCB0aGUgcGFyZW50IHNwYW4gZnJvbSB0aGUgY29udGV4dCwgc28gd2UnbGwgY3JlYXRlIGEgbmV3IHJvb3Qgc3BhblxuICAvLyAyLiBFbnN1cmUgdGhlIHByb3BhZ2F0aW9uIGNvbnRleHQgaXMgY29ycmVjdCwgc28gd2UnbGwgY29udGludWUgZnJvbSB0aGUgcGFyZW50IHNwYW5cbiAgY29uc3QgY3R4V2l0aG91dFNwYW4gPSBhcGkudHJhY2UuZGVsZXRlU3BhbihjdHgpO1xuXG4gIGNvbnN0IHsgc3BhbklkLCB0cmFjZUlkIH0gPSBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG4gIGNvbnN0IHNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKSk7XG5cbiAgLy8gSW4gdGhpcyBjYXNlLCB3aGVuIHdlIGFyZSBmb3JjaW5nIGEgdHJhbnNhY3Rpb24sIHdlIHdhbnQgdG8gdHJlYXQgdGhpcyBsaWtlIGNvbnRpbnVpbmcgYW4gaW5jb21pbmcgdHJhY2VcbiAgLy8gc28gd2Ugc2V0IHRoZSB0cmFjZVN0YXRlIGFjY29yZGluZyB0byB0aGUgcm9vdCBzcGFuXG4gIGNvbnN0IHJvb3RTcGFuID0gY29yZS5nZXRSb290U3BhbihwYXJlbnRTcGFuKTtcbiAgY29uc3QgZHNjID0gY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4ocm9vdFNwYW4pO1xuXG4gIGNvbnN0IHRyYWNlU3RhdGUgPSBtYWtlVHJhY2VTdGF0ZSh7XG4gICAgZHNjLFxuICAgIHBhcmVudFNwYW5JZDogc3BhbklkICE9PSBhcGkuSU5WQUxJRF9TUEFOSUQgPyBzcGFuSWQgOiB1bmRlZmluZWQsXG4gICAgc2FtcGxlZCxcbiAgfSk7XG5cbiAgY29uc3Qgc3Bhbk9wdGlvbnMgPSB7XG4gICAgdHJhY2VJZCxcbiAgICBzcGFuSWQsXG4gICAgaXNSZW1vdGU6IHRydWUsXG4gICAgdHJhY2VGbGFnczogc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgIHRyYWNlU3RhdGUsXG4gIH07XG5cbiAgY29uc3QgY3R4V2l0aFNwYW5Db250ZXh0ID0gYXBpLnRyYWNlLnNldFNwYW5Db250ZXh0KGN0eFdpdGhvdXRTcGFuLCBzcGFuT3B0aW9ucyk7XG5cbiAgcmV0dXJuIGN0eFdpdGhTcGFuQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gIGlmIChzY29wZSkge1xuICAgIGNvbnN0IGN0eCA9IGdldENvbnRleHRGcm9tU2NvcGUoc2NvcGUpO1xuICAgIGlmIChjdHgpIHtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xufVxuXG4vKipcbiAqIENvbnRpbnVlIGEgdHJhY2UgZnJvbSBgc2VudHJ5LXRyYWNlYCBhbmQgYGJhZ2dhZ2VgIHZhbHVlcy5cbiAqIFRoZXNlIHZhbHVlcyBjYW4gYmUgb2J0YWluZWQgZnJvbSBpbmNvbWluZyByZXF1ZXN0IGhlYWRlcnMsIG9yIGluIHRoZSBicm93c2VyIGZyb20gYDxtZXRhIG5hbWU9XCJzZW50cnktdHJhY2VcIj5gXG4gKiBhbmQgYDxtZXRhIG5hbWU9XCJiYWdnYWdlXCI+YCBIVE1MIHRhZ3MuXG4gKlxuICogU3BhbnMgc3RhcnRlZCB3aXRoIGBzdGFydFNwYW5gLCBgc3RhcnRTcGFuTWFudWFsYCBhbmQgYHN0YXJ0SW5hY3RpdmVTcGFuYCwgd2l0aGluIHRoZSBjYWxsYmFjayB3aWxsIGF1dG9tYXRpY2FsbHlcbiAqIGJlIGF0dGFjaGVkIHRvIHRoZSBpbmNvbWluZyB0cmFjZS5cbiAqXG4gKiBUaGlzIGlzIGEgY3VzdG9tIHZlcnNpb24gb2YgYGNvbnRpbnVlVHJhY2VgIHRoYXQgaXMgdXNlZCBpbiBPVEVMLXBvd2VyZWQgZW52aXJvbm1lbnRzLlxuICogSXQgcHJvcGFnYXRlcyB0aGUgdHJhY2UgYXMgYSByZW1vdGUgc3BhbiwgaW4gYWRkaXRpb24gdG8gc2V0dGluZyBpdCBvbiB0aGUgcHJvcGFnYXRpb24gY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gY29udGludWVUcmFjZShvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gY29yZS5jb250aW51ZVRyYWNlKG9wdGlvbnMsICgpID0+IHtcbiAgICByZXR1cm4gY29udGludWVUcmFjZUFzUmVtb3RlU3BhbihhcGkuY29udGV4dC5hY3RpdmUoKSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlU3BhbldyYXBwZXIocGFyZW50U3Bhbikge1xuICByZXR1cm4gcGFyZW50U3BhblxuICAgID8gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIC8vIFdlIGNhc3QgdGhpcywgYmVjYXVzZSB0aGUgT1RFTCBTcGFuIGhhcyBhIGZldyBtb3JlIG1ldGhvZHMgdGhhbiBvdXIgU3BhbiBpbnRlcmZhY2VcbiAgICAgICAgLy8gVE9ETzogQWRkIHRoZXNlIG1pc3NpbmcgbWV0aG9kcyB0byB0aGUgU3BhbiBpbnRlcmZhY2VcbiAgICAgICAgcmV0dXJuIHdpdGhBY3RpdmVTcGFuKHBhcmVudFNwYW4gLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgOiAoY2FsbGJhY2spID0+IGNhbGxiYWNrKCk7XG59XG5cbi8qKiBTdXBwcmVzcyB0cmFjaW5nIGluIHRoZSBnaXZlbiBjYWxsYmFjaywgZW5zdXJpbmcgbm8gc3BhbnMgYXJlIGdlbmVyYXRlZCBpbnNpZGUgb2YgaXQuICovXG5mdW5jdGlvbiBzdXBwcmVzc1RyYWNpbmcoY2FsbGJhY2spIHtcbiAgY29uc3QgY3R4ID0gY29yZSQxLnN1cHByZXNzVHJhY2luZyhhcGkuY29udGV4dC5hY3RpdmUoKSk7XG4gIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eCwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBfb3B0aW9uYWxDaGFpbiQ0KG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9XG4vKiogRW5zdXJlIHRoZSBgdHJhY2VgIGNvbnRleHQgaXMgc2V0IG9uIGFsbCBldmVudHMuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50Q29udGV4dFRyYWNlKGNsaWVudCkge1xuICBjbGllbnQub24oJ3ByZXByb2Nlc3NFdmVudCcsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzcGFuID0gZ2V0QWN0aXZlU3BhbigpO1xuICAgIC8vIEZvciB0cmFuc2FjdGlvbiBldmVudHMsIHRoaXMgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5XG4gICAgLy8gQmVjYXVzZSB0aGUgYWN0aXZlIHNwYW4gbWF5IG5vdCBiZSB0aGUgc3BhbiB0aGF0IGlzIGFjdHVhbGx5IHRoZSB0cmFuc2FjdGlvbiBldmVudFxuICAgIGlmICghc3BhbiB8fCBldmVudC50eXBlID09PSAndHJhbnNhY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgcGFyZW50IHNwYW4gaWQgZnJvbSB0cmFjZSBzdGF0ZSwgdXNlIHRoYXQgKCcnIG1lYW5zIG5vIHBhcmVudCBzaG91bGQgYmUgdXNlZClcbiAgICAvLyBFbHNlLCBwaWNrIHRoZSBvbmUgZnJvbSB0aGUgc3BhblxuICAgIGNvbnN0IHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlID0gX29wdGlvbmFsQ2hhaW4kNChbc3BhbkNvbnRleHQsICdhY2Nlc3MnLCBfID0+IF8udHJhY2VTdGF0ZSwgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuZ2V0LCAnY2FsbCcsIF8zID0+IF8zKFNFTlRSWV9UUkFDRV9TVEFURV9QQVJFTlRfU1BBTl9JRCldKTtcbiAgICBjb25zdCBwYXJlbnRfc3Bhbl9pZCA9XG4gICAgICB0eXBlb2YgcGFyZW50U3BhbklkRnJvbVRyYWNlU3RhdGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcGFyZW50U3BhbklkRnJvbVRyYWNlU3RhdGUgfHwgdW5kZWZpbmVkXG4gICAgICAgIDogc3Bhbkhhc1BhcmVudElkKHNwYW4pXG4gICAgICAgICAgPyBzcGFuLnBhcmVudFNwYW5JZFxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gSWYgZXZlbnQgaGFzIGFscmVhZHkgc2V0IGB0cmFjZWAgY29udGV4dCwgdXNlIHRoYXQgb25lLlxuICAgIGV2ZW50LmNvbnRleHRzID0ge1xuICAgICAgdHJhY2U6IHV0aWxzLmRyb3BVbmRlZmluZWRLZXlzKHtcbiAgICAgICAgdHJhY2VfaWQ6IHNwYW5Db250ZXh0LnRyYWNlSWQsXG4gICAgICAgIHNwYW5faWQ6IHNwYW5Db250ZXh0LnNwYW5JZCxcbiAgICAgICAgcGFyZW50X3NwYW5faWQsXG4gICAgICB9KSxcbiAgICAgIC4uLmV2ZW50LmNvbnRleHRzLFxuICAgIH07XG5cbiAgICBjb25zdCByb290U3BhbiA9IGNvcmUuZ2V0Um9vdFNwYW4oc3Bhbik7XG5cbiAgICBldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEgPSB7XG4gICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3Bhbihyb290U3BhbiksXG4gICAgICAuLi5ldmVudC5zZGtQcm9jZXNzaW5nTWV0YWRhdGEsXG4gICAgfTtcblxuICAgIHJldHVybiBldmVudDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYXN5bmMgY29udGV4dCBzdHJhdGVneSB0byB1c2UgZm9sbG93IHRoZSBPVEVMIGNvbnRleHQgdW5kZXIgdGhlIGhvb2QuXG4gKiBXZSBoYW5kbGUgZm9ya2luZyBhIGh1YiBpbnNpZGUgb2Ygb3VyIGN1c3RvbSBPVEVMIENvbnRleHQgTWFuYWdlciAoLi9vdGVsQ29udGV4dE1hbmFnZXIudHMpXG4gKi9cbmZ1bmN0aW9uIHNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3koKSB7XG4gIGZ1bmN0aW9uIGdldFNjb3BlcygpIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcbiAgICBjb25zdCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjdHgpO1xuXG4gICAgaWYgKHNjb3Blcykge1xuICAgICAgcmV0dXJuIHNjb3BlcztcbiAgICB9XG5cbiAgICAvLyBmYWxsYmFjayBiZWhhdmlvcjpcbiAgICAvLyBpZiwgZm9yIHdoYXRldmVyIHJlYXNvbiwgd2UgY2FuJ3QgZmluZCBzY29wZXMgb24gdGhlIGNvbnRleHQgaGVyZSwgd2UgaGF2ZSB0byBmaXggdGhpcyBzb21laG93XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiBjb3JlLmdldERlZmF1bHRDdXJyZW50U2NvcGUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBjb3JlLmdldERlZmF1bHRJc29sYXRpb25TY29wZSgpLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoU2NvcGUoY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggdXNlcyB0aGUgcHJlc2VuY2Ugb2YgdGhpcyBrZXkgdG8gZGV0ZXJtaW5lIGlmIGl0IHNob3VsZFxuICAgIC8vIGZvcmsgdGhlIGlzb2xhdGlvbiBzY29wZSwgb3Igbm90XG4gICAgLy8gYXMgYnkgZGVmYXVsdCwgd2UgZG9uJ3Qgd2FudCB0byBmb3JrIHRoaXMsIHVubGVzcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBgd2l0aFNjb3BlYFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eCwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldEN1cnJlbnRTY29wZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTZXRTY29wZShzY29wZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjdHggPSBhcGkuY29udGV4dC5hY3RpdmUoKTtcblxuICAgIC8vIFdlIGRlcGVuZCBvbiB0aGUgb3RlbENvbnRleHRNYW5hZ2VyIHRvIGhhbmRsZSB0aGUgY29udGV4dC9odWJcbiAgICAvLyBXZSBzZXQgdGhlIGBTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVlgIGNvbnRleHQgdmFsdWUsIHdoaWNoIGlzIHBpY2tlZCB1cCBieVxuICAgIC8vIHRoZSBPVEVMIGNvbnRleHQgbWFuYWdlciwgd2hpY2ggcGlja3MgdXAgdGhpcyBzY29wZSBhcyB0aGUgY3VycmVudCBzY29wZVxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVksIHNjb3BlKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHNjb3BlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhJc29sYXRpb25TY29wZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHguc2V0VmFsdWUoU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZLCB0cnVlKSwgKCkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGdldElzb2xhdGlvblNjb3BlKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFNldElzb2xhdGlvblNjb3BlKGlzb2xhdGlvblNjb3BlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChjdHguc2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSwgaXNvbGF0aW9uU2NvcGUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0SXNvbGF0aW9uU2NvcGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlcygpLnNjb3BlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNvbGF0aW9uU2NvcGUoKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlcygpLmlzb2xhdGlvblNjb3BlO1xuICB9XG5cbiAgY29yZS5zZXRBc3luY0NvbnRleHRTdHJhdGVneSh7XG4gICAgd2l0aFNjb3BlLFxuICAgIHdpdGhTZXRTY29wZSxcbiAgICB3aXRoU2V0SXNvbGF0aW9uU2NvcGUsXG4gICAgd2l0aElzb2xhdGlvblNjb3BlLFxuICAgIGdldEN1cnJlbnRTY29wZSxcbiAgICBnZXRJc29sYXRpb25TY29wZSxcbiAgICBzdGFydFNwYW4sXG4gICAgc3RhcnRTcGFuTWFudWFsLFxuICAgIHN0YXJ0SW5hY3RpdmVTcGFuLFxuICAgIGdldEFjdGl2ZVNwYW4sXG4gICAgLy8gVGhlIHR5cGVzIGhlcmUgZG9uJ3QgZnVsbHkgYWxpZ24sIGJlY2F1c2Ugb3VyIG93biBgU3BhbmAgdHlwZSBpcyBuYXJyb3dlclxuICAgIC8vIHRoYW4gdGhlIE9URUwgb25lIC0gYnV0IHRoaXMgaXMgT0sgZm9yIGhlcmUsIGFzIHdlIG5vdyB3ZSdsbCBvbmx5IGhhdmUgT1RFTCBzcGFucyBwYXNzZWQgYXJvdW5kXG4gICAgd2l0aEFjdGl2ZVNwYW46IHdpdGhBY3RpdmVTcGFuICxcbiAgICBzdXBwcmVzc1RyYWNpbmc6IHN1cHByZXNzVHJhY2luZyxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDMob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxuLyoqXG4gKiBXcmFwIGFuIE9wZW5UZWxlbWV0cnkgQ29udGV4dE1hbmFnZXIgaW4gYSB3YXkgdGhhdCBlbnN1cmVzIHRoZSBjb250ZXh0IGlzIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBTZW50cnkgU2NvcGUuXG4gKlxuICogVXNhZ2U6XG4gKiBpbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyIH0gZnJvbSAnQG9wZW50ZWxlbWV0cnkvY29udGV4dC1hc3luYy1ob29rcyc7XG4gKiBjb25zdCBTZW50cnlDb250ZXh0TWFuYWdlciA9IHdyYXBDb250ZXh0TWFuYWdlckNsYXNzKEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIpO1xuICogY29uc3QgY29udGV4dE1hbmFnZXIgPSBuZXcgU2VudHJ5Q29udGV4dE1hbmFnZXIoKTtcbiAqL1xuZnVuY3Rpb24gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MoXG4gIENvbnRleHRNYW5hZ2VyQ2xhc3MsXG4pIHtcbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjdXN0b20gQ29udGV4dE1hbmFnZXIgZm9yIE9wZW5UZWxlbWV0cnksIHdoaWNoIGV4dGVuZHMgdGhlIGRlZmF1bHQgQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlci5cbiAgICogSXQgZW5zdXJlcyB0aGF0IHdlIGNyZWF0ZSBuZXcgc2NvcGVzIHBlciBjb250ZXh0LCBzbyB0aGF0IHRoZSBPVEVMIENvbnRleHQgJiB0aGUgU2VudHJ5IFNjb3BlIGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICpcbiAgICogTm90ZSB0aGF0IHdlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgQXN5bmNIb29rcyB3aXRoIHRoaXMsXG4gICAqIGJ1dCBzaW5jZSB0aGlzIHNob3VsZCB3b3JrIGZvciBOb2RlIDE0KyBhbnlob3cgdGhhdCBzaG91bGQgYmUgZ29vZCBlbm91Z2guXG4gICAqL1xuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgZG9lcyBub3QgbGlrZSB0aGlzLCBidXQgd2Uga25vdyB0aGlzIGlzIGZpbmVcbiAgY2xhc3MgU2VudHJ5Q29udGV4dE1hbmFnZXIgZXh0ZW5kcyBDb250ZXh0TWFuYWdlckNsYXNzIHtcbiAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICBzZXRJc1NldHVwKCdTZW50cnlDb250ZXh0TWFuYWdlcicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVyd3JpdGUgd2l0aCgpIG9mIHRoZSBvcmlnaW5hbCBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyXG4gICAgICogdG8gZW5zdXJlIHdlIGFsc28gY3JlYXRlIG5ldyBzY29wZXMgcGVyIGNvbnRleHQuXG4gICAgICovXG4gICAgIHdpdGgoXG4gICAgICBjb250ZXh0LFxuICAgICAgZm4sXG4gICAgICB0aGlzQXJnLFxuICAgICAgLi4uYXJnc1xuICAgICkge1xuICAgICAgY29uc3QgY3VycmVudFNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3QgY3VycmVudFNjb3BlID0gX29wdGlvbmFsQ2hhaW4kMyhbY3VycmVudFNjb3BlcywgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnNjb3BlXSkgfHwgY29yZS5nZXRDdXJyZW50U2NvcGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJc29sYXRpb25TY29wZSA9IF9vcHRpb25hbENoYWluJDMoW2N1cnJlbnRTY29wZXMsICdvcHRpb25hbEFjY2VzcycsIF8yID0+IF8yLmlzb2xhdGlvblNjb3BlXSkgfHwgY29yZS5nZXRJc29sYXRpb25TY29wZSgpO1xuXG4gICAgICBjb25zdCBzaG91bGRGb3JrSXNvbGF0aW9uU2NvcGUgPSBjb250ZXh0LmdldFZhbHVlKFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSkgPT09IHRydWU7XG4gICAgICBjb25zdCBzY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX1NDT1BFX0NPTlRFWFRfS0VZKSA7XG4gICAgICBjb25zdCBpc29sYXRpb25TY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfU0VUX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSkgO1xuXG4gICAgICBjb25zdCBuZXdDdXJyZW50U2NvcGUgPSBzY29wZSB8fCBjdXJyZW50U2NvcGUuY2xvbmUoKTtcbiAgICAgIGNvbnN0IG5ld0lzb2xhdGlvblNjb3BlID1cbiAgICAgICAgaXNvbGF0aW9uU2NvcGUgfHwgKHNob3VsZEZvcmtJc29sYXRpb25TY29wZSA/IGN1cnJlbnRJc29sYXRpb25TY29wZS5jbG9uZSgpIDogY3VycmVudElzb2xhdGlvblNjb3BlKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IHsgc2NvcGU6IG5ld0N1cnJlbnRTY29wZSwgaXNvbGF0aW9uU2NvcGU6IG5ld0lzb2xhdGlvblNjb3BlIH07XG5cbiAgICAgIGNvbnN0IGN0eDEgPSBzZXRTY29wZXNPbkNvbnRleHQoY29udGV4dCwgc2NvcGVzKTtcblxuICAgICAgLy8gUmVtb3ZlIHRoZSB1bm5lZWRlZCB2YWx1ZXMgYWdhaW5cbiAgICAgIGNvbnN0IGN0eDIgPSBjdHgxXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkpXG4gICAgICAgIC5kZWxldGVWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKTtcblxuICAgICAgc2V0Q29udGV4dE9uU2NvcGUobmV3Q3VycmVudFNjb3BlLCBjdHgyKTtcblxuICAgICAgcmV0dXJuIHN1cGVyLndpdGgoY3R4MiwgZm4sIHRoaXNBcmcsIC4uLmFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTZW50cnlDb250ZXh0TWFuYWdlciA7XG59XG5cbi8qKiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyB0cnVlLCBpdCBtZWFucyB0aGF0IHRoZSBwYXJlbnQgaXMgYSByZW1vdGUgc3Bhbi4gKi9cbmNvbnN0IFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URSA9ICdzZW50cnkucGFyZW50SXNSZW1vdGUnO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gcnVucyB0aHJvdWdoIGEgbGlzdCBvZiBPVEVMIFNwYW5zLCBhbmQgd3JhcHMgdGhlbSBpbiBhbiBgU3Bhbk5vZGVgXG4gKiB3aGVyZSBlYWNoIG5vZGUgaG9sZHMgYSByZWZlcmVuY2UgdG8gdGhlaXIgcGFyZW50IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdyb3VwU3BhbnNXaXRoUGFyZW50cyhzcGFucykge1xuICBjb25zdCBub2RlTWFwID0gbmV3IE1hcCgpO1xuXG4gIGZvciAoY29uc3Qgc3BhbiBvZiBzcGFucykge1xuICAgIGNyZWF0ZU9yVXBkYXRlU3Bhbk5vZGVBbmRSZWZzKG5vZGVNYXAsIHNwYW4pO1xuICB9XG5cbiAgcmV0dXJuIEFycmF5LmZyb20obm9kZU1hcCwgZnVuY3Rpb24gKFtfaWQsIHNwYW5Ob2RlXSkge1xuICAgIHJldHVybiBzcGFuTm9kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhpcyByZXR1cm5zIHRoZSBfbG9jYWxfIHBhcmVudCBJRCAtIGBwYXJlbnRJZGAgb24gdGhlIHNwYW4gbWF5IHBvaW50IHRvIGEgcmVtb3RlIHNwYW4uXG4gKi9cbmZ1bmN0aW9uIGdldExvY2FsUGFyZW50SWQoc3Bhbikge1xuICBjb25zdCBwYXJlbnRJc1JlbW90ZSA9IHNwYW4uYXR0cmlidXRlc1tTRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1BBUkVOVF9JU19SRU1PVEVdID09PSB0cnVlO1xuICAvLyBJZiB0aGUgcGFyZW50SWQgaXMgdGhlIHRyYWNlIHBhcmVudCBJRCwgd2UgcHJldGVuZCBpdCdzIHVuZGVmaW5lZFxuICAvLyBBcyB0aGlzIG1lYW5zIHRoZSBwYXJlbnQgZXhpc3RzIHNvbWV3aGVyZSBlbHNlXG4gIHJldHVybiAhcGFyZW50SXNSZW1vdGUgPyBzcGFuLnBhcmVudFNwYW5JZCA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVTcGFuTm9kZUFuZFJlZnMobm9kZU1hcCwgc3Bhbikge1xuICBjb25zdCBpZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gIGNvbnN0IHBhcmVudElkID0gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKTtcblxuICBpZiAoIXBhcmVudElkKSB7XG4gICAgY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIHNwYW4sIGNoaWxkcmVuOiBbXSB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbHNlIG1ha2Ugc3VyZSB0byBjcmVhdGUgcGFyZW50IG5vZGUgYXMgd2VsbFxuICAvLyBOb3RlIHRoYXQgdGhlIHBhcmVudCBtYXkgbm90IGtub3cgaXQncyBwYXJlbnQgX3lldF8sIHRoaXMgbWF5IGJlIHVwZGF0ZWQgaW4gYSBsYXRlciBwYXNzXG4gIGNvbnN0IHBhcmVudE5vZGUgPSBjcmVhdGVPckdldFBhcmVudE5vZGUobm9kZU1hcCwgcGFyZW50SWQpO1xuICBjb25zdCBub2RlID0gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIHNwYW4sIHBhcmVudE5vZGUsIGNoaWxkcmVuOiBbXSB9KTtcbiAgcGFyZW50Tm9kZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPckdldFBhcmVudE5vZGUobm9kZU1hcCwgaWQpIHtcbiAgY29uc3QgZXhpc3RpbmcgPSBub2RlTWFwLmdldChpZCk7XG5cbiAgaWYgKGV4aXN0aW5nKSB7XG4gICAgcmV0dXJuIGV4aXN0aW5nO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCB7IGlkLCBjaGlsZHJlbjogW10gfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yVXBkYXRlTm9kZShub2RlTWFwLCBzcGFuTm9kZSkge1xuICBjb25zdCBleGlzdGluZyA9IG5vZGVNYXAuZ2V0KHNwYW5Ob2RlLmlkKTtcblxuICAvLyBJZiBzcGFuIGlzIGFscmVhZHkgc2V0LCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nLnNwYW4pIHtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICAvLyBJZiBpdCBleGlzdHMgYnV0IHNwYW4gaXMgbm90IHNldCB5ZXQsIHdlIHVwZGF0ZSBpdFxuICBpZiAoZXhpc3RpbmcgJiYgIWV4aXN0aW5nLnNwYW4pIHtcbiAgICBleGlzdGluZy5zcGFuID0gc3Bhbk5vZGUuc3BhbjtcbiAgICBleGlzdGluZy5wYXJlbnROb2RlID0gc3Bhbk5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICAvLyBFbHNlLCB3ZSBjcmVhdGUgYSBuZXcgb25lLi4uXG4gIG5vZGVNYXAuc2V0KHNwYW5Ob2RlLmlkLCBzcGFuTm9kZSk7XG4gIHJldHVybiBzcGFuTm9kZTtcbn1cblxuLy8gY2Fub25pY2FsQ29kZXNHcnBjTWFwIG1hcHMgc29tZSBHUlBDIGNvZGVzIHRvIFNlbnRyeSdzIHNwYW4gc3RhdHVzZXMuIFNlZSBkZXNjcmlwdGlvbiBpbiBncnBjIGRvY3VtZW50YXRpb24uXG5jb25zdCBjYW5vbmljYWxHcnBjRXJyb3JDb2Rlc01hcCA9IHtcbiAgJzEnOiAnY2FuY2VsbGVkJyxcbiAgJzInOiAndW5rbm93bl9lcnJvcicsXG4gICczJzogJ2ludmFsaWRfYXJndW1lbnQnLFxuICAnNCc6ICdkZWFkbGluZV9leGNlZWRlZCcsXG4gICc1JzogJ25vdF9mb3VuZCcsXG4gICc2JzogJ2FscmVhZHlfZXhpc3RzJyxcbiAgJzcnOiAncGVybWlzc2lvbl9kZW5pZWQnLFxuICAnOCc6ICdyZXNvdXJjZV9leGhhdXN0ZWQnLFxuICAnOSc6ICdmYWlsZWRfcHJlY29uZGl0aW9uJyxcbiAgJzEwJzogJ2Fib3J0ZWQnLFxuICAnMTEnOiAnb3V0X29mX3JhbmdlJyxcbiAgJzEyJzogJ3VuaW1wbGVtZW50ZWQnLFxuICAnMTMnOiAnaW50ZXJuYWxfZXJyb3InLFxuICAnMTQnOiAndW5hdmFpbGFibGUnLFxuICAnMTUnOiAnZGF0YV9sb3NzJyxcbiAgJzE2JzogJ3VuYXV0aGVudGljYXRlZCcsXG59IDtcblxuY29uc3QgaXNTdGF0dXNFcnJvck1lc3NhZ2VWYWxpZCA9IChtZXNzYWdlKSA9PiB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwKS5pbmNsdWRlcyhtZXNzYWdlICk7XG59O1xuXG4vKipcbiAqIEdldCBhIFNlbnRyeSBzcGFuIHN0YXR1cyBmcm9tIGFuIG90ZWwgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gbWFwU3RhdHVzKHNwYW4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pID8gc3Bhbi5hdHRyaWJ1dGVzIDoge307XG4gIGNvbnN0IHN0YXR1cyA9IHNwYW5IYXNTdGF0dXMoc3BhbikgPyBzcGFuLnN0YXR1cyA6IHVuZGVmaW5lZDtcblxuICBpZiAoc3RhdHVzKSB7XG4gICAgLy8gU2luY2Ugc3BhbiBzdGF0dXMgT0sgaXMgbm90IHNldCBieSBkZWZhdWx0LCB3ZSBnaXZlIGl0IHByaW9yaXR5OiBodHRwczovL29wZW50ZWxlbWV0cnkuaW8vZG9jcy9jb25jZXB0cy9zaWduYWxzL3RyYWNlcy8jc3Bhbi1zdGF0dXNcbiAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGFwaS5TcGFuU3RhdHVzQ29kZS5PSykge1xuICAgICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19PSyB9O1xuICAgICAgLy8gSWYgdGhlIHNwYW4gaXMgYWxyZWFkeSBtYXJrZWQgYXMgZXJyb25lb3VzIHdlIHJldHVybiB0aGF0IGV4YWN0IHN0YXR1c1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzLmNvZGUgPT09IGFwaS5TcGFuU3RhdHVzQ29kZS5FUlJPUikge1xuICAgICAgaWYgKHR5cGVvZiBzdGF0dXMubWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgaW5mZXJyZWRTdGF0dXMgPSBpbmZlclN0YXR1c0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTdGF0dXMpIHtcbiAgICAgICAgICByZXR1cm4gaW5mZXJyZWRTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1cy5tZXNzYWdlICYmIGlzU3RhdHVzRXJyb3JNZXNzYWdlVmFsaWQoc3RhdHVzLm1lc3NhZ2UpKSB7XG4gICAgICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6IHN0YXR1cy5tZXNzYWdlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX0VSUk9SLCBtZXNzYWdlOiAndW5rbm93bl9lcnJvcicgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGUgc3BhbiBzdGF0dXMgaXMgVU5TRVQsIHdlIHRyeSB0byBpbmZlciBpdCBmcm9tIEhUVFAgb3IgR1JQQyBzdGF0dXMgY29kZXMuXG4gIGNvbnN0IGluZmVycmVkU3RhdHVzID0gaW5mZXJTdGF0dXNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKTtcblxuICBpZiAoaW5mZXJyZWRTdGF0dXMpIHtcbiAgICByZXR1cm4gaW5mZXJyZWRTdGF0dXM7XG4gIH1cblxuICAvLyBXZSBkZWZhdWx0IHRvIHNldHRpbmcgdGhlIHNwYW5zIHN0YXR1cyB0byBvay5cbiAgaWYgKHN0YXR1cyAmJiBzdGF0dXMuY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLlVOU0VUKSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19PSyB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZmVyU3RhdHVzRnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAvLyBJZiB0aGUgc3BhbiBzdGF0dXMgaXMgVU5TRVQsIHdlIHRyeSB0byBpbmZlciBpdCBmcm9tIEhUVFAgb3IgR1JQQyBzdGF0dXMgY29kZXMuXG5cbiAgY29uc3QgaHR0cENvZGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV07XG4gIGNvbnN0IGdycGNDb2RlQXR0cmlidXRlID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX1JQQ19HUlBDX1NUQVRVU19DT0RFXTtcblxuICBjb25zdCBudW1iZXJIdHRwQ29kZSA9XG4gICAgdHlwZW9mIGh0dHBDb2RlQXR0cmlidXRlID09PSAnbnVtYmVyJ1xuICAgICAgPyBodHRwQ29kZUF0dHJpYnV0ZVxuICAgICAgOiB0eXBlb2YgaHR0cENvZGVBdHRyaWJ1dGUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gcGFyc2VJbnQoaHR0cENvZGVBdHRyaWJ1dGUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgbnVtYmVySHR0cENvZGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNvcmUuZ2V0U3BhblN0YXR1c0Zyb21IdHRwQ29kZShudW1iZXJIdHRwQ29kZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGdycGNDb2RlQXR0cmlidXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6IGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwW2dycGNDb2RlQXR0cmlidXRlXSB8fCAndW5rbm93bl9lcnJvcicgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDIob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxuY29uc3QgTUFYX1NQQU5fQ09VTlQgPSAxMDAwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMzAwOyAvLyA1IG1pblxuXG4vKipcbiAqIEEgU2VudHJ5LXNwZWNpZmljIGV4cG9ydGVyIHRoYXQgY29udmVydHMgT3BlblRlbGVtZXRyeSBTcGFucyB0byBTZW50cnkgU3BhbnMgJiBUcmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIFNlbnRyeVNwYW5FeHBvcnRlciB7XG5cbiAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5zID0gW107XG4gICAgdGhpcy5fdGltZW91dCA9IF9vcHRpb25hbENoYWluJDIoW29wdGlvbnMsICdvcHRpb25hbEFjY2VzcycsIF8gPT4gXy50aW1lb3V0XSkgfHwgREVGQVVMVF9USU1FT1VUO1xuICB9XG5cbiAgLyoqIEV4cG9ydCBhIHNpbmdsZSBzcGFuLiAqL1xuICAgZXhwb3J0KHNwYW4pIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5zLnB1c2goc3Bhbik7XG5cbiAgICAvLyBJZiB0aGUgc3BhbiBoYXMgYSBsb2NhbCBwYXJlbnQgSUQsIHdlIGRvbid0IG5lZWQgdG8gZXhwb3J0IGFueXRoaW5nIGp1c3QgeWV0XG4gICAgaWYgKGdldExvY2FsUGFyZW50SWQoc3BhbikpIHtcbiAgICAgIGNvbnN0IG9wZW5TcGFuQ291bnQgPSB0aGlzLl9maW5pc2hlZFNwYW5zLmxlbmd0aDtcbiAgICAgIERFQlVHX0JVSUxEICYmIHV0aWxzLmxvZ2dlci5sb2coYFNwYW5FeHBvcnRlciBoYXMgJHtvcGVuU3BhbkNvdW50fSB1bnNlbnQgc3BhbnMgcmVtYWluaW5nYCk7XG4gICAgICB0aGlzLl9jbGVhbnVwT2xkU3BhbnMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgIC8vIElmIHdlIGdvdCBhIHBhcmVudCBzcGFuLCB3ZSB0cnkgdG8gc2VuZCB0aGUgc3BhbiB0cmVlXG4gICAgLy8gV2FpdCBhIHRpY2sgZm9yIHRoaXMsIHRvIGVuc3VyZSB3ZSBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICB0aGlzLl9mbHVzaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9LCAxKTtcbiAgfVxuXG4gIC8qKiBUcnkgdG8gZmx1c2ggYW55IHBlbmRpbmcgc3BhbnMgaW1tZWRpYXRlbHkuICovXG4gICBmbHVzaCgpIHtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgIGNvbnN0IG9wZW5TcGFuQ291bnQgPSB0aGlzLl9maW5pc2hlZFNwYW5zLmxlbmd0aDtcblxuICAgIGNvbnN0IHJlbWFpbmluZ1NwYW5zID0gbWF5YmVTZW5kKHRoaXMuX2ZpbmlzaGVkU3BhbnMpO1xuXG4gICAgY29uc3QgcmVtYWluaW5nT3BlblNwYW5Db3VudCA9IHJlbWFpbmluZ1NwYW5zLmxlbmd0aDtcbiAgICBjb25zdCBzZW50U3BhbkNvdW50ID0gb3BlblNwYW5Db3VudCAtIHJlbWFpbmluZ09wZW5TcGFuQ291bnQ7XG5cbiAgICBERUJVR19CVUlMRCAmJlxuICAgICAgdXRpbHMubG9nZ2VyLmxvZyhgU3BhbkV4cG9ydGVyIGV4cG9ydGVkICR7c2VudFNwYW5Db3VudH0gc3BhbnMsICR7cmVtYWluaW5nT3BlblNwYW5Db3VudH0gdW5zZW50IHNwYW5zIHJlbWFpbmluZ2ApO1xuXG4gICAgdGhpcy5fY2xlYW51cE9sZFNwYW5zKHJlbWFpbmluZ1NwYW5zKTtcbiAgfVxuXG4gIC8qKiBDbGVhciB0aGUgZXhwb3J0ZXIuICovXG4gICBjbGVhcigpIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5zID0gW107XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gIH1cblxuICAvKiogQ2xlYXIgdGhlIGZsdXNoIHRpbWVvdXQuICovXG4gICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLl9mbHVzaFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9mbHVzaFRpbWVvdXQpO1xuICAgICAgdGhpcy5fZmx1c2hUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IHNwYW4gdGhhdCBpcyBvbGRlciB0aGFuIDVtaW4uXG4gICAqIFdlIGRvIHRoaXMgdG8gYXZvaWQgbGVha2luZyBtZW1vcnkuXG4gICAqL1xuICAgX2NsZWFudXBPbGRTcGFucyhzcGFucyA9IHRoaXMuX2ZpbmlzaGVkU3BhbnMpIHtcbiAgICB0aGlzLl9maW5pc2hlZFNwYW5zID0gc3BhbnMuZmlsdGVyKHNwYW4gPT4ge1xuICAgICAgY29uc3Qgc2hvdWxkRHJvcCA9IHNob3VsZENsZWFudXBTcGFuKHNwYW4sIHRoaXMuX3RpbWVvdXQpO1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgc2hvdWxkRHJvcCAmJlxuICAgICAgICB1dGlscy5sb2dnZXIubG9nKFxuICAgICAgICAgIGBTcGFuRXhwb3J0ZXIgZHJvcHBpbmcgc3BhbiAke3NwYW4ubmFtZX0gKCR7XG4gICAgICAgICAgICBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkXG4gICAgICAgICAgfSkgYmVjYXVzZSBpdCBpcyBwZW5kaW5nIGZvciBtb3JlIHRoYW4gNSBtaW51dGVzLmAsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gIXNob3VsZERyb3A7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZW5kIHRoZSBnaXZlbiBzcGFucywgYnV0IG9ubHkgaWYgdGhleSBhcmUgcGFydCBvZiBhIGZpbmlzaGVkIHRyYW5zYWN0aW9uLlxuICpcbiAqIFJldHVybnMgdGhlIHVuc2VudCBzcGFucy5cbiAqIFNwYW5zIHJlbWFpbiB1bnNlbnQgd2hlbiB0aGVpciBwYXJlbnQgc3BhbiBpcyBub3QgeWV0IGZpbmlzaGVkLlxuICogVGhpcyB3aWxsIGhhcHBlbiByZWd1bGFybHksIGFzIGNoaWxkIHNwYW5zIGFyZSBnZW5lcmFsbHkgZmluaXNoZWQgYmVmb3JlIHRoZWlyIHBhcmVudHMuXG4gKiBCdXQgaXQgX2NvdWxkXyBhbHNvIGhhcHBlbiBiZWNhdXNlLCBmb3Igd2hhdGV2ZXIgcmVhc29uLCBhIHBhcmVudCBzcGFuIHdhcyBsb3N0LlxuICogSW4gdGhpcyBjYXNlLCB3ZSdsbCBldmVudHVhbGx5IG5lZWQgdG8gY2xlYW4gdGhpcyB1cC5cbiAqL1xuZnVuY3Rpb24gbWF5YmVTZW5kKHNwYW5zKSB7XG4gIGNvbnN0IGdyb3VwZWQgPSBncm91cFNwYW5zV2l0aFBhcmVudHMoc3BhbnMpO1xuICBjb25zdCByZW1haW5pbmcgPSBuZXcgU2V0KGdyb3VwZWQpO1xuXG4gIGNvbnN0IHJvb3ROb2RlcyA9IGdldENvbXBsZXRlZFJvb3ROb2Rlcyhncm91cGVkKTtcblxuICByb290Tm9kZXMuZm9yRWFjaChyb290ID0+IHtcbiAgICByZW1haW5pbmcuZGVsZXRlKHJvb3QpO1xuICAgIGNvbnN0IHNwYW4gPSByb290LnNwYW47XG4gICAgY29uc3QgdHJhbnNhY3Rpb25FdmVudCA9IGNyZWF0ZVRyYW5zYWN0aW9uRm9yT3RlbFNwYW4oc3Bhbik7XG5cbiAgICAvLyBXZSdsbCByZWN1cnNpdmVseSBhZGQgYWxsIHRoZSBjaGlsZCBzcGFucyB0byB0aGlzIGFycmF5XG4gICAgY29uc3Qgc3BhbnMgPSB0cmFuc2FjdGlvbkV2ZW50LnNwYW5zIHx8IFtdO1xuXG4gICAgcm9vdC5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3BhbihjaGlsZCwgc3BhbnMsIHJlbWFpbmluZyk7XG4gICAgfSk7XG5cbiAgICAvLyBzcGFucy5zb3J0KCkgbXV0YXRlcyB0aGUgYXJyYXksIGJ1dCB3ZSBkbyBub3QgdXNlIHRoaXMgYW55bW9yZSBhZnRlciB0aGlzIHBvaW50XG4gICAgLy8gc28gd2UgY2FuIHNhZmVseSBtdXRhdGUgaXQgaGVyZVxuICAgIHRyYW5zYWN0aW9uRXZlbnQuc3BhbnMgPVxuICAgICAgc3BhbnMubGVuZ3RoID4gTUFYX1NQQU5fQ09VTlRcbiAgICAgICAgPyBzcGFucy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0X3RpbWVzdGFtcCAtIGIuc3RhcnRfdGltZXN0YW1wKS5zbGljZSgwLCBNQVhfU1BBTl9DT1VOVClcbiAgICAgICAgOiBzcGFucztcblxuICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IGNvcmUudGltZWRFdmVudHNUb01lYXN1cmVtZW50cyhzcGFuLmV2ZW50cyk7XG4gICAgaWYgKG1lYXN1cmVtZW50cykge1xuICAgICAgdHJhbnNhY3Rpb25FdmVudC5tZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHM7XG4gICAgfVxuXG4gICAgY29yZS5jYXB0dXJlRXZlbnQodHJhbnNhY3Rpb25FdmVudCk7XG4gIH0pO1xuXG4gIHJldHVybiBBcnJheS5mcm9tKHJlbWFpbmluZylcbiAgICAubWFwKG5vZGUgPT4gbm9kZS5zcGFuKVxuICAgIC5maWx0ZXIoKHNwYW4pID0+ICEhc3Bhbik7XG59XG5cbmZ1bmN0aW9uIG5vZGVJc0NvbXBsZXRlZFJvb3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICEhbm9kZS5zcGFuICYmICFub2RlLnBhcmVudE5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBsZXRlZFJvb3ROb2Rlcyhub2Rlcykge1xuICByZXR1cm4gbm9kZXMuZmlsdGVyKG5vZGVJc0NvbXBsZXRlZFJvb3ROb2RlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ2xlYW51cFNwYW4oc3BhbiwgbWF4U3RhcnRUaW1lT2Zmc2V0U2Vjb25kcykge1xuICBjb25zdCBjdXRvZmYgPSBEYXRlLm5vdygpIC8gMTAwMCAtIG1heFN0YXJ0VGltZU9mZnNldFNlY29uZHM7XG4gIHJldHVybiBjb3JlLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoc3Bhbi5zdGFydFRpbWUpIDwgY3V0b2ZmO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNwYW4oc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbi5hdHRyaWJ1dGVzO1xuXG4gIGNvbnN0IG9yaWdpbiA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09SSUdJTl0gO1xuICBjb25zdCBvcCA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXSA7XG4gIGNvbnN0IHNvdXJjZSA9IGF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV0gO1xuXG4gIHJldHVybiB7IG9yaWdpbiwgb3AsIHNvdXJjZSB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUcmFuc2FjdGlvbkZvck90ZWxTcGFuKHNwYW4pIHtcbiAgY29uc3QgeyBvcCwgZGVzY3JpcHRpb24sIGRhdGEsIG9yaWdpbiA9ICdtYW51YWwnLCBzb3VyY2UgfSA9IGdldFNwYW5EYXRhKHNwYW4pO1xuICBjb25zdCBjYXB0dXJlZFNwYW5TY29wZXMgPSBjb3JlLmdldENhcHR1cmVkU2NvcGVzT25TcGFuKHNwYW4gKTtcblxuICBjb25zdCBzYW1wbGVSYXRlID0gc3Bhbi5hdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV0gO1xuXG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSB1dGlscy5kcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TT1VSQ0VdOiBzb3VyY2UsXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV06IHNhbXBsZVJhdGUsXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IG9wLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogb3JpZ2luLFxuICAgIC4uLmRhdGEsXG4gICAgLi4ucmVtb3ZlU2VudHJ5QXR0cmlidXRlcyhzcGFuLmF0dHJpYnV0ZXMpLFxuICB9KTtcblxuICBjb25zdCB7IHRyYWNlSWQ6IHRyYWNlX2lkLCBzcGFuSWQ6IHNwYW5faWQgfSA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICBjb25zdCBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSA9IF9vcHRpb25hbENoYWluJDIoW3NwYW4sICdhY2Nlc3MnLCBfMiA9PiBfMi5zcGFuQ29udGV4dCwgJ2NhbGwnLCBfMyA9PiBfMygpLCAnYWNjZXNzJywgXzQgPT4gXzQudHJhY2VTdGF0ZSwgJ29wdGlvbmFsQWNjZXNzJywgXzUgPT4gXzUuZ2V0LCAnY2FsbCcsIF82ID0+IF82KFNFTlRSWV9UUkFDRV9TVEFURV9QQVJFTlRfU1BBTl9JRCldKTtcblxuICAvLyBJZiBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSBpcyBkZWZpbmVkIGF0IGFsbCwgd2Ugd2FudCBpdCB0byB0YWtlIHByZXNlZGVuY2VcbiAgLy8gSW4gdGhhdCBjYXNlLCBhbiBlbXB0eSBzdHJpbmcgc2hvdWxkIGJlIGludGVycHJldGVkIGFzIFwibm8gcGFyZW50IHNwYW4gaWRcIixcbiAgLy8gZXZlbiBpZiBgc3Bhbi5wYXJlbnRTcGFuSWRgIGlzIHNldFxuICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZW4gd2UgYXJlIHN0YXJ0aW5nIGEgbmV3IHRyYWNlLCB3aGVyZSB3ZSBoYXZlIGEgdmlydHVhbCBzcGFuIGJhc2VkIG9uIHRoZSBwcm9wYWdhdGlvbkNvbnRleHRcbiAgLy8gV2Ugb25seSB3YW50IHRvIGNvbnRpbnVlIHRoZSB0cmFjZUlkIGluIHRoaXMgY2FzZSwgYnV0IGlnbm9yZSB0aGUgcGFyZW50IHNwYW5cbiAgY29uc3QgcGFyZW50X3NwYW5faWQgPVxuICAgIHR5cGVvZiBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSB8fCB1bmRlZmluZWQgOiBzcGFuLnBhcmVudFNwYW5JZDtcblxuICBjb25zdCBzdGF0dXMgPSBtYXBTdGF0dXMoc3Bhbik7XG5cbiAgY29uc3QgdHJhY2VDb250ZXh0ID0gdXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgIHBhcmVudF9zcGFuX2lkLFxuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgZGF0YTogYXR0cmlidXRlcyxcbiAgICBvcmlnaW4sXG4gICAgb3AsXG4gICAgc3RhdHVzOiBjb3JlLmdldFN0YXR1c01lc3NhZ2Uoc3RhdHVzKSwgLy8gQXMgcGVyIHByb3RvY29sLCBzcGFuIHN0YXR1cyBpcyBhbGxvd2VkIHRvIGJlIHVuZGVmaW5lZFxuICB9KTtcblxuICBjb25zdCB0cmFuc2FjdGlvbkV2ZW50ID0ge1xuICAgIGNvbnRleHRzOiB7XG4gICAgICB0cmFjZTogdHJhY2VDb250ZXh0LFxuICAgICAgb3RlbDoge1xuICAgICAgICByZXNvdXJjZTogc3Bhbi5yZXNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHNwYW5zOiBbXSxcbiAgICBzdGFydF90aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzcGFuLnN0YXJ0VGltZSksXG4gICAgdGltZXN0YW1wOiBjb3JlLnNwYW5UaW1lSW5wdXRUb1NlY29uZHMoc3Bhbi5lbmRUaW1lKSxcbiAgICB0cmFuc2FjdGlvbjogZGVzY3JpcHRpb24sXG4gICAgdHlwZTogJ3RyYW5zYWN0aW9uJyxcbiAgICBzZGtQcm9jZXNzaW5nTWV0YWRhdGE6IHtcbiAgICAgIC4uLnV0aWxzLmRyb3BVbmRlZmluZWRLZXlzKHtcbiAgICAgICAgY2FwdHVyZWRTcGFuU2NvcGU6IGNhcHR1cmVkU3BhblNjb3Blcy5zY29wZSxcbiAgICAgICAgY2FwdHVyZWRTcGFuSXNvbGF0aW9uU2NvcGU6IGNhcHR1cmVkU3BhblNjb3Blcy5pc29sYXRpb25TY29wZSxcbiAgICAgICAgc2FtcGxlUmF0ZSxcbiAgICAgICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dDogY29yZS5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4oc3BhbiApLFxuICAgICAgfSksXG4gICAgfSxcbiAgICAuLi4oc291cmNlICYmIHtcbiAgICAgIHRyYW5zYWN0aW9uX2luZm86IHtcbiAgICAgICAgc291cmNlLFxuICAgICAgfSxcbiAgICB9KSxcbiAgICBfbWV0cmljc19zdW1tYXJ5OiBjb3JlLmdldE1ldHJpY1N1bW1hcnlKc29uRm9yU3BhbihzcGFuICksXG4gIH07XG5cbiAgcmV0dXJuIHRyYW5zYWN0aW9uRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3Bhbihub2RlLCBzcGFucywgcmVtYWluaW5nKSB7XG4gIHJlbWFpbmluZy5kZWxldGUobm9kZSk7XG4gIGNvbnN0IHNwYW4gPSBub2RlLnNwYW47XG5cbiAgY29uc3Qgc2hvdWxkRHJvcCA9ICFzcGFuO1xuXG4gIC8vIElmIHRoaXMgc3BhbiBzaG91bGQgYmUgZHJvcHBlZCwgd2Ugc3RpbGwgd2FudCB0byBjcmVhdGUgc3BhbnMgZm9yIHRoZSBjaGlsZHJlbiBvZiB0aGlzXG4gIGlmIChzaG91bGREcm9wKSB7XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3BhbihjaGlsZCwgc3BhbnMsIHJlbWFpbmluZyk7XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3Bhbl9pZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gIGNvbnN0IHRyYWNlX2lkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQ7XG5cbiAgY29uc3QgeyBhdHRyaWJ1dGVzLCBzdGFydFRpbWUsIGVuZFRpbWUsIHBhcmVudFNwYW5JZCB9ID0gc3BhbjtcblxuICBjb25zdCB7IG9wLCBkZXNjcmlwdGlvbiwgZGF0YSwgb3JpZ2luID0gJ21hbnVhbCcgfSA9IGdldFNwYW5EYXRhKHNwYW4pO1xuICBjb25zdCBhbGxEYXRhID0gdXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXTogb3JpZ2luLFxuICAgIFtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdOiBvcCxcbiAgICAuLi5yZW1vdmVTZW50cnlBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpLFxuICAgIC4uLmRhdGEsXG4gIH0pO1xuXG4gIGNvbnN0IHN0YXR1cyA9IG1hcFN0YXR1cyhzcGFuKTtcblxuICBjb25zdCBzcGFuSlNPTiA9IHV0aWxzLmRyb3BVbmRlZmluZWRLZXlzKHtcbiAgICBzcGFuX2lkLFxuICAgIHRyYWNlX2lkLFxuICAgIGRhdGE6IGFsbERhdGEsXG4gICAgZGVzY3JpcHRpb24sXG4gICAgcGFyZW50X3NwYW5faWQ6IHBhcmVudFNwYW5JZCxcbiAgICBzdGFydF90aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzdGFydFRpbWUpLFxuICAgIC8vIFRoaXMgaXMgWzAsMF0gYnkgZGVmYXVsdCBpbiBPVEVMLCBpbiB3aGljaCBjYXNlIHdlIHdhbnQgdG8gaW50ZXJwcmV0IHRoaXMgYXMgbm8gZW5kIHRpbWVcbiAgICB0aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhlbmRUaW1lKSB8fCB1bmRlZmluZWQsXG4gICAgc3RhdHVzOiBjb3JlLmdldFN0YXR1c01lc3NhZ2Uoc3RhdHVzKSwgLy8gQXMgcGVyIHByb3RvY29sLCBzcGFuIHN0YXR1cyBpcyBhbGxvd2VkIHRvIGJlIHVuZGVmaW5lZFxuICAgIG9wLFxuICAgIG9yaWdpbixcbiAgICBfbWV0cmljc19zdW1tYXJ5OiBjb3JlLmdldE1ldHJpY1N1bW1hcnlKc29uRm9yU3BhbihzcGFuICksXG4gICAgbWVhc3VyZW1lbnRzOiBjb3JlLnRpbWVkRXZlbnRzVG9NZWFzdXJlbWVudHMoc3Bhbi5ldmVudHMpLFxuICB9KTtcblxuICBzcGFucy5wdXNoKHNwYW5KU09OKTtcblxuICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGNyZWF0ZUFuZEZpbmlzaFNwYW5Gb3JPdGVsU3BhbihjaGlsZCwgc3BhbnMsIHJlbWFpbmluZyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTcGFuRGF0YShzcGFuKVxuXG4ge1xuICBjb25zdCB7IG9wOiBkZWZpbmVkT3AsIHNvdXJjZTogZGVmaW5lZFNvdXJjZSwgb3JpZ2luIH0gPSBwYXJzZVNwYW4oc3Bhbik7XG4gIGNvbnN0IHsgb3A6IGluZmVycmVkT3AsIGRlc2NyaXB0aW9uLCBzb3VyY2U6IGluZmVycmVkU291cmNlLCBkYXRhOiBpbmZlcnJlZERhdGEgfSA9IHBhcnNlU3BhbkRlc2NyaXB0aW9uKHNwYW4pO1xuXG4gIGNvbnN0IG9wID0gZGVmaW5lZE9wIHx8IGluZmVycmVkT3A7XG4gIGNvbnN0IHNvdXJjZSA9IGRlZmluZWRTb3VyY2UgfHwgaW5mZXJyZWRTb3VyY2U7XG5cbiAgY29uc3QgZGF0YSA9IHsgLi4uaW5mZXJyZWREYXRhLCAuLi5nZXREYXRhKHNwYW4pIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvcCxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzb3VyY2UsXG4gICAgb3JpZ2luLFxuICAgIGRhdGEsXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlIGN1c3RvbSBgc2VudHJ5LmAgYXR0cmlidHVlcyB3ZSBkbyBub3QgbmVlZCB0byBzZW5kLlxuICogVGhlc2UgYXJlIG1vcmUgY2FycmllciBhdHRyaWJ1dGVzIHdlIHVzZSBpbnNpZGUgb2YgdGhlIFNESywgd2UgZG8gbm90IG5lZWQgdG8gc2VuZCB0aGVtIHRvIHRoZSBBUEkuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVNlbnRyeUF0dHJpYnV0ZXMoZGF0YSkge1xuICBjb25zdCBjbGVhbmVkRGF0YSA9IHsgLi4uZGF0YSB9O1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1keW5hbWljLWRlbGV0ZSAqL1xuICBkZWxldGUgY2xlYW5lZERhdGFbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTtcbiAgZGVsZXRlIGNsZWFuZWREYXRhW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URV07XG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlICovXG5cbiAgcmV0dXJuIGNsZWFuZWREYXRhO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhKHNwYW4pIHtcbiAgY29uc3QgYXR0cmlidXRlcyA9IHNwYW4uYXR0cmlidXRlcztcbiAgY29uc3QgZGF0YSA9IHtcbiAgICAnb3RlbC5raW5kJzogYXBpLlNwYW5LaW5kW3NwYW4ua2luZF0sXG4gIH07XG5cbiAgaWYgKGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXSkge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9TVEFUVVNfQ09ERV0gO1xuICAgIGRhdGFbJ2h0dHAucmVzcG9uc2Uuc3RhdHVzX2NvZGUnXSA9IHN0YXR1c0NvZGU7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0RGF0YSA9IGdldFJlcXVlc3RTcGFuRGF0YShzcGFuKTtcblxuICBpZiAocmVxdWVzdERhdGEudXJsKSB7XG4gICAgZGF0YS51cmwgPSByZXF1ZXN0RGF0YS51cmw7XG4gIH1cblxuICBpZiAocmVxdWVzdERhdGFbJ2h0dHAucXVlcnknXSkge1xuICAgIGRhdGFbJ2h0dHAucXVlcnknXSA9IHJlcXVlc3REYXRhWydodHRwLnF1ZXJ5J10uc2xpY2UoMSk7XG4gIH1cbiAgaWYgKHJlcXVlc3REYXRhWydodHRwLmZyYWdtZW50J10pIHtcbiAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSByZXF1ZXN0RGF0YVsnaHR0cC5mcmFnbWVudCddLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDEob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxuZnVuY3Rpb24gb25TcGFuU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCkge1xuICAvLyBUaGlzIGlzIGEgcmVsaWFibGUgd2F5IHRvIGdldCB0aGUgcGFyZW50IHNwYW4gLSBiZWNhdXNlIHRoaXMgaXMgZXhhY3RseSBob3cgdGhlIHBhcmVudCBpcyBpZGVudGlmaWVkIGluIHRoZSBPVEVMIFNES1xuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4ocGFyZW50Q29udGV4dCk7XG5cbiAgbGV0IHNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KHBhcmVudENvbnRleHQpO1xuXG4gIC8vIFdlIG5lZWQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgc3BhbiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIG1vdmUgdXAgdGhlIHNwYW4gdHJlZSBmb3IgYnJlYWRjcnVtYnNcbiAgaWYgKHBhcmVudFNwYW4gJiYgIXBhcmVudFNwYW4uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSkge1xuICAgIGNvcmUuYWRkQ2hpbGRTcGFuVG9TcGFuKHBhcmVudFNwYW4sIHNwYW4pO1xuICB9XG5cbiAgLy8gV2UgbmVlZCB0aGlzIGluIHRoZSBzcGFuIGV4cG9ydGVyXG4gIGlmIChwYXJlbnRTcGFuICYmIHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKS5pc1JlbW90ZSkge1xuICAgIHNwYW4uc2V0QXR0cmlidXRlKFNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URSwgdHJ1ZSk7XG4gIH1cblxuICAvLyBUaGUgcm9vdCBjb250ZXh0IGRvZXMgbm90IGhhdmUgc2NvcGVzIHN0b3JlZCwgc28gd2UgY2hlY2sgZm9yIHRoaXMgc3BlY2lmaWNhbGx5XG4gIC8vIEFzIGZhbGxiYWNrIHdlIGF0dGFjaCB0aGUgZ2xvYmFsIHNjb3Blc1xuICBpZiAocGFyZW50Q29udGV4dCA9PT0gYXBpLlJPT1RfQ09OVEVYVCkge1xuICAgIHNjb3BlcyA9IHtcbiAgICAgIHNjb3BlOiBjb3JlLmdldERlZmF1bHRDdXJyZW50U2NvcGUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBjb3JlLmdldERlZmF1bHRJc29sYXRpb25TY29wZSgpLFxuICAgIH07XG4gIH1cblxuICAvLyBXZSBuZWVkIHRoZSBzY29wZSBhdCB0aW1lIG9mIHNwYW4gY3JlYXRpb24gaW4gb3JkZXIgdG8gYXBwbHkgaXQgdG8gdGhlIGV2ZW50IHdoZW4gdGhlIHNwYW4gaXMgZmluaXNoZWRcbiAgaWYgKHNjb3Blcykge1xuICAgIGNvcmUuc2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3Bhbiwgc2NvcGVzLnNjb3BlLCBzY29wZXMuaXNvbGF0aW9uU2NvcGUpO1xuICB9XG5cbiAgY29yZS5sb2dTcGFuU3RhcnQoc3Bhbik7XG5cbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgX29wdGlvbmFsQ2hhaW4kMShbY2xpZW50LCAnb3B0aW9uYWxBY2Nlc3MnLCBfID0+IF8uZW1pdCwgJ2NhbGwnLCBfMiA9PiBfMignc3BhblN0YXJ0Jywgc3BhbildKTtcbn1cblxuZnVuY3Rpb24gb25TcGFuRW5kKHNwYW4pIHtcbiAgY29yZS5sb2dTcGFuRW5kKHNwYW4pO1xuXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG4gIF9vcHRpb25hbENoYWluJDEoW2NsaWVudCwgJ29wdGlvbmFsQWNjZXNzJywgXzMgPT4gXzMuZW1pdCwgJ2NhbGwnLCBfNCA9PiBfNCgnc3BhbkVuZCcsIHNwYW4pXSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgT3BlblRlbGVtZXRyeSBTcGFucyB0byBTZW50cnkgU3BhbnMgYW5kIHNlbmRzIHRoZW0gdG8gU2VudHJ5IHZpYVxuICogdGhlIFNlbnRyeSBTREsuXG4gKi9cbmNsYXNzIFNlbnRyeVNwYW5Qcm9jZXNzb3IgIHtcblxuICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVNwYW5Qcm9jZXNzb3InKTtcbiAgICB0aGlzLl9leHBvcnRlciA9IG5ldyBTZW50cnlTcGFuRXhwb3J0ZXIob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBhc3luYyBmb3JjZUZsdXNoKCkge1xuICAgIHRoaXMuX2V4cG9ydGVyLmZsdXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBhc3luYyBzaHV0ZG93bigpIHtcbiAgICB0aGlzLl9leHBvcnRlci5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgb25TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KSB7XG4gICAgb25TcGFuU3RhcnQoc3BhbiwgcGFyZW50Q29udGV4dCk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIG9uRW5kKHNwYW4pIHtcbiAgICBvblNwYW5FbmQoc3Bhbik7XG5cbiAgICB0aGlzLl9leHBvcnRlci5leHBvcnQoc3Bhbik7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGN1c3RvbSBPVEVMIHNhbXBsZXIgdGhhdCB1c2VzIFNlbnRyeSBzYW1wbGluZyByYXRlcyB0byBtYWtlIGl0cyBkZWNpc2lvblxuICovXG5jbGFzcyBTZW50cnlTYW1wbGVyICB7XG5cbiAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICBzZXRJc1NldHVwKCdTZW50cnlTYW1wbGVyJyk7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgIHNob3VsZFNhbXBsZShcbiAgICBjb250ZXh0LFxuICAgIHRyYWNlSWQsXG4gICAgc3Bhbk5hbWUsXG4gICAgc3BhbktpbmQsXG4gICAgc3BhbkF0dHJpYnV0ZXMsXG4gICAgX2xpbmtzLFxuICApIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fY2xpZW50LmdldE9wdGlvbnMoKTtcblxuICAgIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcbiAgICBjb25zdCBwYXJlbnRDb250ZXh0ID0gX29wdGlvbmFsQ2hhaW4oW3BhcmVudFNwYW4sICdvcHRpb25hbEFjY2VzcycsIF8gPT4gXy5zcGFuQ29udGV4dCwgJ2NhbGwnLCBfMiA9PiBfMigpXSk7XG5cbiAgICBpZiAoIWNvcmUuaGFzVHJhY2luZ0VuYWJsZWQob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgYSBodHRwLmNsaWVudCBzcGFuIHRoYXQgaGFzIG5vIGxvY2FsIHBhcmVudCwgd2UgbmV2ZXIgd2FudCB0byBzYW1wbGUgaXRcbiAgICAvLyBidXQgd2Ugd2FudCB0byBsZWF2ZSBkb3duc3RyZWFtIHNhbXBsaW5nIGRlY2lzaW9ucyB1cCB0byB0aGUgc2VydmVyXG4gICAgaWYgKFxuICAgICAgc3BhbktpbmQgPT09IGFwaS5TcGFuS2luZC5DTElFTlQgJiZcbiAgICAgIHNwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9NRVRIT0RdICYmXG4gICAgICAoIXBhcmVudFNwYW4gfHwgX29wdGlvbmFsQ2hhaW4oW3BhcmVudENvbnRleHQsICdvcHRpb25hbEFjY2VzcycsIF8zID0+IF8zLmlzUmVtb3RlXSkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gd3JhcFNhbXBsaW5nRGVjaXNpb24oeyBkZWNpc2lvbjogdW5kZWZpbmVkLCBjb250ZXh0LCBzcGFuQXR0cmlidXRlcyB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRTYW1wbGVkID0gcGFyZW50U3BhbiA/IGdldFBhcmVudFNhbXBsZWQocGFyZW50U3BhbiwgdHJhY2VJZCwgc3Bhbk5hbWUpIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgbXV0YWJsZVNhbXBsaW5nRGVjaXNpb24gPSB7IGRlY2lzaW9uOiB0cnVlIH07XG4gICAgdGhpcy5fY2xpZW50LmVtaXQoXG4gICAgICAnYmVmb3JlU2FtcGxpbmcnLFxuICAgICAge1xuICAgICAgICBzcGFuQXR0cmlidXRlczogc3BhbkF0dHJpYnV0ZXMsXG4gICAgICAgIHNwYW5OYW1lOiBzcGFuTmFtZSxcbiAgICAgICAgcGFyZW50U2FtcGxlZDogcGFyZW50U2FtcGxlZCxcbiAgICAgICAgcGFyZW50Q29udGV4dDogcGFyZW50Q29udGV4dCxcbiAgICAgIH0sXG4gICAgICBtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbixcbiAgICApO1xuICAgIGlmICghbXV0YWJsZVNhbXBsaW5nRGVjaXNpb24uZGVjaXNpb24pIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IFtzYW1wbGVkLCBzYW1wbGVSYXRlXSA9IGNvcmUuc2FtcGxlU3BhbihvcHRpb25zLCB7XG4gICAgICBuYW1lOiBzcGFuTmFtZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHNwYW5BdHRyaWJ1dGVzLFxuICAgICAgdHJhbnNhY3Rpb25Db250ZXh0OiB7XG4gICAgICAgIG5hbWU6IHNwYW5OYW1lLFxuICAgICAgICBwYXJlbnRTYW1wbGVkLFxuICAgICAgfSxcbiAgICAgIHBhcmVudFNhbXBsZWQsXG4gICAgfSk7XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9TQU1QTEVfUkFURV06IHNhbXBsZVJhdGUsXG4gICAgfTtcblxuICAgIGNvbnN0IG1ldGhvZCA9IGAke3NwYW5BdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9NRVRIT0RdfWAudG9VcHBlckNhc2UoKTtcbiAgICBpZiAobWV0aG9kID09PSAnT1BUSU9OUycgfHwgbWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIERFQlVHX0JVSUxEICYmIHV0aWxzLmxvZ2dlci5sb2coYFtUcmFjaW5nXSBOb3Qgc2FtcGxpbmcgc3BhbiBiZWNhdXNlIEhUVFAgbWV0aG9kIGlzICcke21ldGhvZH0nIGZvciAke3NwYW5OYW1lfWApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi53cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELCBjb250ZXh0LCBzcGFuQXR0cmlidXRlcyB9KSxcbiAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFzYW1wbGVkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi53cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELCBjb250ZXh0LCBzcGFuQXR0cmlidXRlcyB9KSxcbiAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi53cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5SRUNPUkRfQU5EX1NBTVBMRUQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICB9O1xuICB9XG5cbiAgLyoqIFJldHVybnMgdGhlIHNhbXBsZXIgbmFtZSBvciBzaG9ydCBkZXNjcmlwdGlvbiB3aXRoIHRoZSBjb25maWd1cmF0aW9uLiAqL1xuICAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdTZW50cnlTYW1wbGVyJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRSZW1vdGVTYW1wbGVkKHBhcmVudFNwYW4pIHtcbiAgY29uc3QgdHJhY2VJZCA9IHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKS50cmFjZUlkO1xuICBjb25zdCB0cmFjZXBhcmVudERhdGEgPSBnZXRQcm9wYWdhdGlvbkNvbnRleHRGcm9tU3BhbihwYXJlbnRTcGFuKTtcblxuICAvLyBPbmx5IGluaGVyaXQgc2FtcGxlZCBpZiBgdHJhY2VJZGAgaXMgdGhlIHNhbWVcbiAgcmV0dXJuIHRyYWNlcGFyZW50RGF0YSAmJiB0cmFjZUlkID09PSB0cmFjZXBhcmVudERhdGEudHJhY2VJZCA/IHRyYWNlcGFyZW50RGF0YS5zYW1wbGVkIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTYW1wbGVkKHBhcmVudFNwYW4sIHRyYWNlSWQsIHNwYW5OYW1lKSB7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBwYXJlbnRTcGFuLnNwYW5Db250ZXh0KCk7XG5cbiAgLy8gT25seSBpbmhlcml0IHNhbXBsZSByYXRlIGlmIGB0cmFjZUlkYCBpcyB0aGUgc2FtZVxuICAvLyBOb3RlIGZvciB0ZXN0aW5nOiBgaXNTcGFuQ29udGV4dFZhbGlkKClgIGNoZWNrcyB0aGUgZm9ybWF0IG9mIHRoZSB0cmFjZUlkL3NwYW5JZCwgc28gd2UgbmVlZCB0byBwYXNzIHZhbGlkIG9uZXNcbiAgaWYgKGFwaS5pc1NwYW5Db250ZXh0VmFsaWQocGFyZW50Q29udGV4dCkgJiYgcGFyZW50Q29udGV4dC50cmFjZUlkID09PSB0cmFjZUlkKSB7XG4gICAgaWYgKHBhcmVudENvbnRleHQuaXNSZW1vdGUpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBnZXRQYXJlbnRSZW1vdGVTYW1wbGVkKHBhcmVudFNwYW4pO1xuICAgICAgREVCVUdfQlVJTEQgJiZcbiAgICAgICAgdXRpbHMubG9nZ2VyLmxvZyhgW1RyYWNpbmddIEluaGVyaXRpbmcgcmVtb3RlIHBhcmVudCdzIHNhbXBsZWQgZGVjaXNpb24gZm9yICR7c3Bhbk5hbWV9OiAke3BhcmVudFNhbXBsZWR9YCk7XG4gICAgICByZXR1cm4gcGFyZW50U2FtcGxlZDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnRTYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihwYXJlbnRDb250ZXh0KTtcbiAgICBERUJVR19CVUlMRCAmJiB1dGlscy5sb2dnZXIubG9nKGBbVHJhY2luZ10gSW5oZXJpdGluZyBwYXJlbnQncyBzYW1wbGVkIGRlY2lzaW9uIGZvciAke3NwYW5OYW1lfTogJHtwYXJlbnRTYW1wbGVkfWApO1xuICAgIHJldHVybiBwYXJlbnRTYW1wbGVkO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBXcmFwIGEgc2FtcGxpbmcgZGVjaXNpb24gd2l0aCBkYXRhIHRoYXQgU2VudHJ5IG5lZWRzIHRvIHdvcmsgcHJvcGVybHkgd2l0aCBpdC5cbiAqIElmIHlvdSBwYXNzIGBkZWNpc2lvbjogdW5kZWZpbmVkYCwgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGBOT1RfUkVDT1JESU5HYCwgYnV0IGluIGNvbnRyYXN0IHRvIHBhc3NpbmcgYE5PVF9SRUNPUkRJTkdgXG4gKiBpdCB3aWxsIG5vdCBwcm9wYWdhdGUgdGhpcyBkZWNpc2lvbiB0byBkb3duc3RyZWFtIFNlbnRyeSBTREtzLlxuICovXG5mdW5jdGlvbiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7XG4gIGRlY2lzaW9uLFxuICBjb250ZXh0LFxuICBzcGFuQXR0cmlidXRlcyxcbn0pIHtcbiAgY29uc3QgdHJhY2VTdGF0ZSA9IGdldEJhc2VUcmFjZVN0YXRlKGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzKTtcblxuICAvLyBJZiB0aGUgZGVjaXNpb24gaXMgdW5kZWZpbmVkLCB3ZSB0cmVhdCBpdCBhcyBOT1RfUkVDT1JESU5HLCBidXQgd2UgZG9uJ3QgcHJvcGFnYXRlIHRoaXMgZGVjaXNpb24gdG8gZG93bnN0cmVhbSBTREtzXG4gIC8vIFdoaWNoIGlzIGRvbmUgYnkgbm90IHNldHRpbmcgYFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkdgIHRyYWNlU3RhdGVcbiAgaWYgKGRlY2lzaW9uID09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7IGRlY2lzaW9uOiBzZGtUcmFjZUJhc2UuU2FtcGxpbmdEZWNpc2lvbi5OT1RfUkVDT1JELCB0cmFjZVN0YXRlIH07XG4gIH1cblxuICBpZiAoZGVjaXNpb24gPT09IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQpIHtcbiAgICByZXR1cm4geyBkZWNpc2lvbiwgdHJhY2VTdGF0ZTogdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORywgJzEnKSB9O1xuICB9XG5cbiAgcmV0dXJuIHsgZGVjaXNpb24sIHRyYWNlU3RhdGUgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QmFzZVRyYWNlU3RhdGUoY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuICBjb25zdCBwYXJlbnRDb250ZXh0ID0gX29wdGlvbmFsQ2hhaW4oW3BhcmVudFNwYW4sICdvcHRpb25hbEFjY2VzcycsIF80ID0+IF80LnNwYW5Db250ZXh0LCAnY2FsbCcsIF81ID0+IF81KCldKTtcblxuICBsZXQgdHJhY2VTdGF0ZSA9IF9vcHRpb25hbENoYWluKFtwYXJlbnRDb250ZXh0LCAnb3B0aW9uYWxBY2Nlc3MnLCBfNiA9PiBfNi50cmFjZVN0YXRlXSkgfHwgbmV3IGNvcmUkMS5UcmFjZVN0YXRlKCk7XG5cbiAgLy8gV2UgYWx3YXlzIGtlZXAgdGhlIFVSTCBvbiB0aGUgdHJhY2Ugc3RhdGUsIHNvIHdlIGNhbiBhY2Nlc3MgaXQgaW4gdGhlIHByb3BhZ2F0b3JcbiAgY29uc3QgdXJsID0gc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1VSTF07XG4gIGlmICh1cmwgJiYgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cmFjZVN0YXRlID0gdHJhY2VTdGF0ZS5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1VSTCwgdXJsKTtcbiAgfVxuXG4gIHJldHVybiB0cmFjZVN0YXRlO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHRha2VzIGFuIE9wZW5UZWxlbWV0cnkgaW5zdHJ1bWVudGF0aW9uIG9yXG4gKiBhcnJheSBvZiBpbnN0cnVtZW50YXRpb25zIGFuZCByZWdpc3RlcnMgdGhlbSB3aXRoIE9wZW5UZWxlbWV0cnkuXG4gKi9cbmZ1bmN0aW9uIGFkZE9wZW5UZWxlbWV0cnlJbnN0cnVtZW50YXRpb24oLi4uaW5zdHJ1bWVudGF0aW9ucykge1xuICBpbnN0cnVtZW50YXRpb24ucmVnaXN0ZXJJbnN0cnVtZW50YXRpb25zKHtcbiAgICBpbnN0cnVtZW50YXRpb25zLFxuICB9KTtcbn1cblxuZXhwb3J0cy5nZXRDbGllbnQgPSBjb3JlLmdldENsaWVudDtcbmV4cG9ydHMuZ2V0Q3VycmVudEh1YlNoaW0gPSBjb3JlLmdldEN1cnJlbnRIdWJTaGltO1xuZXhwb3J0cy5nZXREeW5hbWljU2FtcGxpbmdDb250ZXh0RnJvbVNwYW4gPSBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbjtcbmV4cG9ydHMuU2VudHJ5UHJvcGFnYXRvciA9IFNlbnRyeVByb3BhZ2F0b3I7XG5leHBvcnRzLlNlbnRyeVNhbXBsZXIgPSBTZW50cnlTYW1wbGVyO1xuZXhwb3J0cy5TZW50cnlTcGFuUHJvY2Vzc29yID0gU2VudHJ5U3BhblByb2Nlc3NvcjtcbmV4cG9ydHMuYWRkT3BlblRlbGVtZXRyeUluc3RydW1lbnRhdGlvbiA9IGFkZE9wZW5UZWxlbWV0cnlJbnN0cnVtZW50YXRpb247XG5leHBvcnRzLmNvbnRpbnVlVHJhY2UgPSBjb250aW51ZVRyYWNlO1xuZXhwb3J0cy5lbmhhbmNlRHNjV2l0aE9wZW5UZWxlbWV0cnlSb290U3Bhbk5hbWUgPSBlbmhhbmNlRHNjV2l0aE9wZW5UZWxlbWV0cnlSb290U3Bhbk5hbWU7XG5leHBvcnRzLmdldEFjdGl2ZVNwYW4gPSBnZXRBY3RpdmVTcGFuO1xuZXhwb3J0cy5nZXRSZXF1ZXN0U3BhbkRhdGEgPSBnZXRSZXF1ZXN0U3BhbkRhdGE7XG5leHBvcnRzLmdldFNjb3Blc0Zyb21Db250ZXh0ID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQ7XG5leHBvcnRzLmdldFNwYW5LaW5kID0gZ2V0U3BhbktpbmQ7XG5leHBvcnRzLmlzU2VudHJ5UmVxdWVzdFNwYW4gPSBpc1NlbnRyeVJlcXVlc3RTcGFuO1xuZXhwb3J0cy5vcGVuVGVsZW1ldHJ5U2V0dXBDaGVjayA9IG9wZW5UZWxlbWV0cnlTZXR1cENoZWNrO1xuZXhwb3J0cy5zZXRPcGVuVGVsZW1ldHJ5Q29udGV4dEFzeW5jQ29udGV4dFN0cmF0ZWd5ID0gc2V0T3BlblRlbGVtZXRyeUNvbnRleHRBc3luY0NvbnRleHRTdHJhdGVneTtcbmV4cG9ydHMuc2V0dXBFdmVudENvbnRleHRUcmFjZSA9IHNldHVwRXZlbnRDb250ZXh0VHJhY2U7XG5leHBvcnRzLnNwYW5IYXNBdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXM7XG5leHBvcnRzLnNwYW5IYXNFdmVudHMgPSBzcGFuSGFzRXZlbnRzO1xuZXhwb3J0cy5zcGFuSGFzS2luZCA9IHNwYW5IYXNLaW5kO1xuZXhwb3J0cy5zcGFuSGFzTmFtZSA9IHNwYW5IYXNOYW1lO1xuZXhwb3J0cy5zcGFuSGFzUGFyZW50SWQgPSBzcGFuSGFzUGFyZW50SWQ7XG5leHBvcnRzLnNwYW5IYXNTdGF0dXMgPSBzcGFuSGFzU3RhdHVzO1xuZXhwb3J0cy5zdGFydEluYWN0aXZlU3BhbiA9IHN0YXJ0SW5hY3RpdmVTcGFuO1xuZXhwb3J0cy5zdGFydFNwYW4gPSBzdGFydFNwYW47XG5leHBvcnRzLnN0YXJ0U3Bhbk1hbnVhbCA9IHN0YXJ0U3Bhbk1hbnVhbDtcbmV4cG9ydHMuc3VwcHJlc3NUcmFjaW5nID0gc3VwcHJlc3NUcmFjaW5nO1xuZXhwb3J0cy53aXRoQWN0aXZlU3BhbiA9IHdpdGhBY3RpdmVTcGFuO1xuZXhwb3J0cy53cmFwQ2xpZW50Q2xhc3MgPSB3cmFwQ2xpZW50Q2xhc3M7XG5leHBvcnRzLndyYXBDb250ZXh0TWFuYWdlckNsYXNzID0gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3M7XG5leHBvcnRzLndyYXBTYW1wbGluZ0RlY2lzaW9uID0gd3JhcFNhbXBsaW5nRGVjaXNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js":
/*!***********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js ***!
  \***********************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var {\n  _optionalChain\n} = __webpack_require__(/*! @sentry/utils */ \"(rsc)/./node_modules/.pnpm/@sentry+utils@8.17.0/node_modules/@sentry/utils/build/cjs/index.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nconst semanticConventions = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+semantic-conventions@1.25.1/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst utils = __webpack_require__(/*! @sentry/utils */ \"(rsc)/./node_modules/.pnpm/@sentry+utils@8.17.0/node_modules/@sentry/utils/build/cjs/index.js\");\nconst api = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js\");\nconst core = __webpack_require__(/*! @sentry/core */ \"(rsc)/./node_modules/.pnpm/@sentry+core@8.17.0/node_modules/@sentry/core/build/cjs/index.js\");\nconst core$1 = __webpack_require__(/*! @opentelemetry/core */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+core@1.25.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js\");\nconst sdkTraceBase = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+sdk-trace-base@1.25.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nconst instrumentation = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/./node_modules/.pnpm/@opentelemetry+instrumentation@0.52.1_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\n\n/**\n * Check if a given span has attributes.\n * This is necessary because the base `Span` type does not have attributes,\n * so in places where we are passed a generic span, we need to check if we want to access them.\n */\nfunction spanHasAttributes(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.attributes && typeof castSpan.attributes === 'object';\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasKind(span) {\n  const castSpan = span ;\n  return !!castSpan.kind;\n}\n\n/**\n * Check if a given span has a status.\n * This is necessary because the base `Span` type does not have a status,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasStatus(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.status;\n}\n\n/**\n * Check if a given span has a name.\n * This is necessary because the base `Span` type does not have a name,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasName(span) {\n  const castSpan = span ;\n  return !!castSpan.name;\n}\n\n/**\n * Check if a given span has a kind.\n * This is necessary because the base `Span` type does not have a kind,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasParentId(\n  span,\n) {\n  const castSpan = span ;\n  return !!castSpan.parentSpanId;\n}\n\n/**\n * Check if a given span has events.\n * This is necessary because the base `Span` type does not have events,\n * so in places where we are passed a generic span, we need to check if we want to access it.\n */\nfunction spanHasEvents(\n  span,\n) {\n  const castSpan = span ;\n  return Array.isArray(castSpan.events);\n}\n\n/**\n * Get sanitizied request data from an OTEL span.\n */\nfunction getRequestSpanData(span) {\n  // The base `Span` type has no `attributes`, so we need to guard here against that\n  if (!spanHasAttributes(span)) {\n    return {};\n  }\n\n  const data = {\n    url: span.attributes[semanticConventions.SEMATTRS_HTTP_URL] ,\n    'http.method': span.attributes[semanticConventions.SEMATTRS_HTTP_METHOD] ,\n  };\n\n  // Default to GET if URL is set but method is not\n  if (!data['http.method'] && data.url) {\n    data['http.method'] = 'GET';\n  }\n\n  try {\n    const urlStr = span.attributes[semanticConventions.SEMATTRS_HTTP_URL];\n    if (typeof urlStr === 'string') {\n      const url = utils.parseUrl(urlStr);\n\n      data.url = utils.getSanitizedUrlString(url);\n\n      if (url.search) {\n        data['http.query'] = url.search;\n      }\n      if (url.hash) {\n        data['http.fragment'] = url.hash;\n      }\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  return data;\n}\n\nfunction _optionalChain$8(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n// Typescript complains if we do not use `...args: any[]` for the mixin, with:\n// A mixin class must have a constructor with a single rest parameter of type 'any[]'.ts(2545)\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Wrap an Client with things we need for OpenTelemetry support.\n *\n * Usage:\n * const OpenTelemetryClient = getWrappedClientClass(NodeClient);\n * const client = new OpenTelemetryClient(options);\n */\nfunction wrapClientClass\n\n(ClientClass) {\n  class OpenTelemetryClient extends ClientClass  {\n\n     constructor(...args) {\n      super(...args);\n    }\n\n    /** Get the OTEL tracer. */\n     get tracer() {\n      if (this._tracer) {\n        return this._tracer;\n      }\n\n      const name = '@sentry/opentelemetry';\n      const version = core.SDK_VERSION;\n      const tracer = api.trace.getTracer(name, version);\n      this._tracer = tracer;\n\n      return tracer;\n    }\n\n    /**\n     * @inheritDoc\n     */\n     async flush(timeout) {\n      const provider = this.traceProvider;\n      const spanProcessor = _optionalChain$8([provider, 'optionalAccess', _ => _.activeSpanProcessor]);\n\n      if (spanProcessor) {\n        await spanProcessor.forceFlush();\n      }\n\n      return super.flush(timeout);\n    }\n  }\n\n  return OpenTelemetryClient ;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * Get the span kind from a span.\n * For whatever reason, this is not public API on the generic \"Span\" type,\n * so we need to check if we actually have a `SDKTraceBaseSpan` where we can fetch this from.\n * Otherwise, we fall back to `SpanKind.INTERNAL`.\n */\nfunction getSpanKind(span) {\n  if (spanHasKind(span)) {\n    return span.kind;\n  }\n\n  return api.SpanKind.INTERNAL;\n}\n\nconst SENTRY_TRACE_HEADER = 'sentry-trace';\nconst SENTRY_BAGGAGE_HEADER = 'baggage';\n\nconst SENTRY_TRACE_STATE_DSC = 'sentry.dsc';\nconst SENTRY_TRACE_STATE_PARENT_SPAN_ID = 'sentry.parent_span_id';\nconst SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING = 'sentry.sampled_not_recording';\nconst SENTRY_TRACE_STATE_URL = 'sentry.url';\n\nconst SENTRY_SCOPES_CONTEXT_KEY = api.createContextKey('sentry_scopes');\n\nconst SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_isolation_scope');\n\nconst SENTRY_FORK_SET_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_scope');\n\nconst SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY = api.createContextKey('sentry_fork_set_isolation_scope');\n\nconst SCOPE_CONTEXT_FIELD = '_scopeContext';\n\n/**\n * Try to get the current scopes from the given OTEL context.\n * This requires a Context Manager that was wrapped with getWrappedContextManager.\n */\nfunction getScopesFromContext(context) {\n  return context.getValue(SENTRY_SCOPES_CONTEXT_KEY) ;\n}\n\n/**\n * Set the current scopes on an OTEL context.\n * This will return a forked context with the Propagation Context set.\n */\nfunction setScopesOnContext(context, scopes) {\n  return context.setValue(SENTRY_SCOPES_CONTEXT_KEY, scopes);\n}\n\n/**\n * Set the context on the scope so we can later look it up.\n * We need this to get the context from the scope in the `trace` functions.\n */\nfunction setContextOnScope(scope, context) {\n  utils.addNonEnumerableProperty(scope, SCOPE_CONTEXT_FIELD, context);\n}\n\n/**\n * Get the context related to a scope.\n * TODO v8: Use this for the `trace` functions.\n * */\nfunction getContextFromScope(scope) {\n  return (scope )[SCOPE_CONTEXT_FIELD];\n}\n\n/**\n *\n * @param otelSpan Checks wheter a given OTEL Span is an http request to sentry.\n * @returns boolean\n */\nfunction isSentryRequestSpan(span) {\n  if (!spanHasAttributes(span)) {\n    return false;\n  }\n\n  const { attributes } = span;\n\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];\n\n  if (!httpUrl) {\n    return false;\n  }\n\n  return core.isSentryRequestUrl(httpUrl.toString(), core.getClient());\n}\n\n/**\n * Extract better op/description from an otel span.\n *\n * Based on https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/7422ce2a06337f68a59b552b8c5a2ac125d6bae5/exporter/sentryexporter/sentry_exporter.go#L306\n */\nfunction parseSpanDescription(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const name = spanHasName(span) ? span.name : '<unknown>';\n\n  // This attribute is intentionally exported as a SEMATTR constant because it should stay intimite API\n  if (attributes['sentry.skip_span_data_inference']) {\n    return {\n      op: undefined,\n      description: name,\n      source: 'custom',\n      data: {\n        // Suggest to callers of `parseSpanDescription` to wipe the hint because it is unnecessary data in the end.\n        'sentry.skip_span_data_inference': undefined,\n      },\n    };\n  }\n\n  // if http.method exists, this is an http request span\n  //\n  // TODO: Referencing `http.request.method` is a temporary workaround until the semantic\n  // conventions export an attribute key for it.\n  const httpMethod = attributes['http.request.method'] || attributes[semanticConventions.SEMATTRS_HTTP_METHOD];\n  if (httpMethod) {\n    return descriptionForHttpMethod({ attributes, name, kind: getSpanKind(span) }, httpMethod);\n  }\n\n  const dbSystem = attributes[semanticConventions.SEMATTRS_DB_SYSTEM];\n  const opIsCache =\n    typeof attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] === 'string' &&\n    attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP].startsWith('cache.');\n\n  // If db.type exists then this is a database call span\n  // If the Redis DB is used as a cache, the span description should not be changed\n  if (dbSystem && !opIsCache) {\n    return descriptionForDbSystem({ attributes, name });\n  }\n\n  // If rpc.service exists then this is a rpc call span.\n  const rpcService = attributes[semanticConventions.SEMATTRS_RPC_SERVICE];\n  if (rpcService) {\n    return {\n      op: 'rpc',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If messaging.system exists then this is a messaging system span.\n  const messagingSystem = attributes[semanticConventions.SEMATTRS_MESSAGING_SYSTEM];\n  if (messagingSystem) {\n    return {\n      op: 'message',\n      description: name,\n      source: 'route',\n    };\n  }\n\n  // If faas.trigger exists then this is a function as a service span.\n  const faasTrigger = attributes[semanticConventions.SEMATTRS_FAAS_TRIGGER];\n  if (faasTrigger) {\n    return { op: faasTrigger.toString(), description: name, source: 'route' };\n  }\n\n  return { op: undefined, description: name, source: 'custom' };\n}\n\nfunction descriptionForDbSystem({ attributes, name }) {\n  // Use DB statement (Ex \"SELECT * FROM table\") if possible as description.\n  const statement = attributes[semanticConventions.SEMATTRS_DB_STATEMENT];\n\n  const description = statement ? statement.toString() : name;\n\n  return { op: 'db', description, source: 'task' };\n}\n\n/** Only exported for tests. */\nfunction descriptionForHttpMethod(\n  { name, kind, attributes },\n  httpMethod,\n) {\n  const opParts = ['http'];\n\n  switch (kind) {\n    case api.SpanKind.CLIENT:\n      opParts.push('client');\n      break;\n    case api.SpanKind.SERVER:\n      opParts.push('server');\n      break;\n  }\n\n  const { urlPath, url, query, fragment, hasRoute } = getSanitizedUrl(attributes, kind);\n\n  if (!urlPath) {\n    return { op: opParts.join('.'), description: name, source: 'custom' };\n  }\n\n  // Ex. description=\"GET /api/users\".\n  const description = `${httpMethod} ${urlPath}`;\n\n  // If `httpPath` is a root path, then we can categorize the transaction source as route.\n  const source = hasRoute || urlPath === '/' ? 'route' : 'url';\n\n  const data = {};\n\n  if (url) {\n    data.url = url;\n  }\n  if (query) {\n    data['http.query'] = query;\n  }\n  if (fragment) {\n    data['http.fragment'] = fragment;\n  }\n\n  return {\n    op: opParts.join('.'),\n    description,\n    source,\n    data,\n  };\n}\n\n/** Exported for tests only */\nfunction getSanitizedUrl(\n  attributes,\n  kind,\n)\n\n {\n  // This is the relative path of the URL, e.g. /sub\n  const httpTarget = attributes[semanticConventions.SEMATTRS_HTTP_TARGET];\n  // This is the full URL, including host & query params etc., e.g. https://example.com/sub?foo=bar\n  const httpUrl = attributes[semanticConventions.SEMATTRS_HTTP_URL];\n  // This is the normalized route name - may not always be available!\n  const httpRoute = attributes[semanticConventions.SEMATTRS_HTTP_ROUTE];\n\n  const parsedUrl = typeof httpUrl === 'string' ? utils.parseUrl(httpUrl) : undefined;\n  const url = parsedUrl ? utils.getSanitizedUrlString(parsedUrl) : undefined;\n  const query = parsedUrl && parsedUrl.search ? parsedUrl.search : undefined;\n  const fragment = parsedUrl && parsedUrl.hash ? parsedUrl.hash : undefined;\n\n  if (typeof httpRoute === 'string') {\n    return { urlPath: httpRoute, url, query, fragment, hasRoute: true };\n  }\n\n  if (kind === api.SpanKind.SERVER && typeof httpTarget === 'string') {\n    return { urlPath: utils.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  if (parsedUrl) {\n    return { urlPath: url, url, query, fragment, hasRoute: false };\n  }\n\n  // fall back to target even for client spans, if no URL is present\n  if (typeof httpTarget === 'string') {\n    return { urlPath: utils.stripUrlQueryAndFragment(httpTarget), url, query, fragment, hasRoute: false };\n  }\n\n  return { urlPath: undefined, url, query, fragment, hasRoute: false };\n}\n\n/**\n * Setup a DSC handler on the passed client,\n * ensuring that the transaction name is inferred from the span correctly.\n */\nfunction enhanceDscWithOpenTelemetryRootSpanName(client) {\n  client.on('createDsc', (dsc, rootSpan) => {\n    // We want to overwrite the transaction on the DSC that is created by default in core\n    // The reason for this is that we want to infer the span name, not use the initial one\n    // Otherwise, we'll get names like \"GET\" instead of e.g. \"GET /foo\"\n    // `parseSpanDescription` takes the attributes of the span into account for the name\n    // This mutates the passed-in DSC\n    if (rootSpan) {\n      const jsonSpan = core.spanToJSON(rootSpan);\n      const attributes = jsonSpan.data || {};\n      const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n      const { description } = spanHasName(rootSpan) ? parseSpanDescription(rootSpan) : { description: undefined };\n      if (source !== 'url' && description) {\n        dsc.transaction = description;\n      }\n    }\n  });\n}\n\n/**\n * Returns the currently active span.\n */\nfunction getActiveSpan() {\n  return api.trace.getActiveSpan();\n}\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nconst DEBUG_BUILD = ( false || false);\n\nfunction _optionalChain$7(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * OpenTelemetry only knows about SAMPLED or NONE decision,\n * but for us it is important to differentiate between unset and unsampled.\n *\n * Both of these are identified as `traceFlags === TracegFlags.NONE`,\n * but we additionally look at a special trace state to differentiate between them.\n */\nfunction getSamplingDecision(spanContext) {\n  const { traceFlags, traceState } = spanContext;\n\n  const sampledNotRecording = traceState ? traceState.get(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING) === '1' : false;\n\n  // If trace flag is `SAMPLED`, we interpret this as sampled\n  // If it is `NONE`, it could mean either it was sampled to be not recorder, or that it was not sampled at all\n  // For us this is an important difference, sow e look at the SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING\n  // to identify which it is\n  if (traceFlags === api.TraceFlags.SAMPLED) {\n    return true;\n  }\n\n  if (sampledNotRecording) {\n    return false;\n  }\n\n  // Fall back to DSC as a last resort, that may also contain `sampled`...\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const dsc = dscString ? utils.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  if (_optionalChain$7([dsc, 'optionalAccess', _ => _.sampled]) === 'true') {\n    return true;\n  }\n  if (_optionalChain$7([dsc, 'optionalAccess', _2 => _2.sampled]) === 'false') {\n    return false;\n  }\n\n  return undefined;\n}\n\nconst setupElements = new Set();\n\n/** Get all the OpenTelemetry elements that have been set up. */\nfunction openTelemetrySetupCheck() {\n  return Array.from(setupElements);\n}\n\n/** Mark an OpenTelemetry element as setup. */\nfunction setIsSetup(element) {\n  setupElements.add(element);\n}\n\nfunction _optionalChain$6(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/** Get the Sentry propagation context from a span context. */\nfunction getPropagationContextFromSpan(span) {\n  const spanContext = span.spanContext();\n  const { traceId, spanId, traceState } = spanContext;\n\n  // When we have a dsc trace state, it means this came from the incoming trace\n  // Then this takes presedence over the root span\n  const dscString = traceState ? traceState.get(SENTRY_TRACE_STATE_DSC) : undefined;\n  const traceStateDsc = dscString ? utils.baggageHeaderToDynamicSamplingContext(dscString) : undefined;\n\n  const parentSpanId = traceState ? traceState.get(SENTRY_TRACE_STATE_PARENT_SPAN_ID) || undefined : undefined;\n\n  const sampled = getSamplingDecision(spanContext);\n\n  // No trace state? --> Take DSC from root span\n  const dsc = traceStateDsc || core.getDynamicSamplingContextFromSpan(core.getRootSpan(span));\n\n  return {\n    traceId,\n    spanId,\n    sampled,\n    parentSpanId,\n    dsc,\n  };\n}\n\n/**\n * Injects and extracts `sentry-trace` and `baggage` headers from carriers.\n */\nclass SentryPropagator extends core$1.W3CBaggagePropagator {\n  /** A map of URLs that have already been checked for if they match tracePropagationTargets. */\n\n   constructor() {\n    super();\n    setIsSetup('SentryPropagator');\n\n    // We're caching results so we don't have to recompute regexp every time we create a request.\n    this._urlMatchesTargetsMap = new utils.LRUMap(100);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   inject(context, carrier, setter) {\n    if (core$1.isTracingSuppressed(context)) {\n      DEBUG_BUILD && utils.logger.log('[Tracing] Not injecting trace data for url because tracing is suppressed.');\n      return;\n    }\n\n    const activeSpan = api.trace.getSpan(context);\n    const url = activeSpan && getCurrentURL(activeSpan);\n\n    const tracePropagationTargets = _optionalChain$6([core.getClient, 'call', _ => _(), 'optionalAccess', _2 => _2.getOptions, 'call', _3 => _3(), 'optionalAccess', _4 => _4.tracePropagationTargets]);\n    if (\n      typeof url === 'string' &&\n      tracePropagationTargets &&\n      !this._shouldInjectTraceData(tracePropagationTargets, url)\n    ) {\n      DEBUG_BUILD &&\n        utils.logger.log(\n          '[Tracing] Not injecting trace data for url because it does not match tracePropagationTargets:',\n          url,\n        );\n      return;\n    }\n\n    const existingBaggageHeader = getExistingBaggage(carrier);\n    let baggage = api.propagation.getBaggage(context) || api.propagation.createBaggage({});\n\n    const { dynamicSamplingContext, traceId, spanId, sampled } = getInjectionData(context);\n\n    if (existingBaggageHeader) {\n      const baggageEntries = utils.parseBaggageHeader(existingBaggageHeader);\n\n      if (baggageEntries) {\n        Object.entries(baggageEntries).forEach(([key, value]) => {\n          baggage = baggage.setEntry(key, { value });\n        });\n      }\n    }\n\n    if (dynamicSamplingContext) {\n      baggage = Object.entries(dynamicSamplingContext).reduce((b, [dscKey, dscValue]) => {\n        if (dscValue) {\n          return b.setEntry(`${utils.SENTRY_BAGGAGE_KEY_PREFIX}${dscKey}`, { value: dscValue });\n        }\n        return b;\n      }, baggage);\n    }\n\n    // We also want to avoid setting the default OTEL trace ID, if we get that for whatever reason\n    if (traceId && traceId !== api.INVALID_TRACEID) {\n      setter.set(carrier, SENTRY_TRACE_HEADER, utils.generateSentryTraceHeader(traceId, spanId, sampled));\n    }\n\n    super.inject(api.propagation.setBaggage(context, baggage), carrier, setter);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   extract(context, carrier, getter) {\n    const maybeSentryTraceHeader = getter.get(carrier, SENTRY_TRACE_HEADER);\n    const baggage = getter.get(carrier, SENTRY_BAGGAGE_HEADER);\n\n    const sentryTrace = maybeSentryTraceHeader\n      ? Array.isArray(maybeSentryTraceHeader)\n        ? maybeSentryTraceHeader[0]\n        : maybeSentryTraceHeader\n      : undefined;\n\n    const propagationContext = utils.propagationContextFromHeaders(sentryTrace, baggage);\n\n    // Add remote parent span context\n    const ctxWithSpanContext = getContextWithRemoteActiveSpan(context, { sentryTrace, baggage });\n\n    // Also update the scope on the context (to be sure this is picked up everywhere)\n    const scopes = getScopesFromContext(ctxWithSpanContext);\n    const newScopes = {\n      scope: scopes ? scopes.scope.clone() : core.getCurrentScope().clone(),\n      isolationScope: scopes ? scopes.isolationScope : core.getIsolationScope(),\n    };\n    newScopes.scope.setPropagationContext(propagationContext);\n\n    return setScopesOnContext(ctxWithSpanContext, newScopes);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   fields() {\n    return [SENTRY_TRACE_HEADER, SENTRY_BAGGAGE_HEADER];\n  }\n\n  /** If we want to inject trace data for a given URL. */\n   _shouldInjectTraceData(tracePropagationTargets, url) {\n    if (tracePropagationTargets === undefined) {\n      return true;\n    }\n\n    const cachedDecision = this._urlMatchesTargetsMap.get(url);\n    if (cachedDecision !== undefined) {\n      return cachedDecision;\n    }\n\n    const decision = utils.stringMatchesSomePattern(url, tracePropagationTargets);\n    this._urlMatchesTargetsMap.set(url, decision);\n    return decision;\n  }\n}\n\n/** Exported for tests. */\nfunction makeTraceState({\n  parentSpanId,\n  dsc,\n  sampled,\n}\n\n) {\n  // We store the DSC as OTEL trace state on the span context\n  const dscString = dsc ? utils.dynamicSamplingContextToSentryBaggageHeader(dsc) : undefined;\n\n  // We _always_ set the parent span ID, even if it is empty\n  // If we'd set this to 'undefined' we could not know if the trace state was set, but there was no parentSpanId,\n  // vs the trace state was not set at all (in which case we want to do fallback handling)\n  // If `''`, it should be considered \"no parent\"\n  const traceStateBase = new core$1.TraceState().set(SENTRY_TRACE_STATE_PARENT_SPAN_ID, parentSpanId || '');\n\n  const traceStateWithDsc = dscString ? traceStateBase.set(SENTRY_TRACE_STATE_DSC, dscString) : traceStateBase;\n\n  // We also specifically want to store if this is sampled to be not recording,\n  // or unsampled (=could be either sampled or not)\n  return sampled === false ? traceStateWithDsc.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') : traceStateWithDsc;\n}\n\nfunction getInjectionData(context)\n\n {\n  const span = core.hasTracingEnabled() ? api.trace.getSpan(context) : undefined;\n  const spanIsRemote = _optionalChain$6([span, 'optionalAccess', _5 => _5.spanContext, 'call', _6 => _6(), 'access', _7 => _7.isRemote]);\n\n  // If we have a local span, we can just pick everything from it\n  if (span && !spanIsRemote) {\n    const spanContext = span.spanContext();\n\n    const propagationContext = getPropagationContextFromSpan(span);\n    const dynamicSamplingContext = getDynamicSamplingContext(propagationContext, spanContext.traceId);\n    return {\n      dynamicSamplingContext,\n      traceId: spanContext.traceId,\n      spanId: spanContext.spanId,\n      sampled: getSamplingDecision(spanContext),\n    };\n  }\n\n  // Else we try to use the propagation context from the scope\n  const scope = _optionalChain$6([getScopesFromContext, 'call', _8 => _8(context), 'optionalAccess', _9 => _9.scope]) || core.getCurrentScope();\n\n  const propagationContext = scope.getPropagationContext();\n  const dynamicSamplingContext = getDynamicSamplingContext(propagationContext, propagationContext.traceId);\n  return {\n    dynamicSamplingContext,\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.spanId,\n    sampled: propagationContext.sampled,\n  };\n}\n\n/** Get the DSC from a context, or fall back to use the one from the client. */\nfunction getDynamicSamplingContext(\n  propagationContext,\n  traceId,\n) {\n  // If we have a DSC on the propagation context, we just use it\n  if (_optionalChain$6([propagationContext, 'optionalAccess', _10 => _10.dsc])) {\n    return propagationContext.dsc;\n  }\n\n  // Else, we try to generate a new one\n  const client = core.getClient();\n\n  if (client) {\n    return core.getDynamicSamplingContextFromClient(traceId || propagationContext.traceId, client);\n  }\n\n  return undefined;\n}\n\nfunction getContextWithRemoteActiveSpan(\n  ctx,\n  { sentryTrace, baggage },\n) {\n  const propagationContext = utils.propagationContextFromHeaders(sentryTrace, baggage);\n\n  // We store the DSC as OTEL trace state on the span context\n  const traceState = makeTraceState({\n    parentSpanId: propagationContext.parentSpanId,\n    dsc: propagationContext.dsc,\n    sampled: propagationContext.sampled,\n  });\n\n  const spanContext = {\n    traceId: propagationContext.traceId,\n    spanId: propagationContext.parentSpanId || '',\n    isRemote: true,\n    traceFlags: propagationContext.sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  return api.trace.setSpanContext(ctx, spanContext);\n}\n\n/**\n * Takes trace strings and propagates them as a remote active span.\n * This should be used in addition to `continueTrace` in OTEL-powered environments.\n */\nfunction continueTraceAsRemoteSpan(\n  ctx,\n  options,\n  callback,\n) {\n  const ctxWithSpanContext = getContextWithRemoteActiveSpan(ctx, options);\n\n  return api.context.with(ctxWithSpanContext, callback);\n}\n\n/** Try to get the existing baggage header so we can merge this in. */\nfunction getExistingBaggage(carrier) {\n  try {\n    const baggage = (carrier )[SENTRY_BAGGAGE_HEADER];\n    return Array.isArray(baggage) ? baggage.join(',') : baggage;\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * It is pretty tricky to get access to the outgoing request URL of a request in the propagator.\n * As we only have access to the context of the span to be sent and the carrier (=headers),\n * but the span may be unsampled and thus have no attributes.\n *\n * So we use the following logic:\n * 1. If we have an active span, we check if it has a URL attribute.\n * 2. Else, if the active span has no URL attribute (e.g. it is unsampled), we check a special trace state (which we set in our sampler).\n */\nfunction getCurrentURL(span) {\n  const urlAttribute = _optionalChain$6([core.spanToJSON, 'call', _11 => _11(span), 'access', _12 => _12.data, 'optionalAccess', _13 => _13[semanticConventions.SEMATTRS_HTTP_URL]]);\n  if (urlAttribute) {\n    return urlAttribute;\n  }\n\n  // Also look at the traceState, which we may set in the sampler even for unsampled spans\n  const urlTraceState = _optionalChain$6([span, 'access', _14 => _14.spanContext, 'call', _15 => _15(), 'access', _16 => _16.traceState, 'optionalAccess', _17 => _17.get, 'call', _18 => _18(SENTRY_TRACE_STATE_URL)]);\n  if (urlTraceState) {\n    return urlTraceState;\n  }\n\n  return undefined;\n}\n\nfunction _optionalChain$5(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpan(options, callback) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      _applySentryAttributesToSpan(span, options);\n\n      return core.handleCallbackErrors(\n        () => callback(span),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n        () => span.end(),\n      );\n    });\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startSpanManual(\n  options,\n  callback,\n) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    return tracer.startActiveSpan(name, spanOptions, ctx, span => {\n      _applySentryAttributesToSpan(span, options);\n\n      return core.handleCallbackErrors(\n        () => callback(span, () => span.end()),\n        () => {\n          // Only set the span status to ERROR when there wasn't any status set before, in order to avoid stomping useful span statuses\n          if (core.spanToJSON(span).status === undefined) {\n            span.setStatus({ code: api.SpanStatusCode.ERROR });\n          }\n        },\n      );\n    });\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nfunction startInactiveSpan(options) {\n  const tracer = getTracer();\n\n  const { name, parentSpan: customParentSpan } = options;\n\n  // If `options.parentSpan` is defined, we want to wrap the callback in `withActiveSpan`\n  const wrapper = getActiveSpanWrapper(customParentSpan);\n\n  return wrapper(() => {\n    const activeCtx = getContext(options.scope, options.forceTransaction);\n    const shouldSkipSpan = options.onlyIfParent && !api.trace.getSpan(activeCtx);\n    const ctx = shouldSkipSpan ? core$1.suppressTracing(activeCtx) : activeCtx;\n\n    const spanOptions = getSpanOptions(options);\n\n    const span = tracer.startSpan(name, spanOptions, ctx);\n\n    _applySentryAttributesToSpan(span, options);\n\n    return span;\n  });\n}\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will be root spans.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nfunction withActiveSpan(span, callback) {\n  const newContextWithActiveSpan = span ? api.trace.setSpan(api.context.active(), span) : api.trace.deleteSpan(api.context.active());\n  return api.context.with(newContextWithActiveSpan, () => callback(core.getCurrentScope()));\n}\n\nfunction getTracer() {\n  const client = core.getClient();\n  return (client && client.tracer) || api.trace.getTracer('@sentry/opentelemetry', core.SDK_VERSION);\n}\n\nfunction _applySentryAttributesToSpan(span, options) {\n  const { op } = options;\n\n  if (op) {\n    span.setAttribute(core.SEMANTIC_ATTRIBUTE_SENTRY_OP, op);\n  }\n}\n\nfunction getSpanOptions(options) {\n  const { startTime, attributes, kind } = options;\n\n  // OTEL expects timestamps in ms, not seconds\n  const fixedStartTime = typeof startTime === 'number' ? ensureTimestampInMilliseconds(startTime) : startTime;\n\n  return {\n    attributes,\n    kind,\n    startTime: fixedStartTime,\n  };\n}\n\nfunction ensureTimestampInMilliseconds(timestamp) {\n  const isMs = timestamp < 9999999999;\n  return isMs ? timestamp * 1000 : timestamp;\n}\n\nfunction getContext(scope, forceTransaction) {\n  const ctx = getContextForScope(scope);\n  const actualScope = _optionalChain$5([getScopesFromContext, 'call', _ => _(ctx), 'optionalAccess', _2 => _2.scope]);\n\n  const parentSpan = api.trace.getSpan(ctx);\n\n  // In the case that we have no parent span, we need to \"simulate\" one to ensure the propagation context is correct\n  if (!parentSpan) {\n    const client = core.getClient();\n\n    if (actualScope && client) {\n      const propagationContext = actualScope.getPropagationContext();\n\n      // We store the DSC as OTEL trace state on the span context\n      const traceState = makeTraceState({\n        parentSpanId: propagationContext.parentSpanId,\n        // Not defined yet, we want to pick this up on-demand only\n        dsc: undefined,\n        sampled: propagationContext.sampled,\n      });\n\n      const spanOptions = {\n        traceId: propagationContext.traceId,\n        spanId: propagationContext.parentSpanId || propagationContext.spanId,\n        isRemote: true,\n        traceFlags: propagationContext.sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n        traceState,\n      };\n\n      // Add remote parent span context,\n      return api.trace.setSpanContext(ctx, spanOptions);\n    }\n\n    // if we have no scope or client, we just return the context as-is\n    return ctx;\n  }\n\n  // If we don't want to force a transaction, and we have a parent span, all good, we just return as-is!\n  if (!forceTransaction) {\n    return ctx;\n  }\n\n  // Else, if we do have a parent span but want to force a transaction, we have to simulate a \"root\" context\n\n  // Else, we need to do two things:\n  // 1. Unset the parent span from the context, so we'll create a new root span\n  // 2. Ensure the propagation context is correct, so we'll continue from the parent span\n  const ctxWithoutSpan = api.trace.deleteSpan(ctx);\n\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = getSamplingDecision(parentSpan.spanContext());\n\n  // In this case, when we are forcing a transaction, we want to treat this like continuing an incoming trace\n  // so we set the traceState according to the root span\n  const rootSpan = core.getRootSpan(parentSpan);\n  const dsc = core.getDynamicSamplingContextFromSpan(rootSpan);\n\n  const traceState = makeTraceState({\n    dsc,\n    parentSpanId: spanId !== api.INVALID_SPANID ? spanId : undefined,\n    sampled,\n  });\n\n  const spanOptions = {\n    traceId,\n    spanId,\n    isRemote: true,\n    traceFlags: sampled ? api.TraceFlags.SAMPLED : api.TraceFlags.NONE,\n    traceState,\n  };\n\n  const ctxWithSpanContext = api.trace.setSpanContext(ctxWithoutSpan, spanOptions);\n\n  return ctxWithSpanContext;\n}\n\nfunction getContextForScope(scope) {\n  if (scope) {\n    const ctx = getContextFromScope(scope);\n    if (ctx) {\n      return ctx;\n    }\n  }\n\n  return api.context.active();\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n *\n * This is a custom version of `continueTrace` that is used in OTEL-powered environments.\n * It propagates the trace as a remote span, in addition to setting it on the propagation context.\n */\nfunction continueTrace(options, callback) {\n  return core.continueTrace(options, () => {\n    return continueTraceAsRemoteSpan(api.context.active(), options, callback);\n  });\n}\n\nfunction getActiveSpanWrapper(parentSpan) {\n  return parentSpan\n    ? (callback) => {\n        // We cast this, because the OTEL Span has a few more methods than our Span interface\n        // TODO: Add these missing methods to the Span interface\n        return withActiveSpan(parentSpan , callback);\n      }\n    : (callback) => callback();\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nfunction suppressTracing(callback) {\n  const ctx = core$1.suppressTracing(api.context.active());\n  return api.context.with(ctx, callback);\n}\n\nfunction _optionalChain$4(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n/** Ensure the `trace` context is set on all events. */\nfunction setupEventContextTrace(client) {\n  client.on('preprocessEvent', event => {\n    const span = getActiveSpan();\n    // For transaction events, this is handled separately\n    // Because the active span may not be the span that is actually the transaction event\n    if (!span || event.type === 'transaction') {\n      return;\n    }\n\n    const spanContext = span.spanContext();\n\n    // If we have a parent span id from trace state, use that ('' means no parent should be used)\n    // Else, pick the one from the span\n    const parentSpanIdFromTraceState = _optionalChain$4([spanContext, 'access', _ => _.traceState, 'optionalAccess', _2 => _2.get, 'call', _3 => _3(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);\n    const parent_span_id =\n      typeof parentSpanIdFromTraceState === 'string'\n        ? parentSpanIdFromTraceState || undefined\n        : spanHasParentId(span)\n          ? span.parentSpanId\n          : undefined;\n\n    // If event has already set `trace` context, use that one.\n    event.contexts = {\n      trace: utils.dropUndefinedKeys({\n        trace_id: spanContext.traceId,\n        span_id: spanContext.spanId,\n        parent_span_id,\n      }),\n      ...event.contexts,\n    };\n\n    const rootSpan = core.getRootSpan(span);\n\n    event.sdkProcessingMetadata = {\n      dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(rootSpan),\n      ...event.sdkProcessingMetadata,\n    };\n\n    return event;\n  });\n}\n\n/**\n * Sets the async context strategy to use follow the OTEL context under the hood.\n * We handle forking a hub inside of our custom OTEL Context Manager (./otelContextManager.ts)\n */\nfunction setOpenTelemetryContextAsyncContextStrategy() {\n  function getScopes() {\n    const ctx = api.context.active();\n    const scopes = getScopesFromContext(ctx);\n\n    if (scopes) {\n      return scopes;\n    }\n\n    // fallback behavior:\n    // if, for whatever reason, we can't find scopes on the context here, we have to fix this somehow\n    return {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  function withScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    // as by default, we don't want to fork this, unless triggered explicitly by `withScope`\n    return api.context.with(ctx, () => {\n      return callback(getCurrentScope());\n    });\n  }\n\n  function withSetScope(scope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_SET_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which picks up this scope as the current scope\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY, scope), () => {\n      return callback(scope);\n    });\n  }\n\n  function withIsolationScope(callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY, true), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function withSetIsolationScope(isolationScope, callback) {\n    const ctx = api.context.active();\n\n    // We depend on the otelContextManager to handle the context/hub\n    // We set the `SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY` context value, which is picked up by\n    // the OTEL context manager, which uses the presence of this key to determine if it should\n    // fork the isolation scope, or not\n    return api.context.with(ctx.setValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY, isolationScope), () => {\n      return callback(getIsolationScope());\n    });\n  }\n\n  function getCurrentScope() {\n    return getScopes().scope;\n  }\n\n  function getIsolationScope() {\n    return getScopes().isolationScope;\n  }\n\n  core.setAsyncContextStrategy({\n    withScope,\n    withSetScope,\n    withSetIsolationScope,\n    withIsolationScope,\n    getCurrentScope,\n    getIsolationScope,\n    startSpan,\n    startSpanManual,\n    startInactiveSpan,\n    getActiveSpan,\n    // The types here don't fully align, because our own `Span` type is narrower\n    // than the OTEL one - but this is OK for here, as we now we'll only have OTEL spans passed around\n    withActiveSpan: withActiveSpan ,\n    suppressTracing: suppressTracing,\n  });\n}\n\nfunction _optionalChain$3(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\n/**\n * Wrap an OpenTelemetry ContextManager in a way that ensures the context is kept in sync with the Sentry Scope.\n *\n * Usage:\n * import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';\n * const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);\n * const contextManager = new SentryContextManager();\n */\nfunction wrapContextManagerClass(\n  ContextManagerClass,\n) {\n  /**\n   * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.\n   * It ensures that we create new scopes per context, so that the OTEL Context & the Sentry Scope are always in sync.\n   *\n   * Note that we currently only support AsyncHooks with this,\n   * but since this should work for Node 14+ anyhow that should be good enough.\n   */\n\n  // @ts-expect-error TS does not like this, but we know this is fine\n  class SentryContextManager extends ContextManagerClass {\n     constructor(...args) {\n      super(...args);\n      setIsSetup('SentryContextManager');\n    }\n    /**\n     * Overwrite with() of the original AsyncLocalStorageContextManager\n     * to ensure we also create new scopes per context.\n     */\n     with(\n      context,\n      fn,\n      thisArg,\n      ...args\n    ) {\n      const currentScopes = getScopesFromContext(context);\n      const currentScope = _optionalChain$3([currentScopes, 'optionalAccess', _ => _.scope]) || core.getCurrentScope();\n      const currentIsolationScope = _optionalChain$3([currentScopes, 'optionalAccess', _2 => _2.isolationScope]) || core.getIsolationScope();\n\n      const shouldForkIsolationScope = context.getValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY) === true;\n      const scope = context.getValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY) ;\n      const isolationScope = context.getValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY) ;\n\n      const newCurrentScope = scope || currentScope.clone();\n      const newIsolationScope =\n        isolationScope || (shouldForkIsolationScope ? currentIsolationScope.clone() : currentIsolationScope);\n      const scopes = { scope: newCurrentScope, isolationScope: newIsolationScope };\n\n      const ctx1 = setScopesOnContext(context, scopes);\n\n      // Remove the unneeded values again\n      const ctx2 = ctx1\n        .deleteValue(SENTRY_FORK_ISOLATION_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_SCOPE_CONTEXT_KEY)\n        .deleteValue(SENTRY_FORK_SET_ISOLATION_SCOPE_CONTEXT_KEY);\n\n      setContextOnScope(newCurrentScope, ctx2);\n\n      return super.with(ctx2, fn, thisArg, ...args);\n    }\n  }\n\n  return SentryContextManager ;\n}\n\n/** If this attribute is true, it means that the parent is a remote span. */\nconst SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE = 'sentry.parentIsRemote';\n\n/**\n * This function runs through a list of OTEL Spans, and wraps them in an `SpanNode`\n * where each node holds a reference to their parent node.\n */\nfunction groupSpansWithParents(spans) {\n  const nodeMap = new Map();\n\n  for (const span of spans) {\n    createOrUpdateSpanNodeAndRefs(nodeMap, span);\n  }\n\n  return Array.from(nodeMap, function ([_id, spanNode]) {\n    return spanNode;\n  });\n}\n\n/**\n * This returns the _local_ parent ID - `parentId` on the span may point to a remote span.\n */\nfunction getLocalParentId(span) {\n  const parentIsRemote = span.attributes[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE] === true;\n  // If the parentId is the trace parent ID, we pretend it's undefined\n  // As this means the parent exists somewhere else\n  return !parentIsRemote ? span.parentSpanId : undefined;\n}\n\nfunction createOrUpdateSpanNodeAndRefs(nodeMap, span) {\n  const id = span.spanContext().spanId;\n  const parentId = getLocalParentId(span);\n\n  if (!parentId) {\n    createOrUpdateNode(nodeMap, { id, span, children: [] });\n    return;\n  }\n\n  // Else make sure to create parent node as well\n  // Note that the parent may not know it's parent _yet_, this may be updated in a later pass\n  const parentNode = createOrGetParentNode(nodeMap, parentId);\n  const node = createOrUpdateNode(nodeMap, { id, span, parentNode, children: [] });\n  parentNode.children.push(node);\n}\n\nfunction createOrGetParentNode(nodeMap, id) {\n  const existing = nodeMap.get(id);\n\n  if (existing) {\n    return existing;\n  }\n\n  return createOrUpdateNode(nodeMap, { id, children: [] });\n}\n\nfunction createOrUpdateNode(nodeMap, spanNode) {\n  const existing = nodeMap.get(spanNode.id);\n\n  // If span is already set, nothing to do here\n  if (existing && existing.span) {\n    return existing;\n  }\n\n  // If it exists but span is not set yet, we update it\n  if (existing && !existing.span) {\n    existing.span = spanNode.span;\n    existing.parentNode = spanNode.parentNode;\n    return existing;\n  }\n\n  // Else, we create a new one...\n  nodeMap.set(spanNode.id, spanNode);\n  return spanNode;\n}\n\n// canonicalCodesGrpcMap maps some GRPC codes to Sentry's span statuses. See description in grpc documentation.\nconst canonicalGrpcErrorCodesMap = {\n  '1': 'cancelled',\n  '2': 'unknown_error',\n  '3': 'invalid_argument',\n  '4': 'deadline_exceeded',\n  '5': 'not_found',\n  '6': 'already_exists',\n  '7': 'permission_denied',\n  '8': 'resource_exhausted',\n  '9': 'failed_precondition',\n  '10': 'aborted',\n  '11': 'out_of_range',\n  '12': 'unimplemented',\n  '13': 'internal_error',\n  '14': 'unavailable',\n  '15': 'data_loss',\n  '16': 'unauthenticated',\n} ;\n\nconst isStatusErrorMessageValid = (message) => {\n  return Object.values(canonicalGrpcErrorCodesMap).includes(message );\n};\n\n/**\n * Get a Sentry span status from an otel span.\n */\nfunction mapStatus(span) {\n  const attributes = spanHasAttributes(span) ? span.attributes : {};\n  const status = spanHasStatus(span) ? span.status : undefined;\n\n  if (status) {\n    // Since span status OK is not set by default, we give it priority: https://opentelemetry.io/docs/concepts/signals/traces/#span-status\n    if (status.code === api.SpanStatusCode.OK) {\n      return { code: core.SPAN_STATUS_OK };\n      // If the span is already marked as erroneous we return that exact status\n    } else if (status.code === api.SpanStatusCode.ERROR) {\n      if (typeof status.message === 'undefined') {\n        const inferredStatus = inferStatusFromAttributes(attributes);\n        if (inferredStatus) {\n          return inferredStatus;\n        }\n      }\n\n      if (status.message && isStatusErrorMessageValid(status.message)) {\n        return { code: core.SPAN_STATUS_ERROR, message: status.message };\n      } else {\n        return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n      }\n    }\n  }\n\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n  const inferredStatus = inferStatusFromAttributes(attributes);\n\n  if (inferredStatus) {\n    return inferredStatus;\n  }\n\n  // We default to setting the spans status to ok.\n  if (status && status.code === api.SpanStatusCode.UNSET) {\n    return { code: core.SPAN_STATUS_OK };\n  } else {\n    return { code: core.SPAN_STATUS_ERROR, message: 'unknown_error' };\n  }\n}\n\nfunction inferStatusFromAttributes(attributes) {\n  // If the span status is UNSET, we try to infer it from HTTP or GRPC status codes.\n\n  const httpCodeAttribute = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE];\n  const grpcCodeAttribute = attributes[semanticConventions.SEMATTRS_RPC_GRPC_STATUS_CODE];\n\n  const numberHttpCode =\n    typeof httpCodeAttribute === 'number'\n      ? httpCodeAttribute\n      : typeof httpCodeAttribute === 'string'\n        ? parseInt(httpCodeAttribute)\n        : undefined;\n\n  if (typeof numberHttpCode === 'number') {\n    return core.getSpanStatusFromHttpCode(numberHttpCode);\n  }\n\n  if (typeof grpcCodeAttribute === 'string') {\n    return { code: core.SPAN_STATUS_ERROR, message: canonicalGrpcErrorCodesMap[grpcCodeAttribute] || 'unknown_error' };\n  }\n\n  return undefined;\n}\n\nfunction _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nconst MAX_SPAN_COUNT = 1000;\nconst DEFAULT_TIMEOUT = 300; // 5 min\n\n/**\n * A Sentry-specific exporter that converts OpenTelemetry Spans to Sentry Spans & Transactions.\n */\nclass SentrySpanExporter {\n\n   constructor(options) {\n    this._finishedSpans = [];\n    this._timeout = _optionalChain$2([options, 'optionalAccess', _ => _.timeout]) || DEFAULT_TIMEOUT;\n  }\n\n  /** Export a single span. */\n   export(span) {\n    this._finishedSpans.push(span);\n\n    // If the span has a local parent ID, we don't need to export anything just yet\n    if (getLocalParentId(span)) {\n      const openSpanCount = this._finishedSpans.length;\n      DEBUG_BUILD && utils.logger.log(`SpanExporter has ${openSpanCount} unsent spans remaining`);\n      this._cleanupOldSpans();\n      return;\n    }\n\n    this._clearTimeout();\n\n    // If we got a parent span, we try to send the span tree\n    // Wait a tick for this, to ensure we avoid race conditions\n    this._flushTimeout = setTimeout(() => {\n      this.flush();\n    }, 1);\n  }\n\n  /** Try to flush any pending spans immediately. */\n   flush() {\n    this._clearTimeout();\n\n    const openSpanCount = this._finishedSpans.length;\n\n    const remainingSpans = maybeSend(this._finishedSpans);\n\n    const remainingOpenSpanCount = remainingSpans.length;\n    const sentSpanCount = openSpanCount - remainingOpenSpanCount;\n\n    DEBUG_BUILD &&\n      utils.logger.log(`SpanExporter exported ${sentSpanCount} spans, ${remainingOpenSpanCount} unsent spans remaining`);\n\n    this._cleanupOldSpans(remainingSpans);\n  }\n\n  /** Clear the exporter. */\n   clear() {\n    this._finishedSpans = [];\n    this._clearTimeout();\n  }\n\n  /** Clear the flush timeout. */\n   _clearTimeout() {\n    if (this._flushTimeout) {\n      clearTimeout(this._flushTimeout);\n      this._flushTimeout = undefined;\n    }\n  }\n\n  /**\n   * Remove any span that is older than 5min.\n   * We do this to avoid leaking memory.\n   */\n   _cleanupOldSpans(spans = this._finishedSpans) {\n    this._finishedSpans = spans.filter(span => {\n      const shouldDrop = shouldCleanupSpan(span, this._timeout);\n      DEBUG_BUILD &&\n        shouldDrop &&\n        utils.logger.log(\n          `SpanExporter dropping span ${span.name} (${\n            span.spanContext().spanId\n          }) because it is pending for more than 5 minutes.`,\n        );\n      return !shouldDrop;\n    });\n  }\n}\n\n/**\n * Send the given spans, but only if they are part of a finished transaction.\n *\n * Returns the unsent spans.\n * Spans remain unsent when their parent span is not yet finished.\n * This will happen regularly, as child spans are generally finished before their parents.\n * But it _could_ also happen because, for whatever reason, a parent span was lost.\n * In this case, we'll eventually need to clean this up.\n */\nfunction maybeSend(spans) {\n  const grouped = groupSpansWithParents(spans);\n  const remaining = new Set(grouped);\n\n  const rootNodes = getCompletedRootNodes(grouped);\n\n  rootNodes.forEach(root => {\n    remaining.delete(root);\n    const span = root.span;\n    const transactionEvent = createTransactionForOtelSpan(span);\n\n    // We'll recursively add all the child spans to this array\n    const spans = transactionEvent.spans || [];\n\n    root.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, remaining);\n    });\n\n    // spans.sort() mutates the array, but we do not use this anymore after this point\n    // so we can safely mutate it here\n    transactionEvent.spans =\n      spans.length > MAX_SPAN_COUNT\n        ? spans.sort((a, b) => a.start_timestamp - b.start_timestamp).slice(0, MAX_SPAN_COUNT)\n        : spans;\n\n    const measurements = core.timedEventsToMeasurements(span.events);\n    if (measurements) {\n      transactionEvent.measurements = measurements;\n    }\n\n    core.captureEvent(transactionEvent);\n  });\n\n  return Array.from(remaining)\n    .map(node => node.span)\n    .filter((span) => !!span);\n}\n\nfunction nodeIsCompletedRootNode(node) {\n  return !!node.span && !node.parentNode;\n}\n\nfunction getCompletedRootNodes(nodes) {\n  return nodes.filter(nodeIsCompletedRootNode);\n}\n\nfunction shouldCleanupSpan(span, maxStartTimeOffsetSeconds) {\n  const cutoff = Date.now() / 1000 - maxStartTimeOffsetSeconds;\n  return core.spanTimeInputToSeconds(span.startTime) < cutoff;\n}\n\nfunction parseSpan(span) {\n  const attributes = span.attributes;\n\n  const origin = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN] ;\n  const op = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_OP] ;\n  const source = attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] ;\n\n  return { origin, op, source };\n}\n\nfunction createTransactionForOtelSpan(span) {\n  const { op, description, data, origin = 'manual', source } = getSpanData(span);\n  const capturedSpanScopes = core.getCapturedScopesOnSpan(span );\n\n  const sampleRate = span.attributes[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE] ;\n\n  const attributes = utils.dropUndefinedKeys({\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    ...data,\n    ...removeSentryAttributes(span.attributes),\n  });\n\n  const { traceId: trace_id, spanId: span_id } = span.spanContext();\n\n  const parentSpanIdFromTraceState = _optionalChain$2([span, 'access', _2 => _2.spanContext, 'call', _3 => _3(), 'access', _4 => _4.traceState, 'optionalAccess', _5 => _5.get, 'call', _6 => _6(SENTRY_TRACE_STATE_PARENT_SPAN_ID)]);\n\n  // If parentSpanIdFromTraceState is defined at all, we want it to take presedence\n  // In that case, an empty string should be interpreted as \"no parent span id\",\n  // even if `span.parentSpanId` is set\n  // this is the case when we are starting a new trace, where we have a virtual span based on the propagationContext\n  // We only want to continue the traceId in this case, but ignore the parent span\n  const parent_span_id =\n    typeof parentSpanIdFromTraceState === 'string' ? parentSpanIdFromTraceState || undefined : span.parentSpanId;\n\n  const status = mapStatus(span);\n\n  const traceContext = utils.dropUndefinedKeys({\n    parent_span_id,\n    span_id,\n    trace_id,\n    data: attributes,\n    origin,\n    op,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n  });\n\n  const transactionEvent = {\n    contexts: {\n      trace: traceContext,\n      otel: {\n        resource: span.resource.attributes,\n      },\n    },\n    spans: [],\n    start_timestamp: core.spanTimeInputToSeconds(span.startTime),\n    timestamp: core.spanTimeInputToSeconds(span.endTime),\n    transaction: description,\n    type: 'transaction',\n    sdkProcessingMetadata: {\n      ...utils.dropUndefinedKeys({\n        capturedSpanScope: capturedSpanScopes.scope,\n        capturedSpanIsolationScope: capturedSpanScopes.isolationScope,\n        sampleRate,\n        dynamicSamplingContext: core.getDynamicSamplingContextFromSpan(span ),\n      }),\n    },\n    ...(source && {\n      transaction_info: {\n        source,\n      },\n    }),\n    _metrics_summary: core.getMetricSummaryJsonForSpan(span ),\n  };\n\n  return transactionEvent;\n}\n\nfunction createAndFinishSpanForOtelSpan(node, spans, remaining) {\n  remaining.delete(node);\n  const span = node.span;\n\n  const shouldDrop = !span;\n\n  // If this span should be dropped, we still want to create spans for the children of this\n  if (shouldDrop) {\n    node.children.forEach(child => {\n      createAndFinishSpanForOtelSpan(child, spans, remaining);\n    });\n    return;\n  }\n\n  const span_id = span.spanContext().spanId;\n  const trace_id = span.spanContext().traceId;\n\n  const { attributes, startTime, endTime, parentSpanId } = span;\n\n  const { op, description, data, origin = 'manual' } = getSpanData(span);\n  const allData = utils.dropUndefinedKeys({\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: origin,\n    [core.SEMANTIC_ATTRIBUTE_SENTRY_OP]: op,\n    ...removeSentryAttributes(attributes),\n    ...data,\n  });\n\n  const status = mapStatus(span);\n\n  const spanJSON = utils.dropUndefinedKeys({\n    span_id,\n    trace_id,\n    data: allData,\n    description,\n    parent_span_id: parentSpanId,\n    start_timestamp: core.spanTimeInputToSeconds(startTime),\n    // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time\n    timestamp: core.spanTimeInputToSeconds(endTime) || undefined,\n    status: core.getStatusMessage(status), // As per protocol, span status is allowed to be undefined\n    op,\n    origin,\n    _metrics_summary: core.getMetricSummaryJsonForSpan(span ),\n    measurements: core.timedEventsToMeasurements(span.events),\n  });\n\n  spans.push(spanJSON);\n\n  node.children.forEach(child => {\n    createAndFinishSpanForOtelSpan(child, spans, remaining);\n  });\n}\n\nfunction getSpanData(span)\n\n {\n  const { op: definedOp, source: definedSource, origin } = parseSpan(span);\n  const { op: inferredOp, description, source: inferredSource, data: inferredData } = parseSpanDescription(span);\n\n  const op = definedOp || inferredOp;\n  const source = definedSource || inferredSource;\n\n  const data = { ...inferredData, ...getData(span) };\n\n  return {\n    op,\n    description,\n    source,\n    origin,\n    data,\n  };\n}\n\n/**\n * Remove custom `sentry.` attribtues we do not need to send.\n * These are more carrier attributes we use inside of the SDK, we do not need to send them to the API.\n */\nfunction removeSentryAttributes(data) {\n  const cleanedData = { ...data };\n\n  /* eslint-disable @typescript-eslint/no-dynamic-delete */\n  delete cleanedData[core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];\n  delete cleanedData[SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE];\n  /* eslint-enable @typescript-eslint/no-dynamic-delete */\n\n  return cleanedData;\n}\n\nfunction getData(span) {\n  const attributes = span.attributes;\n  const data = {\n    'otel.kind': api.SpanKind[span.kind],\n  };\n\n  if (attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE]) {\n    const statusCode = attributes[semanticConventions.SEMATTRS_HTTP_STATUS_CODE] ;\n    data['http.response.status_code'] = statusCode;\n  }\n\n  const requestData = getRequestSpanData(span);\n\n  if (requestData.url) {\n    data.url = requestData.url;\n  }\n\n  if (requestData['http.query']) {\n    data['http.query'] = requestData['http.query'].slice(1);\n  }\n  if (requestData['http.fragment']) {\n    data['http.fragment'] = requestData['http.fragment'].slice(1);\n  }\n\n  return data;\n}\n\nfunction _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }\n\nfunction onSpanStart(span, parentContext) {\n  // This is a reliable way to get the parent span - because this is exactly how the parent is identified in the OTEL SDK\n  const parentSpan = api.trace.getSpan(parentContext);\n\n  let scopes = getScopesFromContext(parentContext);\n\n  // We need access to the parent span in order to be able to move up the span tree for breadcrumbs\n  if (parentSpan && !parentSpan.spanContext().isRemote) {\n    core.addChildSpanToSpan(parentSpan, span);\n  }\n\n  // We need this in the span exporter\n  if (parentSpan && parentSpan.spanContext().isRemote) {\n    span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_PARENT_IS_REMOTE, true);\n  }\n\n  // The root context does not have scopes stored, so we check for this specifically\n  // As fallback we attach the global scopes\n  if (parentContext === api.ROOT_CONTEXT) {\n    scopes = {\n      scope: core.getDefaultCurrentScope(),\n      isolationScope: core.getDefaultIsolationScope(),\n    };\n  }\n\n  // We need the scope at time of span creation in order to apply it to the event when the span is finished\n  if (scopes) {\n    core.setCapturedScopesOnSpan(span, scopes.scope, scopes.isolationScope);\n  }\n\n  core.logSpanStart(span);\n\n  const client = core.getClient();\n  _optionalChain$1([client, 'optionalAccess', _ => _.emit, 'call', _2 => _2('spanStart', span)]);\n}\n\nfunction onSpanEnd(span) {\n  core.logSpanEnd(span);\n\n  const client = core.getClient();\n  _optionalChain$1([client, 'optionalAccess', _3 => _3.emit, 'call', _4 => _4('spanEnd', span)]);\n}\n\n/**\n * Converts OpenTelemetry Spans to Sentry Spans and sends them to Sentry via\n * the Sentry SDK.\n */\nclass SentrySpanProcessor  {\n\n   constructor(options) {\n    setIsSetup('SentrySpanProcessor');\n    this._exporter = new SentrySpanExporter(options);\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async forceFlush() {\n    this._exporter.flush();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   async shutdown() {\n    this._exporter.clear();\n  }\n\n  /**\n   * @inheritDoc\n   */\n   onStart(span, parentContext) {\n    onSpanStart(span, parentContext);\n  }\n\n  /** @inheritDoc */\n   onEnd(span) {\n    onSpanEnd(span);\n\n    this._exporter.export(span);\n  }\n}\n\n/**\n * A custom OTEL sampler that uses Sentry sampling rates to make its decision\n */\nclass SentrySampler  {\n\n   constructor(client) {\n    this._client = client;\n    setIsSetup('SentrySampler');\n  }\n\n  /** @inheritDoc */\n   shouldSample(\n    context,\n    traceId,\n    spanName,\n    spanKind,\n    spanAttributes,\n    _links,\n  ) {\n    const options = this._client.getOptions();\n\n    const parentSpan = api.trace.getSpan(context);\n    const parentContext = _optionalChain([parentSpan, 'optionalAccess', _ => _.spanContext, 'call', _2 => _2()]);\n\n    if (!core.hasTracingEnabled(options)) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    // If we have a http.client span that has no local parent, we never want to sample it\n    // but we want to leave downstream sampling decisions up to the server\n    if (\n      spanKind === api.SpanKind.CLIENT &&\n      spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD] &&\n      (!parentSpan || _optionalChain([parentContext, 'optionalAccess', _3 => _3.isRemote]))\n    ) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const parentSampled = parentSpan ? getParentSampled(parentSpan, traceId, spanName) : undefined;\n\n    const mutableSamplingDecision = { decision: true };\n    this._client.emit(\n      'beforeSampling',\n      {\n        spanAttributes: spanAttributes,\n        spanName: spanName,\n        parentSampled: parentSampled,\n        parentContext: parentContext,\n      },\n      mutableSamplingDecision,\n    );\n    if (!mutableSamplingDecision.decision) {\n      return wrapSamplingDecision({ decision: undefined, context, spanAttributes });\n    }\n\n    const [sampled, sampleRate] = core.sampleSpan(options, {\n      name: spanName,\n      attributes: spanAttributes,\n      transactionContext: {\n        name: spanName,\n        parentSampled,\n      },\n      parentSampled,\n    });\n\n    const attributes = {\n      [core.SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE]: sampleRate,\n    };\n\n    const method = `${spanAttributes[semanticConventions.SEMATTRS_HTTP_METHOD]}`.toUpperCase();\n    if (method === 'OPTIONS' || method === 'HEAD') {\n      DEBUG_BUILD && utils.logger.log(`[Tracing] Not sampling span because HTTP method is '${method}' for ${spanName}`);\n\n      return {\n        ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.NOT_RECORD, context, spanAttributes }),\n        attributes,\n      };\n    }\n\n    if (!sampled) {\n      return {\n        ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.NOT_RECORD, context, spanAttributes }),\n        attributes,\n      };\n    }\n    return {\n      ...wrapSamplingDecision({ decision: sdkTraceBase.SamplingDecision.RECORD_AND_SAMPLED, context, spanAttributes }),\n      attributes,\n    };\n  }\n\n  /** Returns the sampler name or short description with the configuration. */\n   toString() {\n    return 'SentrySampler';\n  }\n}\n\nfunction getParentRemoteSampled(parentSpan) {\n  const traceId = parentSpan.spanContext().traceId;\n  const traceparentData = getPropagationContextFromSpan(parentSpan);\n\n  // Only inherit sampled if `traceId` is the same\n  return traceparentData && traceId === traceparentData.traceId ? traceparentData.sampled : undefined;\n}\n\nfunction getParentSampled(parentSpan, traceId, spanName) {\n  const parentContext = parentSpan.spanContext();\n\n  // Only inherit sample rate if `traceId` is the same\n  // Note for testing: `isSpanContextValid()` checks the format of the traceId/spanId, so we need to pass valid ones\n  if (api.isSpanContextValid(parentContext) && parentContext.traceId === traceId) {\n    if (parentContext.isRemote) {\n      const parentSampled = getParentRemoteSampled(parentSpan);\n      DEBUG_BUILD &&\n        utils.logger.log(`[Tracing] Inheriting remote parent's sampled decision for ${spanName}: ${parentSampled}`);\n      return parentSampled;\n    }\n\n    const parentSampled = getSamplingDecision(parentContext);\n    DEBUG_BUILD && utils.logger.log(`[Tracing] Inheriting parent's sampled decision for ${spanName}: ${parentSampled}`);\n    return parentSampled;\n  }\n\n  return undefined;\n}\n\n/**\n * Wrap a sampling decision with data that Sentry needs to work properly with it.\n * If you pass `decision: undefined`, it will be treated as `NOT_RECORDING`, but in contrast to passing `NOT_RECORDING`\n * it will not propagate this decision to downstream Sentry SDKs.\n */\nfunction wrapSamplingDecision({\n  decision,\n  context,\n  spanAttributes,\n}) {\n  const traceState = getBaseTraceState(context, spanAttributes);\n\n  // If the decision is undefined, we treat it as NOT_RECORDING, but we don't propagate this decision to downstream SDKs\n  // Which is done by not setting `SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING` traceState\n  if (decision == undefined) {\n    return { decision: sdkTraceBase.SamplingDecision.NOT_RECORD, traceState };\n  }\n\n  if (decision === sdkTraceBase.SamplingDecision.NOT_RECORD) {\n    return { decision, traceState: traceState.set(SENTRY_TRACE_STATE_SAMPLED_NOT_RECORDING, '1') };\n  }\n\n  return { decision, traceState };\n}\n\nfunction getBaseTraceState(context, spanAttributes) {\n  const parentSpan = api.trace.getSpan(context);\n  const parentContext = _optionalChain([parentSpan, 'optionalAccess', _4 => _4.spanContext, 'call', _5 => _5()]);\n\n  let traceState = _optionalChain([parentContext, 'optionalAccess', _6 => _6.traceState]) || new core$1.TraceState();\n\n  // We always keep the URL on the trace state, so we can access it in the propagator\n  const url = spanAttributes[semanticConventions.SEMATTRS_HTTP_URL];\n  if (url && typeof url === 'string') {\n    traceState = traceState.set(SENTRY_TRACE_STATE_URL, url);\n  }\n\n  return traceState;\n}\n\n/**\n * This method takes an OpenTelemetry instrumentation or\n * array of instrumentations and registers them with OpenTelemetry.\n */\nfunction addOpenTelemetryInstrumentation(...instrumentations) {\n  instrumentation.registerInstrumentations({\n    instrumentations,\n  });\n}\n\nexports.getClient = core.getClient;\nexports.getCurrentHubShim = core.getCurrentHubShim;\nexports.getDynamicSamplingContextFromSpan = core.getDynamicSamplingContextFromSpan;\nexports.SentryPropagator = SentryPropagator;\nexports.SentrySampler = SentrySampler;\nexports.SentrySpanProcessor = SentrySpanProcessor;\nexports.addOpenTelemetryInstrumentation = addOpenTelemetryInstrumentation;\nexports.continueTrace = continueTrace;\nexports.enhanceDscWithOpenTelemetryRootSpanName = enhanceDscWithOpenTelemetryRootSpanName;\nexports.getActiveSpan = getActiveSpan;\nexports.getRequestSpanData = getRequestSpanData;\nexports.getScopesFromContext = getScopesFromContext;\nexports.getSpanKind = getSpanKind;\nexports.isSentryRequestSpan = isSentryRequestSpan;\nexports.openTelemetrySetupCheck = openTelemetrySetupCheck;\nexports.setOpenTelemetryContextAsyncContextStrategy = setOpenTelemetryContextAsyncContextStrategy;\nexports.setupEventContextTrace = setupEventContextTrace;\nexports.spanHasAttributes = spanHasAttributes;\nexports.spanHasEvents = spanHasEvents;\nexports.spanHasKind = spanHasKind;\nexports.spanHasName = spanHasName;\nexports.spanHasParentId = spanHasParentId;\nexports.spanHasStatus = spanHasStatus;\nexports.startInactiveSpan = startInactiveSpan;\nexports.startSpan = startSpan;\nexports.startSpanManual = startSpanManual;\nexports.suppressTracing = suppressTracing;\nexports.withActiveSpan = withActiveSpan;\nexports.wrapClientClass = wrapClientClass;\nexports.wrapContextManagerClass = wrapContextManagerClass;\nexports.wrapSamplingDecision = wrapSamplingDecision;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlbnRyeStvcGVudGVsZW1ldHJ5QDguMTcuMF9Ab3BlbnRlbGVtZXRyeSthcGlAMS45LjBfQG9wZW50ZWxlbWV0cnkrY29yZUAxLjI1LjFfQG9wZW50ZWxlbWV0X293N2MzN2RtM2w0YnltYzdpNGV0aXB6bWFhL25vZGVfbW9kdWxlcy9Ac2VudHJ5L29wZW50ZWxlbWV0cnkvYnVpbGQvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxvSEFBZTs7QUFFM0IsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCw0QkFBNEIsbUJBQU8sQ0FBQyxzTEFBcUM7QUFDekUsY0FBYyxtQkFBTyxDQUFDLG9IQUFlO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyxrSUFBb0I7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGlIQUFjO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywrSkFBcUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsNkxBQStCO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLGdNQUFnQzs7QUFFaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDckIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BvcnRmb2xpby1wcm9qZWN0Ly4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzZW50cnkrb3BlbnRlbGVtZXRyeUA4LjE3LjBfQG9wZW50ZWxlbWV0cnkrYXBpQDEuOS4wX0BvcGVudGVsZW1ldHJ5K2NvcmVAMS4yNS4xX0BvcGVudGVsZW1ldF9vdzdjMzdkbTNsNGJ5bWM3aTRldGlwem1hYS9ub2RlX21vZHVsZXMvQHNlbnRyeS9vcGVudGVsZW1ldHJ5L2J1aWxkL2Nqcy9pbmRleC5qcz8xNGM4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB7XG4gIF9vcHRpb25hbENoYWluXG59ID0gcmVxdWlyZSgnQHNlbnRyeS91dGlscycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jb25zdCBzZW1hbnRpY0NvbnZlbnRpb25zID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvc2VtYW50aWMtY29udmVudGlvbnMnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnQHNlbnRyeS91dGlscycpO1xuY29uc3QgYXBpID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvYXBpJyk7XG5jb25zdCBjb3JlID0gcmVxdWlyZSgnQHNlbnRyeS9jb3JlJyk7XG5jb25zdCBjb3JlJDEgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9jb3JlJyk7XG5jb25zdCBzZGtUcmFjZUJhc2UgPSByZXF1aXJlKCdAb3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZScpO1xuY29uc3QgaW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnQG9wZW50ZWxlbWV0cnkvaW5zdHJ1bWVudGF0aW9uJyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhdHRyaWJ1dGVzLlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYmFzZSBgU3BhbmAgdHlwZSBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZXMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyB0aGVtLlxuICovXG5mdW5jdGlvbiBzcGFuSGFzQXR0cmlidXRlcyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5hdHRyaWJ1dGVzICYmIHR5cGVvZiBjYXN0U3Bhbi5hdHRyaWJ1dGVzID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEga2luZC5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIGtpbmQsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0tpbmQoc3Bhbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5raW5kO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gc3BhbiBoYXMgYSBzdGF0dXMuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBzdGF0dXMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc1N0YXR1cyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gISFjYXN0U3Bhbi5zdGF0dXM7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBnaXZlbiBzcGFuIGhhcyBhIG5hbWUuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBiYXNlIGBTcGFuYCB0eXBlIGRvZXMgbm90IGhhdmUgYSBuYW1lLFxuICogc28gaW4gcGxhY2VzIHdoZXJlIHdlIGFyZSBwYXNzZWQgYSBnZW5lcmljIHNwYW4sIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBhY2Nlc3MgaXQuXG4gKi9cbmZ1bmN0aW9uIHNwYW5IYXNOYW1lKHNwYW4pIHtcbiAgY29uc3QgY2FzdFNwYW4gPSBzcGFuIDtcbiAgcmV0dXJuICEhY2FzdFNwYW4ubmFtZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGEga2luZC5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBhIGtpbmQsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc1BhcmVudElkKFxuICBzcGFuLFxuKSB7XG4gIGNvbnN0IGNhc3RTcGFuID0gc3BhbiA7XG4gIHJldHVybiAhIWNhc3RTcGFuLnBhcmVudFNwYW5JZDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGdpdmVuIHNwYW4gaGFzIGV2ZW50cy5cbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGJhc2UgYFNwYW5gIHR5cGUgZG9lcyBub3QgaGF2ZSBldmVudHMsXG4gKiBzbyBpbiBwbGFjZXMgd2hlcmUgd2UgYXJlIHBhc3NlZCBhIGdlbmVyaWMgc3Bhbiwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSB3YW50IHRvIGFjY2VzcyBpdC5cbiAqL1xuZnVuY3Rpb24gc3Bhbkhhc0V2ZW50cyhcbiAgc3Bhbixcbikge1xuICBjb25zdCBjYXN0U3BhbiA9IHNwYW4gO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShjYXN0U3Bhbi5ldmVudHMpO1xufVxuXG4vKipcbiAqIEdldCBzYW5pdGl6aWVkIHJlcXVlc3QgZGF0YSBmcm9tIGFuIE9URUwgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVxdWVzdFNwYW5EYXRhKHNwYW4pIHtcbiAgLy8gVGhlIGJhc2UgYFNwYW5gIHR5cGUgaGFzIG5vIGBhdHRyaWJ1dGVzYCwgc28gd2UgbmVlZCB0byBndWFyZCBoZXJlIGFnYWluc3QgdGhhdFxuICBpZiAoIXNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IHtcbiAgICB1cmw6IHNwYW4uYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXSAsXG4gICAgJ2h0dHAubWV0aG9kJzogc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9NRVRIT0RdICxcbiAgfTtcblxuICAvLyBEZWZhdWx0IHRvIEdFVCBpZiBVUkwgaXMgc2V0IGJ1dCBtZXRob2QgaXMgbm90XG4gIGlmICghZGF0YVsnaHR0cC5tZXRob2QnXSAmJiBkYXRhLnVybCkge1xuICAgIGRhdGFbJ2h0dHAubWV0aG9kJ10gPSAnR0VUJztcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgdXJsU3RyID0gc3Bhbi5hdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdO1xuICAgIGlmICh0eXBlb2YgdXJsU3RyID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdXJsID0gdXRpbHMucGFyc2VVcmwodXJsU3RyKTtcblxuICAgICAgZGF0YS51cmwgPSB1dGlscy5nZXRTYW5pdGl6ZWRVcmxTdHJpbmcodXJsKTtcblxuICAgICAgaWYgKHVybC5zZWFyY2gpIHtcbiAgICAgICAgZGF0YVsnaHR0cC5xdWVyeSddID0gdXJsLnNlYXJjaDtcbiAgICAgIH1cbiAgICAgIGlmICh1cmwuaGFzaCkge1xuICAgICAgICBkYXRhWydodHRwLmZyYWdtZW50J10gPSB1cmwuaGFzaDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpZ25vcmVcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBfb3B0aW9uYWxDaGFpbiQ4KG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9XG5cbi8vIFR5cGVzY3JpcHQgY29tcGxhaW5zIGlmIHdlIGRvIG5vdCB1c2UgYC4uLmFyZ3M6IGFueVtdYCBmb3IgdGhlIG1peGluLCB3aXRoOlxuLy8gQSBtaXhpbiBjbGFzcyBtdXN0IGhhdmUgYSBjb25zdHJ1Y3RvciB3aXRoIGEgc2luZ2xlIHJlc3QgcGFyYW1ldGVyIG9mIHR5cGUgJ2FueVtdJy50cygyNTQ1KVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIFdyYXAgYW4gQ2xpZW50IHdpdGggdGhpbmdzIHdlIG5lZWQgZm9yIE9wZW5UZWxlbWV0cnkgc3VwcG9ydC5cbiAqXG4gKiBVc2FnZTpcbiAqIGNvbnN0IE9wZW5UZWxlbWV0cnlDbGllbnQgPSBnZXRXcmFwcGVkQ2xpZW50Q2xhc3MoTm9kZUNsaWVudCk7XG4gKiBjb25zdCBjbGllbnQgPSBuZXcgT3BlblRlbGVtZXRyeUNsaWVudChvcHRpb25zKTtcbiAqL1xuZnVuY3Rpb24gd3JhcENsaWVudENsYXNzXG5cbihDbGllbnRDbGFzcykge1xuICBjbGFzcyBPcGVuVGVsZW1ldHJ5Q2xpZW50IGV4dGVuZHMgQ2xpZW50Q2xhc3MgIHtcblxuICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBPVEVMIHRyYWNlci4gKi9cbiAgICAgZ2V0IHRyYWNlcigpIHtcbiAgICAgIGlmICh0aGlzLl90cmFjZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNlcjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmFtZSA9ICdAc2VudHJ5L29wZW50ZWxlbWV0cnknO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IGNvcmUuU0RLX1ZFUlNJT047XG4gICAgICBjb25zdCB0cmFjZXIgPSBhcGkudHJhY2UuZ2V0VHJhY2VyKG5hbWUsIHZlcnNpb24pO1xuICAgICAgdGhpcy5fdHJhY2VyID0gdHJhY2VyO1xuXG4gICAgICByZXR1cm4gdHJhY2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgIGFzeW5jIGZsdXNoKHRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy50cmFjZVByb3ZpZGVyO1xuICAgICAgY29uc3Qgc3BhblByb2Nlc3NvciA9IF9vcHRpb25hbENoYWluJDgoW3Byb3ZpZGVyLCAnb3B0aW9uYWxBY2Nlc3MnLCBfID0+IF8uYWN0aXZlU3BhblByb2Nlc3Nvcl0pO1xuXG4gICAgICBpZiAoc3BhblByb2Nlc3Nvcikge1xuICAgICAgICBhd2FpdCBzcGFuUHJvY2Vzc29yLmZvcmNlRmx1c2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1cGVyLmZsdXNoKHRpbWVvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcGVuVGVsZW1ldHJ5Q2xpZW50IDtcbn1cbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKipcbiAqIEdldCB0aGUgc3BhbiBraW5kIGZyb20gYSBzcGFuLlxuICogRm9yIHdoYXRldmVyIHJlYXNvbiwgdGhpcyBpcyBub3QgcHVibGljIEFQSSBvbiB0aGUgZ2VuZXJpYyBcIlNwYW5cIiB0eXBlLFxuICogc28gd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBhY3R1YWxseSBoYXZlIGEgYFNES1RyYWNlQmFzZVNwYW5gIHdoZXJlIHdlIGNhbiBmZXRjaCB0aGlzIGZyb20uXG4gKiBPdGhlcndpc2UsIHdlIGZhbGwgYmFjayB0byBgU3BhbktpbmQuSU5URVJOQUxgLlxuICovXG5mdW5jdGlvbiBnZXRTcGFuS2luZChzcGFuKSB7XG4gIGlmIChzcGFuSGFzS2luZChzcGFuKSkge1xuICAgIHJldHVybiBzcGFuLmtpbmQ7XG4gIH1cblxuICByZXR1cm4gYXBpLlNwYW5LaW5kLklOVEVSTkFMO1xufVxuXG5jb25zdCBTRU5UUllfVFJBQ0VfSEVBREVSID0gJ3NlbnRyeS10cmFjZSc7XG5jb25zdCBTRU5UUllfQkFHR0FHRV9IRUFERVIgPSAnYmFnZ2FnZSc7XG5cbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9EU0MgPSAnc2VudHJ5LmRzYyc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfUEFSRU5UX1NQQU5fSUQgPSAnc2VudHJ5LnBhcmVudF9zcGFuX2lkJztcbmNvbnN0IFNFTlRSWV9UUkFDRV9TVEFURV9TQU1QTEVEX05PVF9SRUNPUkRJTkcgPSAnc2VudHJ5LnNhbXBsZWRfbm90X3JlY29yZGluZyc7XG5jb25zdCBTRU5UUllfVFJBQ0VfU1RBVEVfVVJMID0gJ3NlbnRyeS51cmwnO1xuXG5jb25zdCBTRU5UUllfU0NPUEVTX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9zY29wZXMnKTtcblxuY29uc3QgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZID0gYXBpLmNyZWF0ZUNvbnRleHRLZXkoJ3NlbnRyeV9mb3JrX2lzb2xhdGlvbl9zY29wZScpO1xuXG5jb25zdCBTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X2Zvcmtfc2V0X3Njb3BlJyk7XG5cbmNvbnN0IFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkgPSBhcGkuY3JlYXRlQ29udGV4dEtleSgnc2VudHJ5X2Zvcmtfc2V0X2lzb2xhdGlvbl9zY29wZScpO1xuXG5jb25zdCBTQ09QRV9DT05URVhUX0ZJRUxEID0gJ19zY29wZUNvbnRleHQnO1xuXG4vKipcbiAqIFRyeSB0byBnZXQgdGhlIGN1cnJlbnQgc2NvcGVzIGZyb20gdGhlIGdpdmVuIE9URUwgY29udGV4dC5cbiAqIFRoaXMgcmVxdWlyZXMgYSBDb250ZXh0IE1hbmFnZXIgdGhhdCB3YXMgd3JhcHBlZCB3aXRoIGdldFdyYXBwZWRDb250ZXh0TWFuYWdlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCkge1xuICByZXR1cm4gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfU0NPUEVTX0NPTlRFWFRfS0VZKSA7XG59XG5cbi8qKlxuICogU2V0IHRoZSBjdXJyZW50IHNjb3BlcyBvbiBhbiBPVEVMIGNvbnRleHQuXG4gKiBUaGlzIHdpbGwgcmV0dXJuIGEgZm9ya2VkIGNvbnRleHQgd2l0aCB0aGUgUHJvcGFnYXRpb24gQ29udGV4dCBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldFNjb3Blc09uQ29udGV4dChjb250ZXh0LCBzY29wZXMpIHtcbiAgcmV0dXJuIGNvbnRleHQuc2V0VmFsdWUoU0VOVFJZX1NDT1BFU19DT05URVhUX0tFWSwgc2NvcGVzKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGNvbnRleHQgb24gdGhlIHNjb3BlIHNvIHdlIGNhbiBsYXRlciBsb29rIGl0IHVwLlxuICogV2UgbmVlZCB0aGlzIHRvIGdldCB0aGUgY29udGV4dCBmcm9tIHRoZSBzY29wZSBpbiB0aGUgYHRyYWNlYCBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHRPblNjb3BlKHNjb3BlLCBjb250ZXh0KSB7XG4gIHV0aWxzLmFkZE5vbkVudW1lcmFibGVQcm9wZXJ0eShzY29wZSwgU0NPUEVfQ09OVEVYVF9GSUVMRCwgY29udGV4dCk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBjb250ZXh0IHJlbGF0ZWQgdG8gYSBzY29wZS5cbiAqIFRPRE8gdjg6IFVzZSB0aGlzIGZvciB0aGUgYHRyYWNlYCBmdW5jdGlvbnMuXG4gKiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSkge1xuICByZXR1cm4gKHNjb3BlIClbU0NPUEVfQ09OVEVYVF9GSUVMRF07XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBvdGVsU3BhbiBDaGVja3Mgd2hldGVyIGEgZ2l2ZW4gT1RFTCBTcGFuIGlzIGFuIGh0dHAgcmVxdWVzdCB0byBzZW50cnkuXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmZ1bmN0aW9uIGlzU2VudHJ5UmVxdWVzdFNwYW4oc3Bhbikge1xuICBpZiAoIXNwYW5IYXNBdHRyaWJ1dGVzKHNwYW4pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBzcGFuO1xuXG4gIGNvbnN0IGh0dHBVcmwgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdO1xuXG4gIGlmICghaHR0cFVybCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBjb3JlLmlzU2VudHJ5UmVxdWVzdFVybChodHRwVXJsLnRvU3RyaW5nKCksIGNvcmUuZ2V0Q2xpZW50KCkpO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYmV0dGVyIG9wL2Rlc2NyaXB0aW9uIGZyb20gYW4gb3RlbCBzcGFuLlxuICpcbiAqIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXRlbGVtZXRyeS9vcGVudGVsZW1ldHJ5LWNvbGxlY3Rvci1jb250cmliL2Jsb2IvNzQyMmNlMmEwNjMzN2Y2OGE1OWI1NTJiOGM1YTJhYzEyNWQ2YmFlNS9leHBvcnRlci9zZW50cnlleHBvcnRlci9zZW50cnlfZXhwb3J0ZXIuZ28jTDMwNlxuICovXG5mdW5jdGlvbiBwYXJzZVNwYW5EZXNjcmlwdGlvbihzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcyhzcGFuKSA/IHNwYW4uYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBuYW1lID0gc3Bhbkhhc05hbWUoc3BhbikgPyBzcGFuLm5hbWUgOiAnPHVua25vd24+JztcblxuICAvLyBUaGlzIGF0dHJpYnV0ZSBpcyBpbnRlbnRpb25hbGx5IGV4cG9ydGVkIGFzIGEgU0VNQVRUUiBjb25zdGFudCBiZWNhdXNlIGl0IHNob3VsZCBzdGF5IGludGltaXRlIEFQSVxuICBpZiAoYXR0cmlidXRlc1snc2VudHJ5LnNraXBfc3Bhbl9kYXRhX2luZmVyZW5jZSddKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wOiB1bmRlZmluZWQsXG4gICAgICBkZXNjcmlwdGlvbjogbmFtZSxcbiAgICAgIHNvdXJjZTogJ2N1c3RvbScsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIC8vIFN1Z2dlc3QgdG8gY2FsbGVycyBvZiBgcGFyc2VTcGFuRGVzY3JpcHRpb25gIHRvIHdpcGUgdGhlIGhpbnQgYmVjYXVzZSBpdCBpcyB1bm5lY2Vzc2FyeSBkYXRhIGluIHRoZSBlbmQuXG4gICAgICAgICdzZW50cnkuc2tpcF9zcGFuX2RhdGFfaW5mZXJlbmNlJzogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gaWYgaHR0cC5tZXRob2QgZXhpc3RzLCB0aGlzIGlzIGFuIGh0dHAgcmVxdWVzdCBzcGFuXG4gIC8vXG4gIC8vIFRPRE86IFJlZmVyZW5jaW5nIGBodHRwLnJlcXVlc3QubWV0aG9kYCBpcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kIHVudGlsIHRoZSBzZW1hbnRpY1xuICAvLyBjb252ZW50aW9ucyBleHBvcnQgYW4gYXR0cmlidXRlIGtleSBmb3IgaXQuXG4gIGNvbnN0IGh0dHBNZXRob2QgPSBhdHRyaWJ1dGVzWydodHRwLnJlcXVlc3QubWV0aG9kJ10gfHwgYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfTUVUSE9EXTtcbiAgaWYgKGh0dHBNZXRob2QpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb25Gb3JIdHRwTWV0aG9kKHsgYXR0cmlidXRlcywgbmFtZSwga2luZDogZ2V0U3BhbktpbmQoc3BhbikgfSwgaHR0cE1ldGhvZCk7XG4gIH1cblxuICBjb25zdCBkYlN5c3RlbSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19EQl9TWVNURU1dO1xuICBjb25zdCBvcElzQ2FjaGUgPVxuICAgIHR5cGVvZiBhdHRyaWJ1dGVzW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF0gPT09ICdzdHJpbmcnICYmXG4gICAgYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdLnN0YXJ0c1dpdGgoJ2NhY2hlLicpO1xuXG4gIC8vIElmIGRiLnR5cGUgZXhpc3RzIHRoZW4gdGhpcyBpcyBhIGRhdGFiYXNlIGNhbGwgc3BhblxuICAvLyBJZiB0aGUgUmVkaXMgREIgaXMgdXNlZCBhcyBhIGNhY2hlLCB0aGUgc3BhbiBkZXNjcmlwdGlvbiBzaG91bGQgbm90IGJlIGNoYW5nZWRcbiAgaWYgKGRiU3lzdGVtICYmICFvcElzQ2FjaGUpIHtcbiAgICByZXR1cm4gZGVzY3JpcHRpb25Gb3JEYlN5c3RlbSh7IGF0dHJpYnV0ZXMsIG5hbWUgfSk7XG4gIH1cblxuICAvLyBJZiBycGMuc2VydmljZSBleGlzdHMgdGhlbiB0aGlzIGlzIGEgcnBjIGNhbGwgc3Bhbi5cbiAgY29uc3QgcnBjU2VydmljZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19SUENfU0VSVklDRV07XG4gIGlmIChycGNTZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wOiAncnBjJyxcbiAgICAgIGRlc2NyaXB0aW9uOiBuYW1lLFxuICAgICAgc291cmNlOiAncm91dGUnLFxuICAgIH07XG4gIH1cblxuICAvLyBJZiBtZXNzYWdpbmcuc3lzdGVtIGV4aXN0cyB0aGVuIHRoaXMgaXMgYSBtZXNzYWdpbmcgc3lzdGVtIHNwYW4uXG4gIGNvbnN0IG1lc3NhZ2luZ1N5c3RlbSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19NRVNTQUdJTkdfU1lTVEVNXTtcbiAgaWYgKG1lc3NhZ2luZ1N5c3RlbSkge1xuICAgIHJldHVybiB7XG4gICAgICBvcDogJ21lc3NhZ2UnLFxuICAgICAgZGVzY3JpcHRpb246IG5hbWUsXG4gICAgICBzb3VyY2U6ICdyb3V0ZScsXG4gICAgfTtcbiAgfVxuXG4gIC8vIElmIGZhYXMudHJpZ2dlciBleGlzdHMgdGhlbiB0aGlzIGlzIGEgZnVuY3Rpb24gYXMgYSBzZXJ2aWNlIHNwYW4uXG4gIGNvbnN0IGZhYXNUcmlnZ2VyID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0ZBQVNfVFJJR0dFUl07XG4gIGlmIChmYWFzVHJpZ2dlcikge1xuICAgIHJldHVybiB7IG9wOiBmYWFzVHJpZ2dlci50b1N0cmluZygpLCBkZXNjcmlwdGlvbjogbmFtZSwgc291cmNlOiAncm91dGUnIH07XG4gIH1cblxuICByZXR1cm4geyBvcDogdW5kZWZpbmVkLCBkZXNjcmlwdGlvbjogbmFtZSwgc291cmNlOiAnY3VzdG9tJyB9O1xufVxuXG5mdW5jdGlvbiBkZXNjcmlwdGlvbkZvckRiU3lzdGVtKHsgYXR0cmlidXRlcywgbmFtZSB9KSB7XG4gIC8vIFVzZSBEQiBzdGF0ZW1lbnQgKEV4IFwiU0VMRUNUICogRlJPTSB0YWJsZVwiKSBpZiBwb3NzaWJsZSBhcyBkZXNjcmlwdGlvbi5cbiAgY29uc3Qgc3RhdGVtZW50ID0gYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0RCX1NUQVRFTUVOVF07XG5cbiAgY29uc3QgZGVzY3JpcHRpb24gPSBzdGF0ZW1lbnQgPyBzdGF0ZW1lbnQudG9TdHJpbmcoKSA6IG5hbWU7XG5cbiAgcmV0dXJuIHsgb3A6ICdkYicsIGRlc2NyaXB0aW9uLCBzb3VyY2U6ICd0YXNrJyB9O1xufVxuXG4vKiogT25seSBleHBvcnRlZCBmb3IgdGVzdHMuICovXG5mdW5jdGlvbiBkZXNjcmlwdGlvbkZvckh0dHBNZXRob2QoXG4gIHsgbmFtZSwga2luZCwgYXR0cmlidXRlcyB9LFxuICBodHRwTWV0aG9kLFxuKSB7XG4gIGNvbnN0IG9wUGFydHMgPSBbJ2h0dHAnXTtcblxuICBzd2l0Y2ggKGtpbmQpIHtcbiAgICBjYXNlIGFwaS5TcGFuS2luZC5DTElFTlQ6XG4gICAgICBvcFBhcnRzLnB1c2goJ2NsaWVudCcpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhcGkuU3BhbktpbmQuU0VSVkVSOlxuICAgICAgb3BQYXJ0cy5wdXNoKCdzZXJ2ZXInKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY29uc3QgeyB1cmxQYXRoLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGUgfSA9IGdldFNhbml0aXplZFVybChhdHRyaWJ1dGVzLCBraW5kKTtcblxuICBpZiAoIXVybFBhdGgpIHtcbiAgICByZXR1cm4geyBvcDogb3BQYXJ0cy5qb2luKCcuJyksIGRlc2NyaXB0aW9uOiBuYW1lLCBzb3VyY2U6ICdjdXN0b20nIH07XG4gIH1cblxuICAvLyBFeC4gZGVzY3JpcHRpb249XCJHRVQgL2FwaS91c2Vyc1wiLlxuICBjb25zdCBkZXNjcmlwdGlvbiA9IGAke2h0dHBNZXRob2R9ICR7dXJsUGF0aH1gO1xuXG4gIC8vIElmIGBodHRwUGF0aGAgaXMgYSByb290IHBhdGgsIHRoZW4gd2UgY2FuIGNhdGVnb3JpemUgdGhlIHRyYW5zYWN0aW9uIHNvdXJjZSBhcyByb3V0ZS5cbiAgY29uc3Qgc291cmNlID0gaGFzUm91dGUgfHwgdXJsUGF0aCA9PT0gJy8nID8gJ3JvdXRlJyA6ICd1cmwnO1xuXG4gIGNvbnN0IGRhdGEgPSB7fTtcblxuICBpZiAodXJsKSB7XG4gICAgZGF0YS51cmwgPSB1cmw7XG4gIH1cbiAgaWYgKHF1ZXJ5KSB7XG4gICAgZGF0YVsnaHR0cC5xdWVyeSddID0gcXVlcnk7XG4gIH1cbiAgaWYgKGZyYWdtZW50KSB7XG4gICAgZGF0YVsnaHR0cC5mcmFnbWVudCddID0gZnJhZ21lbnQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9wOiBvcFBhcnRzLmpvaW4oJy4nKSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBzb3VyY2UsXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuLyoqIEV4cG9ydGVkIGZvciB0ZXN0cyBvbmx5ICovXG5mdW5jdGlvbiBnZXRTYW5pdGl6ZWRVcmwoXG4gIGF0dHJpYnV0ZXMsXG4gIGtpbmQsXG4pXG5cbiB7XG4gIC8vIFRoaXMgaXMgdGhlIHJlbGF0aXZlIHBhdGggb2YgdGhlIFVSTCwgZS5nLiAvc3ViXG4gIGNvbnN0IGh0dHBUYXJnZXQgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9UQVJHRVRdO1xuICAvLyBUaGlzIGlzIHRoZSBmdWxsIFVSTCwgaW5jbHVkaW5nIGhvc3QgJiBxdWVyeSBwYXJhbXMgZXRjLiwgZS5nLiBodHRwczovL2V4YW1wbGUuY29tL3N1Yj9mb289YmFyXG4gIGNvbnN0IGh0dHBVcmwgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdO1xuICAvLyBUaGlzIGlzIHRoZSBub3JtYWxpemVkIHJvdXRlIG5hbWUgLSBtYXkgbm90IGFsd2F5cyBiZSBhdmFpbGFibGUhXG4gIGNvbnN0IGh0dHBSb3V0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1JPVVRFXTtcblxuICBjb25zdCBwYXJzZWRVcmwgPSB0eXBlb2YgaHR0cFVybCA9PT0gJ3N0cmluZycgPyB1dGlscy5wYXJzZVVybChodHRwVXJsKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdXJsID0gcGFyc2VkVXJsID8gdXRpbHMuZ2V0U2FuaXRpemVkVXJsU3RyaW5nKHBhcnNlZFVybCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHF1ZXJ5ID0gcGFyc2VkVXJsICYmIHBhcnNlZFVybC5zZWFyY2ggPyBwYXJzZWRVcmwuc2VhcmNoIDogdW5kZWZpbmVkO1xuICBjb25zdCBmcmFnbWVudCA9IHBhcnNlZFVybCAmJiBwYXJzZWRVcmwuaGFzaCA/IHBhcnNlZFVybC5oYXNoIDogdW5kZWZpbmVkO1xuXG4gIGlmICh0eXBlb2YgaHR0cFJvdXRlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7IHVybFBhdGg6IGh0dHBSb3V0ZSwgdXJsLCBxdWVyeSwgZnJhZ21lbnQsIGhhc1JvdXRlOiB0cnVlIH07XG4gIH1cblxuICBpZiAoa2luZCA9PT0gYXBpLlNwYW5LaW5kLlNFUlZFUiAmJiB0eXBlb2YgaHR0cFRhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiB1dGlscy5zdHJpcFVybFF1ZXJ5QW5kRnJhZ21lbnQoaHR0cFRhcmdldCksIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbiAgfVxuXG4gIGlmIChwYXJzZWRVcmwpIHtcbiAgICByZXR1cm4geyB1cmxQYXRoOiB1cmwsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbiAgfVxuXG4gIC8vIGZhbGwgYmFjayB0byB0YXJnZXQgZXZlbiBmb3IgY2xpZW50IHNwYW5zLCBpZiBubyBVUkwgaXMgcHJlc2VudFxuICBpZiAodHlwZW9mIGh0dHBUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgdXJsUGF0aDogdXRpbHMuc3RyaXBVcmxRdWVyeUFuZEZyYWdtZW50KGh0dHBUYXJnZXQpLCB1cmwsIHF1ZXJ5LCBmcmFnbWVudCwgaGFzUm91dGU6IGZhbHNlIH07XG4gIH1cblxuICByZXR1cm4geyB1cmxQYXRoOiB1bmRlZmluZWQsIHVybCwgcXVlcnksIGZyYWdtZW50LCBoYXNSb3V0ZTogZmFsc2UgfTtcbn1cblxuLyoqXG4gKiBTZXR1cCBhIERTQyBoYW5kbGVyIG9uIHRoZSBwYXNzZWQgY2xpZW50LFxuICogZW5zdXJpbmcgdGhhdCB0aGUgdHJhbnNhY3Rpb24gbmFtZSBpcyBpbmZlcnJlZCBmcm9tIHRoZSBzcGFuIGNvcnJlY3RseS5cbiAqL1xuZnVuY3Rpb24gZW5oYW5jZURzY1dpdGhPcGVuVGVsZW1ldHJ5Um9vdFNwYW5OYW1lKGNsaWVudCkge1xuICBjbGllbnQub24oJ2NyZWF0ZURzYycsIChkc2MsIHJvb3RTcGFuKSA9PiB7XG4gICAgLy8gV2Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBEU0MgdGhhdCBpcyBjcmVhdGVkIGJ5IGRlZmF1bHQgaW4gY29yZVxuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB3ZSB3YW50IHRvIGluZmVyIHRoZSBzcGFuIG5hbWUsIG5vdCB1c2UgdGhlIGluaXRpYWwgb25lXG4gICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBnZXQgbmFtZXMgbGlrZSBcIkdFVFwiIGluc3RlYWQgb2YgZS5nLiBcIkdFVCAvZm9vXCJcbiAgICAvLyBgcGFyc2VTcGFuRGVzY3JpcHRpb25gIHRha2VzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBzcGFuIGludG8gYWNjb3VudCBmb3IgdGhlIG5hbWVcbiAgICAvLyBUaGlzIG11dGF0ZXMgdGhlIHBhc3NlZC1pbiBEU0NcbiAgICBpZiAocm9vdFNwYW4pIHtcbiAgICAgIGNvbnN0IGpzb25TcGFuID0gY29yZS5zcGFuVG9KU09OKHJvb3RTcGFuKTtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBqc29uU3Bhbi5kYXRhIHx8IHt9O1xuICAgICAgY29uc3Qgc291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXTtcblxuICAgICAgY29uc3QgeyBkZXNjcmlwdGlvbiB9ID0gc3Bhbkhhc05hbWUocm9vdFNwYW4pID8gcGFyc2VTcGFuRGVzY3JpcHRpb24ocm9vdFNwYW4pIDogeyBkZXNjcmlwdGlvbjogdW5kZWZpbmVkIH07XG4gICAgICBpZiAoc291cmNlICE9PSAndXJsJyAmJiBkZXNjcmlwdGlvbikge1xuICAgICAgICBkc2MudHJhbnNhY3Rpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBhY3RpdmUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlU3BhbigpIHtcbiAgcmV0dXJuIGFwaS50cmFjZS5nZXRBY3RpdmVTcGFuKCk7XG59XG5cbi8qKlxuICogVGhpcyBzZXJ2ZXMgYXMgYSBidWlsZCB0aW1lIGZsYWcgdGhhdCB3aWxsIGJlIHRydWUgYnkgZGVmYXVsdCwgYnV0IGZhbHNlIGluIG5vbi1kZWJ1ZyBidWlsZHMgb3IgaWYgdXNlcnMgcmVwbGFjZSBgX19TRU5UUllfREVCVUdfX2AgaW4gdGhlaXIgZ2VuZXJhdGVkIGNvZGUuXG4gKlxuICogQVRURU5USU9OOiBUaGlzIGNvbnN0YW50IG11c3QgbmV2ZXIgY3Jvc3MgcGFja2FnZSBib3VuZGFyaWVzIChpLmUuIGJlIGV4cG9ydGVkKSB0byBndWFyYW50ZWUgdGhhdCBpdCBjYW4gYmUgdXNlZCBmb3IgdHJlZSBzaGFraW5nLlxuICovXG5jb25zdCBERUJVR19CVUlMRCA9ICh0eXBlb2YgX19TRU5UUllfREVCVUdfXyA9PT0gJ3VuZGVmaW5lZCcgfHwgX19TRU5UUllfREVCVUdfXyk7XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDcob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxuLyoqXG4gKiBPcGVuVGVsZW1ldHJ5IG9ubHkga25vd3MgYWJvdXQgU0FNUExFRCBvciBOT05FIGRlY2lzaW9uLFxuICogYnV0IGZvciB1cyBpdCBpcyBpbXBvcnRhbnQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHVuc2V0IGFuZCB1bnNhbXBsZWQuXG4gKlxuICogQm90aCBvZiB0aGVzZSBhcmUgaWRlbnRpZmllZCBhcyBgdHJhY2VGbGFncyA9PT0gVHJhY2VnRmxhZ3MuTk9ORWAsXG4gKiBidXQgd2UgYWRkaXRpb25hbGx5IGxvb2sgYXQgYSBzcGVjaWFsIHRyYWNlIHN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiB0aGVtLlxuICovXG5mdW5jdGlvbiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSB7XG4gIGNvbnN0IHsgdHJhY2VGbGFncywgdHJhY2VTdGF0ZSB9ID0gc3BhbkNvbnRleHQ7XG5cbiAgY29uc3Qgc2FtcGxlZE5vdFJlY29yZGluZyA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HKSA9PT0gJzEnIDogZmFsc2U7XG5cbiAgLy8gSWYgdHJhY2UgZmxhZyBpcyBgU0FNUExFRGAsIHdlIGludGVycHJldCB0aGlzIGFzIHNhbXBsZWRcbiAgLy8gSWYgaXQgaXMgYE5PTkVgLCBpdCBjb3VsZCBtZWFuIGVpdGhlciBpdCB3YXMgc2FtcGxlZCB0byBiZSBub3QgcmVjb3JkZXIsIG9yIHRoYXQgaXQgd2FzIG5vdCBzYW1wbGVkIGF0IGFsbFxuICAvLyBGb3IgdXMgdGhpcyBpcyBhbiBpbXBvcnRhbnQgZGlmZmVyZW5jZSwgc293IGUgbG9vayBhdCB0aGUgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElOR1xuICAvLyB0byBpZGVudGlmeSB3aGljaCBpdCBpc1xuICBpZiAodHJhY2VGbGFncyA9PT0gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNhbXBsZWROb3RSZWNvcmRpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGYWxsIGJhY2sgdG8gRFNDIGFzIGEgbGFzdCByZXNvcnQsIHRoYXQgbWF5IGFsc28gY29udGFpbiBgc2FtcGxlZGAuLi5cbiAgY29uc3QgZHNjU3RyaW5nID0gdHJhY2VTdGF0ZSA/IHRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MpIDogdW5kZWZpbmVkO1xuICBjb25zdCBkc2MgPSBkc2NTdHJpbmcgPyB1dGlscy5iYWdnYWdlSGVhZGVyVG9EeW5hbWljU2FtcGxpbmdDb250ZXh0KGRzY1N0cmluZykgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKF9vcHRpb25hbENoYWluJDcoW2RzYywgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnNhbXBsZWRdKSA9PT0gJ3RydWUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKF9vcHRpb25hbENoYWluJDcoW2RzYywgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuc2FtcGxlZF0pID09PSAnZmFsc2UnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3Qgc2V0dXBFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuLyoqIEdldCBhbGwgdGhlIE9wZW5UZWxlbWV0cnkgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gc2V0IHVwLiAqL1xuZnVuY3Rpb24gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2soKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNldHVwRWxlbWVudHMpO1xufVxuXG4vKiogTWFyayBhbiBPcGVuVGVsZW1ldHJ5IGVsZW1lbnQgYXMgc2V0dXAuICovXG5mdW5jdGlvbiBzZXRJc1NldHVwKGVsZW1lbnQpIHtcbiAgc2V0dXBFbGVtZW50cy5hZGQoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDYob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cblxuLyoqIEdldCB0aGUgU2VudHJ5IHByb3BhZ2F0aW9uIGNvbnRleHQgZnJvbSBhIHNwYW4gY29udGV4dC4gKi9cbmZ1bmN0aW9uIGdldFByb3BhZ2F0aW9uQ29udGV4dEZyb21TcGFuKHNwYW4pIHtcbiAgY29uc3Qgc3BhbkNvbnRleHQgPSBzcGFuLnNwYW5Db250ZXh0KCk7XG4gIGNvbnN0IHsgdHJhY2VJZCwgc3BhbklkLCB0cmFjZVN0YXRlIH0gPSBzcGFuQ29udGV4dDtcblxuICAvLyBXaGVuIHdlIGhhdmUgYSBkc2MgdHJhY2Ugc3RhdGUsIGl0IG1lYW5zIHRoaXMgY2FtZSBmcm9tIHRoZSBpbmNvbWluZyB0cmFjZVxuICAvLyBUaGVuIHRoaXMgdGFrZXMgcHJlc2VkZW5jZSBvdmVyIHRoZSByb290IHNwYW5cbiAgY29uc3QgZHNjU3RyaW5nID0gdHJhY2VTdGF0ZSA/IHRyYWNlU3RhdGUuZ2V0KFNFTlRSWV9UUkFDRV9TVEFURV9EU0MpIDogdW5kZWZpbmVkO1xuICBjb25zdCB0cmFjZVN0YXRlRHNjID0gZHNjU3RyaW5nID8gdXRpbHMuYmFnZ2FnZUhlYWRlclRvRHluYW1pY1NhbXBsaW5nQ29udGV4dChkc2NTdHJpbmcpIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IHBhcmVudFNwYW5JZCA9IHRyYWNlU3RhdGUgPyB0cmFjZVN0YXRlLmdldChTRU5UUllfVFJBQ0VfU1RBVEVfUEFSRU5UX1NQQU5fSUQpIHx8IHVuZGVmaW5lZCA6IHVuZGVmaW5lZDtcblxuICBjb25zdCBzYW1wbGVkID0gZ2V0U2FtcGxpbmdEZWNpc2lvbihzcGFuQ29udGV4dCk7XG5cbiAgLy8gTm8gdHJhY2Ugc3RhdGU/IC0tPiBUYWtlIERTQyBmcm9tIHJvb3Qgc3BhblxuICBjb25zdCBkc2MgPSB0cmFjZVN0YXRlRHNjIHx8IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKGNvcmUuZ2V0Um9vdFNwYW4oc3BhbikpO1xuXG4gIHJldHVybiB7XG4gICAgdHJhY2VJZCxcbiAgICBzcGFuSWQsXG4gICAgc2FtcGxlZCxcbiAgICBwYXJlbnRTcGFuSWQsXG4gICAgZHNjLFxuICB9O1xufVxuXG4vKipcbiAqIEluamVjdHMgYW5kIGV4dHJhY3RzIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgaGVhZGVycyBmcm9tIGNhcnJpZXJzLlxuICovXG5jbGFzcyBTZW50cnlQcm9wYWdhdG9yIGV4dGVuZHMgY29yZSQxLlczQ0JhZ2dhZ2VQcm9wYWdhdG9yIHtcbiAgLyoqIEEgbWFwIG9mIFVSTHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBjaGVja2VkIGZvciBpZiB0aGV5IG1hdGNoIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLiAqL1xuXG4gICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVByb3BhZ2F0b3InKTtcblxuICAgIC8vIFdlJ3JlIGNhY2hpbmcgcmVzdWx0cyBzbyB3ZSBkb24ndCBoYXZlIHRvIHJlY29tcHV0ZSByZWdleHAgZXZlcnkgdGltZSB3ZSBjcmVhdGUgYSByZXF1ZXN0LlxuICAgIHRoaXMuX3VybE1hdGNoZXNUYXJnZXRzTWFwID0gbmV3IHV0aWxzLkxSVU1hcCgxMDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICAgaW5qZWN0KGNvbnRleHQsIGNhcnJpZXIsIHNldHRlcikge1xuICAgIGlmIChjb3JlJDEuaXNUcmFjaW5nU3VwcHJlc3NlZChjb250ZXh0KSkge1xuICAgICAgREVCVUdfQlVJTEQgJiYgdXRpbHMubG9nZ2VyLmxvZygnW1RyYWNpbmddIE5vdCBpbmplY3RpbmcgdHJhY2UgZGF0YSBmb3IgdXJsIGJlY2F1c2UgdHJhY2luZyBpcyBzdXBwcmVzc2VkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZVNwYW4gPSBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KTtcbiAgICBjb25zdCB1cmwgPSBhY3RpdmVTcGFuICYmIGdldEN1cnJlbnRVUkwoYWN0aXZlU3Bhbik7XG5cbiAgICBjb25zdCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0cyA9IF9vcHRpb25hbENoYWluJDYoW2NvcmUuZ2V0Q2xpZW50LCAnY2FsbCcsIF8gPT4gXygpLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMiA9PiBfMi5nZXRPcHRpb25zLCAnY2FsbCcsIF8zID0+IF8zKCksICdvcHRpb25hbEFjY2VzcycsIF80ID0+IF80LnRyYWNlUHJvcGFnYXRpb25UYXJnZXRzXSk7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHVybCA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzICYmXG4gICAgICAhdGhpcy5fc2hvdWxkSW5qZWN0VHJhY2VEYXRhKHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLCB1cmwpXG4gICAgKSB7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICB1dGlscy5sb2dnZXIubG9nKFxuICAgICAgICAgICdbVHJhY2luZ10gTm90IGluamVjdGluZyB0cmFjZSBkYXRhIGZvciB1cmwgYmVjYXVzZSBpdCBkb2VzIG5vdCBtYXRjaCB0cmFjZVByb3BhZ2F0aW9uVGFyZ2V0czonLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdGluZ0JhZ2dhZ2VIZWFkZXIgPSBnZXRFeGlzdGluZ0JhZ2dhZ2UoY2Fycmllcik7XG4gICAgbGV0IGJhZ2dhZ2UgPSBhcGkucHJvcGFnYXRpb24uZ2V0QmFnZ2FnZShjb250ZXh0KSB8fCBhcGkucHJvcGFnYXRpb24uY3JlYXRlQmFnZ2FnZSh7fSk7XG5cbiAgICBjb25zdCB7IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsIHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCB9ID0gZ2V0SW5qZWN0aW9uRGF0YShjb250ZXh0KTtcblxuICAgIGlmIChleGlzdGluZ0JhZ2dhZ2VIZWFkZXIpIHtcbiAgICAgIGNvbnN0IGJhZ2dhZ2VFbnRyaWVzID0gdXRpbHMucGFyc2VCYWdnYWdlSGVhZGVyKGV4aXN0aW5nQmFnZ2FnZUhlYWRlcik7XG5cbiAgICAgIGlmIChiYWdnYWdlRW50cmllcykge1xuICAgICAgICBPYmplY3QuZW50cmllcyhiYWdnYWdlRW50cmllcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgYmFnZ2FnZSA9IGJhZ2dhZ2Uuc2V0RW50cnkoa2V5LCB7IHZhbHVlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZHluYW1pY1NhbXBsaW5nQ29udGV4dCkge1xuICAgICAgYmFnZ2FnZSA9IE9iamVjdC5lbnRyaWVzKGR5bmFtaWNTYW1wbGluZ0NvbnRleHQpLnJlZHVjZSgoYiwgW2RzY0tleSwgZHNjVmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChkc2NWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiLnNldEVudHJ5KGAke3V0aWxzLlNFTlRSWV9CQUdHQUdFX0tFWV9QUkVGSVh9JHtkc2NLZXl9YCwgeyB2YWx1ZTogZHNjVmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9LCBiYWdnYWdlKTtcbiAgICB9XG5cbiAgICAvLyBXZSBhbHNvIHdhbnQgdG8gYXZvaWQgc2V0dGluZyB0aGUgZGVmYXVsdCBPVEVMIHRyYWNlIElELCBpZiB3ZSBnZXQgdGhhdCBmb3Igd2hhdGV2ZXIgcmVhc29uXG4gICAgaWYgKHRyYWNlSWQgJiYgdHJhY2VJZCAhPT0gYXBpLklOVkFMSURfVFJBQ0VJRCkge1xuICAgICAgc2V0dGVyLnNldChjYXJyaWVyLCBTRU5UUllfVFJBQ0VfSEVBREVSLCB1dGlscy5nZW5lcmF0ZVNlbnRyeVRyYWNlSGVhZGVyKHRyYWNlSWQsIHNwYW5JZCwgc2FtcGxlZCkpO1xuICAgIH1cblxuICAgIHN1cGVyLmluamVjdChhcGkucHJvcGFnYXRpb24uc2V0QmFnZ2FnZShjb250ZXh0LCBiYWdnYWdlKSwgY2Fycmllciwgc2V0dGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGV4dHJhY3QoY29udGV4dCwgY2FycmllciwgZ2V0dGVyKSB7XG4gICAgY29uc3QgbWF5YmVTZW50cnlUcmFjZUhlYWRlciA9IGdldHRlci5nZXQoY2FycmllciwgU0VOVFJZX1RSQUNFX0hFQURFUik7XG4gICAgY29uc3QgYmFnZ2FnZSA9IGdldHRlci5nZXQoY2FycmllciwgU0VOVFJZX0JBR0dBR0VfSEVBREVSKTtcblxuICAgIGNvbnN0IHNlbnRyeVRyYWNlID0gbWF5YmVTZW50cnlUcmFjZUhlYWRlclxuICAgICAgPyBBcnJheS5pc0FycmF5KG1heWJlU2VudHJ5VHJhY2VIZWFkZXIpXG4gICAgICAgID8gbWF5YmVTZW50cnlUcmFjZUhlYWRlclswXVxuICAgICAgICA6IG1heWJlU2VudHJ5VHJhY2VIZWFkZXJcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gdXRpbHMucHJvcGFnYXRpb25Db250ZXh0RnJvbUhlYWRlcnMoc2VudHJ5VHJhY2UsIGJhZ2dhZ2UpO1xuXG4gICAgLy8gQWRkIHJlbW90ZSBwYXJlbnQgc3BhbiBjb250ZXh0XG4gICAgY29uc3QgY3R4V2l0aFNwYW5Db250ZXh0ID0gZ2V0Q29udGV4dFdpdGhSZW1vdGVBY3RpdmVTcGFuKGNvbnRleHQsIHsgc2VudHJ5VHJhY2UsIGJhZ2dhZ2UgfSk7XG5cbiAgICAvLyBBbHNvIHVwZGF0ZSB0aGUgc2NvcGUgb24gdGhlIGNvbnRleHQgKHRvIGJlIHN1cmUgdGhpcyBpcyBwaWNrZWQgdXAgZXZlcnl3aGVyZSlcbiAgICBjb25zdCBzY29wZXMgPSBnZXRTY29wZXNGcm9tQ29udGV4dChjdHhXaXRoU3BhbkNvbnRleHQpO1xuICAgIGNvbnN0IG5ld1Njb3BlcyA9IHtcbiAgICAgIHNjb3BlOiBzY29wZXMgPyBzY29wZXMuc2NvcGUuY2xvbmUoKSA6IGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkuY2xvbmUoKSxcbiAgICAgIGlzb2xhdGlvblNjb3BlOiBzY29wZXMgPyBzY29wZXMuaXNvbGF0aW9uU2NvcGUgOiBjb3JlLmdldElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgICBuZXdTY29wZXMuc2NvcGUuc2V0UHJvcGFnYXRpb25Db250ZXh0KHByb3BhZ2F0aW9uQ29udGV4dCk7XG5cbiAgICByZXR1cm4gc2V0U2NvcGVzT25Db250ZXh0KGN0eFdpdGhTcGFuQ29udGV4dCwgbmV3U2NvcGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGZpZWxkcygpIHtcbiAgICByZXR1cm4gW1NFTlRSWV9UUkFDRV9IRUFERVIsIFNFTlRSWV9CQUdHQUdFX0hFQURFUl07XG4gIH1cblxuICAvKiogSWYgd2Ugd2FudCB0byBpbmplY3QgdHJhY2UgZGF0YSBmb3IgYSBnaXZlbiBVUkwuICovXG4gICBfc2hvdWxkSW5qZWN0VHJhY2VEYXRhKHRyYWNlUHJvcGFnYXRpb25UYXJnZXRzLCB1cmwpIHtcbiAgICBpZiAodHJhY2VQcm9wYWdhdGlvblRhcmdldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgY2FjaGVkRGVjaXNpb24gPSB0aGlzLl91cmxNYXRjaGVzVGFyZ2V0c01hcC5nZXQodXJsKTtcbiAgICBpZiAoY2FjaGVkRGVjaXNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZERlY2lzaW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGRlY2lzaW9uID0gdXRpbHMuc3RyaW5nTWF0Y2hlc1NvbWVQYXR0ZXJuKHVybCwgdHJhY2VQcm9wYWdhdGlvblRhcmdldHMpO1xuICAgIHRoaXMuX3VybE1hdGNoZXNUYXJnZXRzTWFwLnNldCh1cmwsIGRlY2lzaW9uKTtcbiAgICByZXR1cm4gZGVjaXNpb247XG4gIH1cbn1cblxuLyoqIEV4cG9ydGVkIGZvciB0ZXN0cy4gKi9cbmZ1bmN0aW9uIG1ha2VUcmFjZVN0YXRlKHtcbiAgcGFyZW50U3BhbklkLFxuICBkc2MsXG4gIHNhbXBsZWQsXG59XG5cbikge1xuICAvLyBXZSBzdG9yZSB0aGUgRFNDIGFzIE9URUwgdHJhY2Ugc3RhdGUgb24gdGhlIHNwYW4gY29udGV4dFxuICBjb25zdCBkc2NTdHJpbmcgPSBkc2MgPyB1dGlscy5keW5hbWljU2FtcGxpbmdDb250ZXh0VG9TZW50cnlCYWdnYWdlSGVhZGVyKGRzYykgOiB1bmRlZmluZWQ7XG5cbiAgLy8gV2UgX2Fsd2F5c18gc2V0IHRoZSBwYXJlbnQgc3BhbiBJRCwgZXZlbiBpZiBpdCBpcyBlbXB0eVxuICAvLyBJZiB3ZSdkIHNldCB0aGlzIHRvICd1bmRlZmluZWQnIHdlIGNvdWxkIG5vdCBrbm93IGlmIHRoZSB0cmFjZSBzdGF0ZSB3YXMgc2V0LCBidXQgdGhlcmUgd2FzIG5vIHBhcmVudFNwYW5JZCxcbiAgLy8gdnMgdGhlIHRyYWNlIHN0YXRlIHdhcyBub3Qgc2V0IGF0IGFsbCAoaW4gd2hpY2ggY2FzZSB3ZSB3YW50IHRvIGRvIGZhbGxiYWNrIGhhbmRsaW5nKVxuICAvLyBJZiBgJydgLCBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBcIm5vIHBhcmVudFwiXG4gIGNvbnN0IHRyYWNlU3RhdGVCYXNlID0gbmV3IGNvcmUkMS5UcmFjZVN0YXRlKCkuc2V0KFNFTlRSWV9UUkFDRV9TVEFURV9QQVJFTlRfU1BBTl9JRCwgcGFyZW50U3BhbklkIHx8ICcnKTtcblxuICBjb25zdCB0cmFjZVN0YXRlV2l0aERzYyA9IGRzY1N0cmluZyA/IHRyYWNlU3RhdGVCYXNlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfRFNDLCBkc2NTdHJpbmcpIDogdHJhY2VTdGF0ZUJhc2U7XG5cbiAgLy8gV2UgYWxzbyBzcGVjaWZpY2FsbHkgd2FudCB0byBzdG9yZSBpZiB0aGlzIGlzIHNhbXBsZWQgdG8gYmUgbm90IHJlY29yZGluZyxcbiAgLy8gb3IgdW5zYW1wbGVkICg9Y291bGQgYmUgZWl0aGVyIHNhbXBsZWQgb3Igbm90KVxuICByZXR1cm4gc2FtcGxlZCA9PT0gZmFsc2UgPyB0cmFjZVN0YXRlV2l0aERzYy5zZXQoU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElORywgJzEnKSA6IHRyYWNlU3RhdGVXaXRoRHNjO1xufVxuXG5mdW5jdGlvbiBnZXRJbmplY3Rpb25EYXRhKGNvbnRleHQpXG5cbiB7XG4gIGNvbnN0IHNwYW4gPSBjb3JlLmhhc1RyYWNpbmdFbmFibGVkKCkgPyBhcGkudHJhY2UuZ2V0U3Bhbihjb250ZXh0KSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgc3BhbklzUmVtb3RlID0gX29wdGlvbmFsQ2hhaW4kNihbc3BhbiwgJ29wdGlvbmFsQWNjZXNzJywgXzUgPT4gXzUuc3BhbkNvbnRleHQsICdjYWxsJywgXzYgPT4gXzYoKSwgJ2FjY2VzcycsIF83ID0+IF83LmlzUmVtb3RlXSk7XG5cbiAgLy8gSWYgd2UgaGF2ZSBhIGxvY2FsIHNwYW4sIHdlIGNhbiBqdXN0IHBpY2sgZXZlcnl0aGluZyBmcm9tIGl0XG4gIGlmIChzcGFuICYmICFzcGFuSXNSZW1vdGUpIHtcbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAgIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IGdldFByb3BhZ2F0aW9uQ29udGV4dEZyb21TcGFuKHNwYW4pO1xuICAgIGNvbnN0IGR5bmFtaWNTYW1wbGluZ0NvbnRleHQgPSBnZXREeW5hbWljU2FtcGxpbmdDb250ZXh0KHByb3BhZ2F0aW9uQ29udGV4dCwgc3BhbkNvbnRleHQudHJhY2VJZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQsXG4gICAgICB0cmFjZUlkOiBzcGFuQ29udGV4dC50cmFjZUlkLFxuICAgICAgc3BhbklkOiBzcGFuQ29udGV4dC5zcGFuSWQsXG4gICAgICBzYW1wbGVkOiBnZXRTYW1wbGluZ0RlY2lzaW9uKHNwYW5Db250ZXh0KSxcbiAgICB9O1xuICB9XG5cbiAgLy8gRWxzZSB3ZSB0cnkgdG8gdXNlIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0IGZyb20gdGhlIHNjb3BlXG4gIGNvbnN0IHNjb3BlID0gX29wdGlvbmFsQ2hhaW4kNihbZ2V0U2NvcGVzRnJvbUNvbnRleHQsICdjYWxsJywgXzggPT4gXzgoY29udGV4dCksICdvcHRpb25hbEFjY2VzcycsIF85ID0+IF85LnNjb3BlXSkgfHwgY29yZS5nZXRDdXJyZW50U2NvcGUoKTtcblxuICBjb25zdCBwcm9wYWdhdGlvbkNvbnRleHQgPSBzY29wZS5nZXRQcm9wYWdhdGlvbkNvbnRleHQoKTtcbiAgY29uc3QgZHluYW1pY1NhbXBsaW5nQ29udGV4dCA9IGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHQocHJvcGFnYXRpb25Db250ZXh0LCBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCk7XG4gIHJldHVybiB7XG4gICAgZHluYW1pY1NhbXBsaW5nQ29udGV4dCxcbiAgICB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCxcbiAgICBzcGFuSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5zcGFuSWQsXG4gICAgc2FtcGxlZDogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQsXG4gIH07XG59XG5cbi8qKiBHZXQgdGhlIERTQyBmcm9tIGEgY29udGV4dCwgb3IgZmFsbCBiYWNrIHRvIHVzZSB0aGUgb25lIGZyb20gdGhlIGNsaWVudC4gKi9cbmZ1bmN0aW9uIGdldER5bmFtaWNTYW1wbGluZ0NvbnRleHQoXG4gIHByb3BhZ2F0aW9uQ29udGV4dCxcbiAgdHJhY2VJZCxcbikge1xuICAvLyBJZiB3ZSBoYXZlIGEgRFNDIG9uIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0LCB3ZSBqdXN0IHVzZSBpdFxuICBpZiAoX29wdGlvbmFsQ2hhaW4kNihbcHJvcGFnYXRpb25Db250ZXh0LCAnb3B0aW9uYWxBY2Nlc3MnLCBfMTAgPT4gXzEwLmRzY10pKSB7XG4gICAgcmV0dXJuIHByb3BhZ2F0aW9uQ29udGV4dC5kc2M7XG4gIH1cblxuICAvLyBFbHNlLCB3ZSB0cnkgdG8gZ2VuZXJhdGUgYSBuZXcgb25lXG4gIGNvbnN0IGNsaWVudCA9IGNvcmUuZ2V0Q2xpZW50KCk7XG5cbiAgaWYgKGNsaWVudCkge1xuICAgIHJldHVybiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tQ2xpZW50KHRyYWNlSWQgfHwgcHJvcGFnYXRpb25Db250ZXh0LnRyYWNlSWQsIGNsaWVudCk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0V2l0aFJlbW90ZUFjdGl2ZVNwYW4oXG4gIGN0eCxcbiAgeyBzZW50cnlUcmFjZSwgYmFnZ2FnZSB9LFxuKSB7XG4gIGNvbnN0IHByb3BhZ2F0aW9uQ29udGV4dCA9IHV0aWxzLnByb3BhZ2F0aW9uQ29udGV4dEZyb21IZWFkZXJzKHNlbnRyeVRyYWNlLCBiYWdnYWdlKTtcblxuICAvLyBXZSBzdG9yZSB0aGUgRFNDIGFzIE9URUwgdHJhY2Ugc3RhdGUgb24gdGhlIHNwYW4gY29udGV4dFxuICBjb25zdCB0cmFjZVN0YXRlID0gbWFrZVRyYWNlU3RhdGUoe1xuICAgIHBhcmVudFNwYW5JZDogcHJvcGFnYXRpb25Db250ZXh0LnBhcmVudFNwYW5JZCxcbiAgICBkc2M6IHByb3BhZ2F0aW9uQ29udGV4dC5kc2MsXG4gICAgc2FtcGxlZDogcHJvcGFnYXRpb25Db250ZXh0LnNhbXBsZWQsXG4gIH0pO1xuXG4gIGNvbnN0IHNwYW5Db250ZXh0ID0ge1xuICAgIHRyYWNlSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC50cmFjZUlkLFxuICAgIHNwYW5JZDogcHJvcGFnYXRpb25Db250ZXh0LnBhcmVudFNwYW5JZCB8fCAnJyxcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICB0cmFjZUZsYWdzOiBwcm9wYWdhdGlvbkNvbnRleHQuc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgIHRyYWNlU3RhdGUsXG4gIH07XG5cbiAgcmV0dXJuIGFwaS50cmFjZS5zZXRTcGFuQ29udGV4dChjdHgsIHNwYW5Db250ZXh0KTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0cmFjZSBzdHJpbmdzIGFuZCBwcm9wYWdhdGVzIHRoZW0gYXMgYSByZW1vdGUgYWN0aXZlIHNwYW4uXG4gKiBUaGlzIHNob3VsZCBiZSB1c2VkIGluIGFkZGl0aW9uIHRvIGBjb250aW51ZVRyYWNlYCBpbiBPVEVMLXBvd2VyZWQgZW52aXJvbm1lbnRzLlxuICovXG5mdW5jdGlvbiBjb250aW51ZVRyYWNlQXNSZW1vdGVTcGFuKFxuICBjdHgsXG4gIG9wdGlvbnMsXG4gIGNhbGxiYWNrLFxuKSB7XG4gIGNvbnN0IGN0eFdpdGhTcGFuQ29udGV4dCA9IGdldENvbnRleHRXaXRoUmVtb3RlQWN0aXZlU3BhbihjdHgsIG9wdGlvbnMpO1xuXG4gIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eFdpdGhTcGFuQ29udGV4dCwgY2FsbGJhY2spO1xufVxuXG4vKiogVHJ5IHRvIGdldCB0aGUgZXhpc3RpbmcgYmFnZ2FnZSBoZWFkZXIgc28gd2UgY2FuIG1lcmdlIHRoaXMgaW4uICovXG5mdW5jdGlvbiBnZXRFeGlzdGluZ0JhZ2dhZ2UoY2Fycmllcikge1xuICB0cnkge1xuICAgIGNvbnN0IGJhZ2dhZ2UgPSAoY2FycmllciApW1NFTlRSWV9CQUdHQUdFX0hFQURFUl07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYmFnZ2FnZSkgPyBiYWdnYWdlLmpvaW4oJywnKSA6IGJhZ2dhZ2U7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogSXQgaXMgcHJldHR5IHRyaWNreSB0byBnZXQgYWNjZXNzIHRvIHRoZSBvdXRnb2luZyByZXF1ZXN0IFVSTCBvZiBhIHJlcXVlc3QgaW4gdGhlIHByb3BhZ2F0b3IuXG4gKiBBcyB3ZSBvbmx5IGhhdmUgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9mIHRoZSBzcGFuIHRvIGJlIHNlbnQgYW5kIHRoZSBjYXJyaWVyICg9aGVhZGVycyksXG4gKiBidXQgdGhlIHNwYW4gbWF5IGJlIHVuc2FtcGxlZCBhbmQgdGh1cyBoYXZlIG5vIGF0dHJpYnV0ZXMuXG4gKlxuICogU28gd2UgdXNlIHRoZSBmb2xsb3dpbmcgbG9naWM6XG4gKiAxLiBJZiB3ZSBoYXZlIGFuIGFjdGl2ZSBzcGFuLCB3ZSBjaGVjayBpZiBpdCBoYXMgYSBVUkwgYXR0cmlidXRlLlxuICogMi4gRWxzZSwgaWYgdGhlIGFjdGl2ZSBzcGFuIGhhcyBubyBVUkwgYXR0cmlidXRlIChlLmcuIGl0IGlzIHVuc2FtcGxlZCksIHdlIGNoZWNrIGEgc3BlY2lhbCB0cmFjZSBzdGF0ZSAod2hpY2ggd2Ugc2V0IGluIG91ciBzYW1wbGVyKS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFVSTChzcGFuKSB7XG4gIGNvbnN0IHVybEF0dHJpYnV0ZSA9IF9vcHRpb25hbENoYWluJDYoW2NvcmUuc3BhblRvSlNPTiwgJ2NhbGwnLCBfMTEgPT4gXzExKHNwYW4pLCAnYWNjZXNzJywgXzEyID0+IF8xMi5kYXRhLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMTMgPT4gXzEzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfSFRUUF9VUkxdXSk7XG4gIGlmICh1cmxBdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gdXJsQXR0cmlidXRlO1xuICB9XG5cbiAgLy8gQWxzbyBsb29rIGF0IHRoZSB0cmFjZVN0YXRlLCB3aGljaCB3ZSBtYXkgc2V0IGluIHRoZSBzYW1wbGVyIGV2ZW4gZm9yIHVuc2FtcGxlZCBzcGFuc1xuICBjb25zdCB1cmxUcmFjZVN0YXRlID0gX29wdGlvbmFsQ2hhaW4kNihbc3BhbiwgJ2FjY2VzcycsIF8xNCA9PiBfMTQuc3BhbkNvbnRleHQsICdjYWxsJywgXzE1ID0+IF8xNSgpLCAnYWNjZXNzJywgXzE2ID0+IF8xNi50cmFjZVN0YXRlLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMTcgPT4gXzE3LmdldCwgJ2NhbGwnLCBfMTggPT4gXzE4KFNFTlRSWV9UUkFDRV9TVEFURV9VUkwpXSk7XG4gIGlmICh1cmxUcmFjZVN0YXRlKSB7XG4gICAgcmV0dXJuIHVybFRyYWNlU3RhdGU7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfb3B0aW9uYWxDaGFpbiQ1KG9wcykgeyBsZXQgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgbGV0IHZhbHVlID0gb3BzWzBdOyBsZXQgaSA9IDE7IHdoaWxlIChpIDwgb3BzLmxlbmd0aCkgeyBjb25zdCBvcCA9IG9wc1tpXTsgY29uc3QgZm4gPSBvcHNbaSArIDFdOyBpICs9IDI7IGlmICgob3AgPT09ICdvcHRpb25hbEFjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSAmJiB2YWx1ZSA9PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gaWYgKG9wID09PSAnYWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJykgeyBsYXN0QWNjZXNzTEhTID0gdmFsdWU7IHZhbHVlID0gZm4odmFsdWUpOyB9IGVsc2UgaWYgKG9wID09PSAnY2FsbCcgfHwgb3AgPT09ICdvcHRpb25hbENhbGwnKSB7IHZhbHVlID0gZm4oKC4uLmFyZ3MpID0+IHZhbHVlLmNhbGwobGFzdEFjY2Vzc0xIUywgLi4uYXJncykpOyBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyB9IH0gcmV0dXJuIHZhbHVlOyB9XG5cbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiB3aXRoIGEgdHJhbnNhY3Rpb24vc3BhbiBhbmQgZmluaXNoZXMgdGhlIHNwYW4gYWZ0ZXIgdGhlIGZ1bmN0aW9uIGlzIGRvbmUuXG4gKiBUaGUgY3JlYXRlZCBzcGFuIGlzIHRoZSBhY3RpdmUgc3BhbiBhbmQgd2lsbCBiZSB1c2VkIGFzIHBhcmVudCBieSBvdGhlciBzcGFucyBjcmVhdGVkIGluc2lkZSB0aGUgZnVuY3Rpb25cbiAqIGFuZCBjYW4gYmUgYWNjZXNzZWQgdmlhIGBTZW50cnkuZ2V0QWN0aXZlU3BhbigpYCwgYXMgbG9uZyBhcyB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2hpbGUgdGhlIHNjb3BlIGlzIGFjdGl2ZS5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBjcmVhdGUgYSBzcGFuIHRoYXQgaXMgbm90IHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRJbmFjdGl2ZVNwYW59LlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuXG4gIGNvbnN0IHsgbmFtZSwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSBnZXRDb250ZXh0KG9wdGlvbnMuc2NvcGUsIG9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhYXBpLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBjdHggPSBzaG91bGRTa2lwU3BhbiA/IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYWN0aXZlQ3R4KSA6IGFjdGl2ZUN0eDtcblxuICAgIGNvbnN0IHNwYW5PcHRpb25zID0gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihuYW1lLCBzcGFuT3B0aW9ucywgY3R4LCBzcGFuID0+IHtcbiAgICAgIF9hcHBseVNlbnRyeUF0dHJpYnV0ZXNUb1NwYW4oc3Bhbiwgb3B0aW9ucyk7XG5cbiAgICAgIHJldHVybiBjb3JlLmhhbmRsZUNhbGxiYWNrRXJyb3JzKFxuICAgICAgICAoKSA9PiBjYWxsYmFjayhzcGFuKSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIC8vIE9ubHkgc2V0IHRoZSBzcGFuIHN0YXR1cyB0byBFUlJPUiB3aGVuIHRoZXJlIHdhc24ndCBhbnkgc3RhdHVzIHNldCBiZWZvcmUsIGluIG9yZGVyIHRvIGF2b2lkIHN0b21waW5nIHVzZWZ1bCBzcGFuIHN0YXR1c2VzXG4gICAgICAgICAgaWYgKGNvcmUuc3BhblRvSlNPTihzcGFuKS5zdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGkuU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiBzcGFuLmVuZCgpLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgU2VudHJ5LnN0YXJ0U3BhbmAuIFdyYXBzIGEgZnVuY3Rpb24gd2l0aCBhIHNwYW4sIGJ1dCBkb2VzIG5vdCBmaW5pc2ggdGhlIHNwYW5cbiAqIGFmdGVyIHRoZSBmdW5jdGlvbiBpcyBkb25lIGF1dG9tYXRpY2FsbHkuIFlvdSdsbCBoYXZlIHRvIGNhbGwgYHNwYW4uZW5kKClgIG1hbnVhbGx5LlxuICpcbiAqIFRoZSBjcmVhdGVkIHNwYW4gaXMgdGhlIGFjdGl2ZSBzcGFuIGFuZCB3aWxsIGJlIHVzZWQgYXMgcGFyZW50IGJ5IG90aGVyIHNwYW5zIGNyZWF0ZWQgaW5zaWRlIHRoZSBmdW5jdGlvblxuICogYW5kIGNhbiBiZSBhY2Nlc3NlZCB2aWEgYFNlbnRyeS5nZXRBY3RpdmVTcGFuKClgLCBhcyBsb25nIGFzIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCB3aGlsZSB0aGUgc2NvcGUgaXMgYWN0aXZlLlxuICpcbiAqIFlvdSdsbCBhbHdheXMgZ2V0IGEgc3BhbiBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLFxuICogaXQgbWF5IGp1c3QgYmUgYSBub24tcmVjb3JkaW5nIHNwYW4gaWYgdGhlIHNwYW4gaXMgbm90IHNhbXBsZWQgb3IgaWYgdHJhY2luZyBpcyBkaXNhYmxlZC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRTcGFuTWFudWFsKFxuICBvcHRpb25zLFxuICBjYWxsYmFjayxcbikge1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIoKTtcblxuICBjb25zdCB7IG5hbWUsIHBhcmVudFNwYW46IGN1c3RvbVBhcmVudFNwYW4gfSA9IG9wdGlvbnM7XG5cbiAgLy8gSWYgYG9wdGlvbnMucGFyZW50U3BhbmAgaXMgZGVmaW5lZCwgd2Ugd2FudCB0byB3cmFwIHRoZSBjYWxsYmFjayBpbiBgd2l0aEFjdGl2ZVNwYW5gXG4gIGNvbnN0IHdyYXBwZXIgPSBnZXRBY3RpdmVTcGFuV3JhcHBlcihjdXN0b21QYXJlbnRTcGFuKTtcblxuICByZXR1cm4gd3JhcHBlcigoKSA9PiB7XG4gICAgY29uc3QgYWN0aXZlQ3R4ID0gZ2V0Q29udGV4dChvcHRpb25zLnNjb3BlLCBvcHRpb25zLmZvcmNlVHJhbnNhY3Rpb24pO1xuICAgIGNvbnN0IHNob3VsZFNraXBTcGFuID0gb3B0aW9ucy5vbmx5SWZQYXJlbnQgJiYgIWFwaS50cmFjZS5nZXRTcGFuKGFjdGl2ZUN0eCk7XG4gICAgY29uc3QgY3R4ID0gc2hvdWxkU2tpcFNwYW4gPyBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFjdGl2ZUN0eCkgOiBhY3RpdmVDdHg7XG5cbiAgICBjb25zdCBzcGFuT3B0aW9ucyA9IGdldFNwYW5PcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRyYWNlci5zdGFydEFjdGl2ZVNwYW4obmFtZSwgc3Bhbk9wdGlvbnMsIGN0eCwgc3BhbiA9PiB7XG4gICAgICBfYXBwbHlTZW50cnlBdHRyaWJ1dGVzVG9TcGFuKHNwYW4sIG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gY29yZS5oYW5kbGVDYWxsYmFja0Vycm9ycyhcbiAgICAgICAgKCkgPT4gY2FsbGJhY2soc3BhbiwgKCkgPT4gc3Bhbi5lbmQoKSksXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAvLyBPbmx5IHNldCB0aGUgc3BhbiBzdGF0dXMgdG8gRVJST1Igd2hlbiB0aGVyZSB3YXNuJ3QgYW55IHN0YXR1cyBzZXQgYmVmb3JlLCBpbiBvcmRlciB0byBhdm9pZCBzdG9tcGluZyB1c2VmdWwgc3BhbiBzdGF0dXNlc1xuICAgICAgICAgIGlmIChjb3JlLnNwYW5Ub0pTT04oc3Bhbikuc3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzcGFuLiBUaGlzIHNwYW4gaXMgbm90IHNldCBhcyBhY3RpdmUsIHNvIHdpbGwgbm90IGdldCBhdXRvbWF0aWMgaW5zdHJ1bWVudGF0aW9uIHNwYW5zXG4gKiBhcyBjaGlsZHJlbiBvciBiZSBhYmxlIHRvIGJlIGFjY2Vzc2VkIHZpYSBgU2VudHJ5LmdldEFjdGl2ZVNwYW4oKWAuXG4gKlxuICogSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgc3BhbiB0aGF0IGlzIHNldCBhcyBhY3RpdmUsIHVzZSB7QGxpbmsgc3RhcnRTcGFufS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJldHVybiBhIHNwYW4sXG4gKiBpdCBtYXkganVzdCBiZSBhIG5vbi1yZWNvcmRpbmcgc3BhbiBpZiB0aGUgc3BhbiBpcyBub3Qgc2FtcGxlZCBvciBpZiB0cmFjaW5nIGlzIGRpc2FibGVkLlxuICovXG5mdW5jdGlvbiBzdGFydEluYWN0aXZlU3BhbihvcHRpb25zKSB7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcigpO1xuXG4gIGNvbnN0IHsgbmFtZSwgcGFyZW50U3BhbjogY3VzdG9tUGFyZW50U3BhbiB9ID0gb3B0aW9ucztcblxuICAvLyBJZiBgb3B0aW9ucy5wYXJlbnRTcGFuYCBpcyBkZWZpbmVkLCB3ZSB3YW50IHRvIHdyYXAgdGhlIGNhbGxiYWNrIGluIGB3aXRoQWN0aXZlU3BhbmBcbiAgY29uc3Qgd3JhcHBlciA9IGdldEFjdGl2ZVNwYW5XcmFwcGVyKGN1c3RvbVBhcmVudFNwYW4pO1xuXG4gIHJldHVybiB3cmFwcGVyKCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVDdHggPSBnZXRDb250ZXh0KG9wdGlvbnMuc2NvcGUsIG9wdGlvbnMuZm9yY2VUcmFuc2FjdGlvbik7XG4gICAgY29uc3Qgc2hvdWxkU2tpcFNwYW4gPSBvcHRpb25zLm9ubHlJZlBhcmVudCAmJiAhYXBpLnRyYWNlLmdldFNwYW4oYWN0aXZlQ3R4KTtcbiAgICBjb25zdCBjdHggPSBzaG91bGRTa2lwU3BhbiA/IGNvcmUkMS5zdXBwcmVzc1RyYWNpbmcoYWN0aXZlQ3R4KSA6IGFjdGl2ZUN0eDtcblxuICAgIGNvbnN0IHNwYW5PcHRpb25zID0gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBjb25zdCBzcGFuID0gdHJhY2VyLnN0YXJ0U3BhbihuYW1lLCBzcGFuT3B0aW9ucywgY3R4KTtcblxuICAgIF9hcHBseVNlbnRyeUF0dHJpYnV0ZXNUb1NwYW4oc3Bhbiwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gc3BhbjtcbiAgfSk7XG59XG5cbi8qKlxuICogRm9ya3MgdGhlIGN1cnJlbnQgc2NvcGUgYW5kIHNldHMgdGhlIHByb3ZpZGVkIHNwYW4gYXMgYWN0aXZlIHNwYW4gaW4gdGhlIGNvbnRleHQgb2YgdGhlIHByb3ZpZGVkIGNhbGxiYWNrLiBDYW4gYmVcbiAqIHBhc3NlZCBgbnVsbGAgdG8gc3RhcnQgYW4gZW50aXJlbHkgbmV3IHNwYW4gdHJlZS5cbiAqXG4gKiBAcGFyYW0gc3BhbiBTcGFucyBzdGFydGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGNoaWxkcmVuIG9mIHRoaXMgc3Bhbi4gSWYgYG51bGxgIGlzIHBhc3NlZCxcbiAqIHNwYW5zIHN0YXJ0ZWQgd2l0aGluIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJvb3Qgc3BhbnMuXG4gKiBAcGFyYW0gY2FsbGJhY2sgRXhlY3V0aW9uIGNvbnRleHQgaW4gd2hpY2ggdGhlIHByb3ZpZGVkIHNwYW4gd2lsbCBiZSBhY3RpdmUuIElzIHBhc3NlZCB0aGUgbmV3bHkgZm9ya2VkIHNjb3BlLlxuICogQHJldHVybnMgdGhlIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB3aXRoQWN0aXZlU3BhbihzcGFuLCBjYWxsYmFjaykge1xuICBjb25zdCBuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4gPSBzcGFuID8gYXBpLnRyYWNlLnNldFNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pIDogYXBpLnRyYWNlLmRlbGV0ZVNwYW4oYXBpLmNvbnRleHQuYWN0aXZlKCkpO1xuICByZXR1cm4gYXBpLmNvbnRleHQud2l0aChuZXdDb250ZXh0V2l0aEFjdGl2ZVNwYW4sICgpID0+IGNhbGxiYWNrKGNvcmUuZ2V0Q3VycmVudFNjb3BlKCkpKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2VyKCkge1xuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICByZXR1cm4gKGNsaWVudCAmJiBjbGllbnQudHJhY2VyKSB8fCBhcGkudHJhY2UuZ2V0VHJhY2VyKCdAc2VudHJ5L29wZW50ZWxlbWV0cnknLCBjb3JlLlNES19WRVJTSU9OKTtcbn1cblxuZnVuY3Rpb24gX2FwcGx5U2VudHJ5QXR0cmlidXRlc1RvU3BhbihzcGFuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgb3AgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKG9wKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QLCBvcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3Bhbk9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB7IHN0YXJ0VGltZSwgYXR0cmlidXRlcywga2luZCB9ID0gb3B0aW9ucztcblxuICAvLyBPVEVMIGV4cGVjdHMgdGltZXN0YW1wcyBpbiBtcywgbm90IHNlY29uZHNcbiAgY29uc3QgZml4ZWRTdGFydFRpbWUgPSB0eXBlb2Ygc3RhcnRUaW1lID09PSAnbnVtYmVyJyA/IGVuc3VyZVRpbWVzdGFtcEluTWlsbGlzZWNvbmRzKHN0YXJ0VGltZSkgOiBzdGFydFRpbWU7XG5cbiAgcmV0dXJuIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGtpbmQsXG4gICAgc3RhcnRUaW1lOiBmaXhlZFN0YXJ0VGltZSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlVGltZXN0YW1wSW5NaWxsaXNlY29uZHModGltZXN0YW1wKSB7XG4gIGNvbnN0IGlzTXMgPSB0aW1lc3RhbXAgPCA5OTk5OTk5OTk5O1xuICByZXR1cm4gaXNNcyA/IHRpbWVzdGFtcCAqIDEwMDAgOiB0aW1lc3RhbXA7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoc2NvcGUsIGZvcmNlVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgY29uc3QgYWN0dWFsU2NvcGUgPSBfb3B0aW9uYWxDaGFpbiQ1KFtnZXRTY29wZXNGcm9tQ29udGV4dCwgJ2NhbGwnLCBfID0+IF8oY3R4KSwgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuc2NvcGVdKTtcblxuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY3R4KTtcblxuICAvLyBJbiB0aGUgY2FzZSB0aGF0IHdlIGhhdmUgbm8gcGFyZW50IHNwYW4sIHdlIG5lZWQgdG8gXCJzaW11bGF0ZVwiIG9uZSB0byBlbnN1cmUgdGhlIHByb3BhZ2F0aW9uIGNvbnRleHQgaXMgY29ycmVjdFxuICBpZiAoIXBhcmVudFNwYW4pIHtcbiAgICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuXG4gICAgaWYgKGFjdHVhbFNjb3BlICYmIGNsaWVudCkge1xuICAgICAgY29uc3QgcHJvcGFnYXRpb25Db250ZXh0ID0gYWN0dWFsU2NvcGUuZ2V0UHJvcGFnYXRpb25Db250ZXh0KCk7XG5cbiAgICAgIC8vIFdlIHN0b3JlIHRoZSBEU0MgYXMgT1RFTCB0cmFjZSBzdGF0ZSBvbiB0aGUgc3BhbiBjb250ZXh0XG4gICAgICBjb25zdCB0cmFjZVN0YXRlID0gbWFrZVRyYWNlU3RhdGUoe1xuICAgICAgICBwYXJlbnRTcGFuSWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5wYXJlbnRTcGFuSWQsXG4gICAgICAgIC8vIE5vdCBkZWZpbmVkIHlldCwgd2Ugd2FudCB0byBwaWNrIHRoaXMgdXAgb24tZGVtYW5kIG9ubHlcbiAgICAgICAgZHNjOiB1bmRlZmluZWQsXG4gICAgICAgIHNhbXBsZWQ6IHByb3BhZ2F0aW9uQ29udGV4dC5zYW1wbGVkLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNwYW5PcHRpb25zID0ge1xuICAgICAgICB0cmFjZUlkOiBwcm9wYWdhdGlvbkNvbnRleHQudHJhY2VJZCxcbiAgICAgICAgc3BhbklkOiBwcm9wYWdhdGlvbkNvbnRleHQucGFyZW50U3BhbklkIHx8IHByb3BhZ2F0aW9uQ29udGV4dC5zcGFuSWQsXG4gICAgICAgIGlzUmVtb3RlOiB0cnVlLFxuICAgICAgICB0cmFjZUZsYWdzOiBwcm9wYWdhdGlvbkNvbnRleHQuc2FtcGxlZCA/IGFwaS5UcmFjZUZsYWdzLlNBTVBMRUQgOiBhcGkuVHJhY2VGbGFncy5OT05FLFxuICAgICAgICB0cmFjZVN0YXRlLFxuICAgICAgfTtcblxuICAgICAgLy8gQWRkIHJlbW90ZSBwYXJlbnQgc3BhbiBjb250ZXh0LFxuICAgICAgcmV0dXJuIGFwaS50cmFjZS5zZXRTcGFuQ29udGV4dChjdHgsIHNwYW5PcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBoYXZlIG5vIHNjb3BlIG9yIGNsaWVudCwgd2UganVzdCByZXR1cm4gdGhlIGNvbnRleHQgYXMtaXNcbiAgICByZXR1cm4gY3R4O1xuICB9XG5cbiAgLy8gSWYgd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBhIHRyYW5zYWN0aW9uLCBhbmQgd2UgaGF2ZSBhIHBhcmVudCBzcGFuLCBhbGwgZ29vZCwgd2UganVzdCByZXR1cm4gYXMtaXMhXG4gIGlmICghZm9yY2VUcmFuc2FjdGlvbikge1xuICAgIHJldHVybiBjdHg7XG4gIH1cblxuICAvLyBFbHNlLCBpZiB3ZSBkbyBoYXZlIGEgcGFyZW50IHNwYW4gYnV0IHdhbnQgdG8gZm9yY2UgYSB0cmFuc2FjdGlvbiwgd2UgaGF2ZSB0byBzaW11bGF0ZSBhIFwicm9vdFwiIGNvbnRleHRcblxuICAvLyBFbHNlLCB3ZSBuZWVkIHRvIGRvIHR3byB0aGluZ3M6XG4gIC8vIDEuIFVuc2V0IHRoZSBwYXJlbnQgc3BhbiBmcm9tIHRoZSBjb250ZXh0LCBzbyB3ZSdsbCBjcmVhdGUgYSBuZXcgcm9vdCBzcGFuXG4gIC8vIDIuIEVuc3VyZSB0aGUgcHJvcGFnYXRpb24gY29udGV4dCBpcyBjb3JyZWN0LCBzbyB3ZSdsbCBjb250aW51ZSBmcm9tIHRoZSBwYXJlbnQgc3BhblxuICBjb25zdCBjdHhXaXRob3V0U3BhbiA9IGFwaS50cmFjZS5kZWxldGVTcGFuKGN0eCk7XG5cbiAgY29uc3QgeyBzcGFuSWQsIHRyYWNlSWQgfSA9IHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKTtcbiAgY29uc3Qgc2FtcGxlZCA9IGdldFNhbXBsaW5nRGVjaXNpb24ocGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpKTtcblxuICAvLyBJbiB0aGlzIGNhc2UsIHdoZW4gd2UgYXJlIGZvcmNpbmcgYSB0cmFuc2FjdGlvbiwgd2Ugd2FudCB0byB0cmVhdCB0aGlzIGxpa2UgY29udGludWluZyBhbiBpbmNvbWluZyB0cmFjZVxuICAvLyBzbyB3ZSBzZXQgdGhlIHRyYWNlU3RhdGUgYWNjb3JkaW5nIHRvIHRoZSByb290IHNwYW5cbiAgY29uc3Qgcm9vdFNwYW4gPSBjb3JlLmdldFJvb3RTcGFuKHBhcmVudFNwYW4pO1xuICBjb25zdCBkc2MgPSBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3Bhbihyb290U3Bhbik7XG5cbiAgY29uc3QgdHJhY2VTdGF0ZSA9IG1ha2VUcmFjZVN0YXRlKHtcbiAgICBkc2MsXG4gICAgcGFyZW50U3BhbklkOiBzcGFuSWQgIT09IGFwaS5JTlZBTElEX1NQQU5JRCA/IHNwYW5JZCA6IHVuZGVmaW5lZCxcbiAgICBzYW1wbGVkLFxuICB9KTtcblxuICBjb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgICB0cmFjZUlkLFxuICAgIHNwYW5JZCxcbiAgICBpc1JlbW90ZTogdHJ1ZSxcbiAgICB0cmFjZUZsYWdzOiBzYW1wbGVkID8gYXBpLlRyYWNlRmxhZ3MuU0FNUExFRCA6IGFwaS5UcmFjZUZsYWdzLk5PTkUsXG4gICAgdHJhY2VTdGF0ZSxcbiAgfTtcblxuICBjb25zdCBjdHhXaXRoU3BhbkNvbnRleHQgPSBhcGkudHJhY2Uuc2V0U3BhbkNvbnRleHQoY3R4V2l0aG91dFNwYW4sIHNwYW5PcHRpb25zKTtcblxuICByZXR1cm4gY3R4V2l0aFNwYW5Db250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlKSB7XG4gICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dEZyb21TY29wZShzY29wZSk7XG4gICAgaWYgKGN0eCkge1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG59XG5cbi8qKlxuICogQ29udGludWUgYSB0cmFjZSBmcm9tIGBzZW50cnktdHJhY2VgIGFuZCBgYmFnZ2FnZWAgdmFsdWVzLlxuICogVGhlc2UgdmFsdWVzIGNhbiBiZSBvYnRhaW5lZCBmcm9tIGluY29taW5nIHJlcXVlc3QgaGVhZGVycywgb3IgaW4gdGhlIGJyb3dzZXIgZnJvbSBgPG1ldGEgbmFtZT1cInNlbnRyeS10cmFjZVwiPmBcbiAqIGFuZCBgPG1ldGEgbmFtZT1cImJhZ2dhZ2VcIj5gIEhUTUwgdGFncy5cbiAqXG4gKiBTcGFucyBzdGFydGVkIHdpdGggYHN0YXJ0U3BhbmAsIGBzdGFydFNwYW5NYW51YWxgIGFuZCBgc3RhcnRJbmFjdGl2ZVNwYW5gLCB3aXRoaW4gdGhlIGNhbGxiYWNrIHdpbGwgYXV0b21hdGljYWxseVxuICogYmUgYXR0YWNoZWQgdG8gdGhlIGluY29taW5nIHRyYWNlLlxuICpcbiAqIFRoaXMgaXMgYSBjdXN0b20gdmVyc2lvbiBvZiBgY29udGludWVUcmFjZWAgdGhhdCBpcyB1c2VkIGluIE9URUwtcG93ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBJdCBwcm9wYWdhdGVzIHRoZSB0cmFjZSBhcyBhIHJlbW90ZSBzcGFuLCBpbiBhZGRpdGlvbiB0byBzZXR0aW5nIGl0IG9uIHRoZSBwcm9wYWdhdGlvbiBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBjb250aW51ZVRyYWNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjb3JlLmNvbnRpbnVlVHJhY2Uob3B0aW9ucywgKCkgPT4ge1xuICAgIHJldHVybiBjb250aW51ZVRyYWNlQXNSZW1vdGVTcGFuKGFwaS5jb250ZXh0LmFjdGl2ZSgpLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVTcGFuV3JhcHBlcihwYXJlbnRTcGFuKSB7XG4gIHJldHVybiBwYXJlbnRTcGFuXG4gICAgPyAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgLy8gV2UgY2FzdCB0aGlzLCBiZWNhdXNlIHRoZSBPVEVMIFNwYW4gaGFzIGEgZmV3IG1vcmUgbWV0aG9kcyB0aGFuIG91ciBTcGFuIGludGVyZmFjZVxuICAgICAgICAvLyBUT0RPOiBBZGQgdGhlc2UgbWlzc2luZyBtZXRob2RzIHRvIHRoZSBTcGFuIGludGVyZmFjZVxuICAgICAgICByZXR1cm4gd2l0aEFjdGl2ZVNwYW4ocGFyZW50U3BhbiAsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICA6IChjYWxsYmFjaykgPT4gY2FsbGJhY2soKTtcbn1cblxuLyoqIFN1cHByZXNzIHRyYWNpbmcgaW4gdGhlIGdpdmVuIGNhbGxiYWNrLCBlbnN1cmluZyBubyBzcGFucyBhcmUgZ2VuZXJhdGVkIGluc2lkZSBvZiBpdC4gKi9cbmZ1bmN0aW9uIHN1cHByZXNzVHJhY2luZyhjYWxsYmFjaykge1xuICBjb25zdCBjdHggPSBjb3JlJDEuc3VwcHJlc3NUcmFjaW5nKGFwaS5jb250ZXh0LmFjdGl2ZSgpKTtcbiAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIF9vcHRpb25hbENoYWluJDQob3BzKSB7IGxldCBsYXN0QWNjZXNzTEhTID0gdW5kZWZpbmVkOyBsZXQgdmFsdWUgPSBvcHNbMF07IGxldCBpID0gMTsgd2hpbGUgKGkgPCBvcHMubGVuZ3RoKSB7IGNvbnN0IG9wID0gb3BzW2ldOyBjb25zdCBmbiA9IG9wc1tpICsgMV07IGkgKz0gMjsgaWYgKChvcCA9PT0gJ29wdGlvbmFsQWNjZXNzJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpICYmIHZhbHVlID09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBpZiAob3AgPT09ICdhY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnKSB7IGxhc3RBY2Nlc3NMSFMgPSB2YWx1ZTsgdmFsdWUgPSBmbih2YWx1ZSk7IH0gZWxzZSBpZiAob3AgPT09ICdjYWxsJyB8fCBvcCA9PT0gJ29wdGlvbmFsQ2FsbCcpIHsgdmFsdWUgPSBmbigoLi4uYXJncykgPT4gdmFsdWUuY2FsbChsYXN0QWNjZXNzTEhTLCAuLi5hcmdzKSk7IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IH0gfSByZXR1cm4gdmFsdWU7IH1cbi8qKiBFbnN1cmUgdGhlIGB0cmFjZWAgY29udGV4dCBpcyBzZXQgb24gYWxsIGV2ZW50cy4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRDb250ZXh0VHJhY2UoY2xpZW50KSB7XG4gIGNsaWVudC5vbigncHJlcHJvY2Vzc0V2ZW50JywgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNwYW4gPSBnZXRBY3RpdmVTcGFuKCk7XG4gICAgLy8gRm9yIHRyYW5zYWN0aW9uIGV2ZW50cywgdGhpcyBpcyBoYW5kbGVkIHNlcGFyYXRlbHlcbiAgICAvLyBCZWNhdXNlIHRoZSBhY3RpdmUgc3BhbiBtYXkgbm90IGJlIHRoZSBzcGFuIHRoYXQgaXMgYWN0dWFsbHkgdGhlIHRyYW5zYWN0aW9uIGV2ZW50XG4gICAgaWYgKCFzcGFuIHx8IGV2ZW50LnR5cGUgPT09ICd0cmFuc2FjdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzcGFuQ29udGV4dCA9IHNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAgIC8vIElmIHdlIGhhdmUgYSBwYXJlbnQgc3BhbiBpZCBmcm9tIHRyYWNlIHN0YXRlLCB1c2UgdGhhdCAoJycgbWVhbnMgbm8gcGFyZW50IHNob3VsZCBiZSB1c2VkKVxuICAgIC8vIEVsc2UsIHBpY2sgdGhlIG9uZSBmcm9tIHRoZSBzcGFuXG4gICAgY29uc3QgcGFyZW50U3BhbklkRnJvbVRyYWNlU3RhdGUgPSBfb3B0aW9uYWxDaGFpbiQ0KFtzcGFuQ29udGV4dCwgJ2FjY2VzcycsIF8gPT4gXy50cmFjZVN0YXRlLCAnb3B0aW9uYWxBY2Nlc3MnLCBfMiA9PiBfMi5nZXQsICdjYWxsJywgXzMgPT4gXzMoU0VOVFJZX1RSQUNFX1NUQVRFX1BBUkVOVF9TUEFOX0lEKV0pO1xuICAgIGNvbnN0IHBhcmVudF9zcGFuX2lkID1cbiAgICAgIHR5cGVvZiBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBwYXJlbnRTcGFuSWRGcm9tVHJhY2VTdGF0ZSB8fCB1bmRlZmluZWRcbiAgICAgICAgOiBzcGFuSGFzUGFyZW50SWQoc3BhbilcbiAgICAgICAgICA/IHNwYW4ucGFyZW50U3BhbklkXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiBldmVudCBoYXMgYWxyZWFkeSBzZXQgYHRyYWNlYCBjb250ZXh0LCB1c2UgdGhhdCBvbmUuXG4gICAgZXZlbnQuY29udGV4dHMgPSB7XG4gICAgICB0cmFjZTogdXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgICAgICB0cmFjZV9pZDogc3BhbkNvbnRleHQudHJhY2VJZCxcbiAgICAgICAgc3Bhbl9pZDogc3BhbkNvbnRleHQuc3BhbklkLFxuICAgICAgICBwYXJlbnRfc3Bhbl9pZCxcbiAgICAgIH0pLFxuICAgICAgLi4uZXZlbnQuY29udGV4dHMsXG4gICAgfTtcblxuICAgIGNvbnN0IHJvb3RTcGFuID0gY29yZS5nZXRSb290U3BhbihzcGFuKTtcblxuICAgIGV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSA9IHtcbiAgICAgIGR5bmFtaWNTYW1wbGluZ0NvbnRleHQ6IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuKHJvb3RTcGFuKSxcbiAgICAgIC4uLmV2ZW50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIGV2ZW50O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBhc3luYyBjb250ZXh0IHN0cmF0ZWd5IHRvIHVzZSBmb2xsb3cgdGhlIE9URUwgY29udGV4dCB1bmRlciB0aGUgaG9vZC5cbiAqIFdlIGhhbmRsZSBmb3JraW5nIGEgaHViIGluc2lkZSBvZiBvdXIgY3VzdG9tIE9URUwgQ29udGV4dCBNYW5hZ2VyICguL290ZWxDb250ZXh0TWFuYWdlci50cylcbiAqL1xuZnVuY3Rpb24gc2V0T3BlblRlbGVtZXRyeUNvbnRleHRBc3luY0NvbnRleHRTdHJhdGVneSgpIHtcbiAgZnVuY3Rpb24gZ2V0U2NvcGVzKCkge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuICAgIGNvbnN0IHNjb3BlcyA9IGdldFNjb3Blc0Zyb21Db250ZXh0KGN0eCk7XG5cbiAgICBpZiAoc2NvcGVzKSB7XG4gICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIGJlaGF2aW9yOlxuICAgIC8vIGlmLCBmb3Igd2hhdGV2ZXIgcmVhc29uLCB3ZSBjYW4ndCBmaW5kIHNjb3BlcyBvbiB0aGUgY29udGV4dCBoZXJlLCB3ZSBoYXZlIHRvIGZpeCB0aGlzIHNvbWVob3dcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IGNvcmUuZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpLFxuICAgICAgaXNvbGF0aW9uU2NvcGU6IGNvcmUuZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdpdGhTY29wZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCB1c2VzIHRoZSBwcmVzZW5jZSBvZiB0aGlzIGtleSB0byBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkXG4gICAgLy8gZm9yayB0aGUgaXNvbGF0aW9uIHNjb3BlLCBvciBub3RcbiAgICAvLyBhcyBieSBkZWZhdWx0LCB3ZSBkb24ndCB3YW50IHRvIGZvcmsgdGhpcywgdW5sZXNzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGB3aXRoU2NvcGVgXG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0Q3VycmVudFNjb3BlKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aFNldFNjb3BlKHNjb3BlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGN0eCA9IGFwaS5jb250ZXh0LmFjdGl2ZSgpO1xuXG4gICAgLy8gV2UgZGVwZW5kIG9uIHRoZSBvdGVsQ29udGV4dE1hbmFnZXIgdG8gaGFuZGxlIHRoZSBjb250ZXh0L2h1YlxuICAgIC8vIFdlIHNldCB0aGUgYFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWWAgY29udGV4dCB2YWx1ZSwgd2hpY2ggaXMgcGlja2VkIHVwIGJ5XG4gICAgLy8gdGhlIE9URUwgY29udGV4dCBtYW5hZ2VyLCB3aGljaCBwaWNrcyB1cCB0aGlzIHNjb3BlIGFzIHRoZSBjdXJyZW50IHNjb3BlXG4gICAgcmV0dXJuIGFwaS5jb250ZXh0LndpdGgoY3R4LnNldFZhbHVlKFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSwgc2NvcGUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soc2NvcGUpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aElzb2xhdGlvblNjb3BlKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHVzZXMgdGhlIHByZXNlbmNlIG9mIHRoaXMga2V5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGRcbiAgICAvLyBmb3JrIHRoZSBpc29sYXRpb24gc2NvcGUsIG9yIG5vdFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVksIHRydWUpLCAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZ2V0SXNvbGF0aW9uU2NvcGUoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3aXRoU2V0SXNvbGF0aW9uU2NvcGUoaXNvbGF0aW9uU2NvcGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY3R4ID0gYXBpLmNvbnRleHQuYWN0aXZlKCk7XG5cbiAgICAvLyBXZSBkZXBlbmQgb24gdGhlIG90ZWxDb250ZXh0TWFuYWdlciB0byBoYW5kbGUgdGhlIGNvbnRleHQvaHViXG4gICAgLy8gV2Ugc2V0IHRoZSBgU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZYCBjb250ZXh0IHZhbHVlLCB3aGljaCBpcyBwaWNrZWQgdXAgYnlcbiAgICAvLyB0aGUgT1RFTCBjb250ZXh0IG1hbmFnZXIsIHdoaWNoIHVzZXMgdGhlIHByZXNlbmNlIG9mIHRoaXMga2V5IHRvIGRldGVybWluZSBpZiBpdCBzaG91bGRcbiAgICAvLyBmb3JrIHRoZSBpc29sYXRpb24gc2NvcGUsIG9yIG5vdFxuICAgIHJldHVybiBhcGkuY29udGV4dC53aXRoKGN0eC5zZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZLCBpc29sYXRpb25TY29wZSksICgpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhnZXRJc29sYXRpb25TY29wZSgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKCkuc2NvcGU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJc29sYXRpb25TY29wZSgpIHtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKCkuaXNvbGF0aW9uU2NvcGU7XG4gIH1cblxuICBjb3JlLnNldEFzeW5jQ29udGV4dFN0cmF0ZWd5KHtcbiAgICB3aXRoU2NvcGUsXG4gICAgd2l0aFNldFNjb3BlLFxuICAgIHdpdGhTZXRJc29sYXRpb25TY29wZSxcbiAgICB3aXRoSXNvbGF0aW9uU2NvcGUsXG4gICAgZ2V0Q3VycmVudFNjb3BlLFxuICAgIGdldElzb2xhdGlvblNjb3BlLFxuICAgIHN0YXJ0U3BhbixcbiAgICBzdGFydFNwYW5NYW51YWwsXG4gICAgc3RhcnRJbmFjdGl2ZVNwYW4sXG4gICAgZ2V0QWN0aXZlU3BhbixcbiAgICAvLyBUaGUgdHlwZXMgaGVyZSBkb24ndCBmdWxseSBhbGlnbiwgYmVjYXVzZSBvdXIgb3duIGBTcGFuYCB0eXBlIGlzIG5hcnJvd2VyXG4gICAgLy8gdGhhbiB0aGUgT1RFTCBvbmUgLSBidXQgdGhpcyBpcyBPSyBmb3IgaGVyZSwgYXMgd2Ugbm93IHdlJ2xsIG9ubHkgaGF2ZSBPVEVMIHNwYW5zIHBhc3NlZCBhcm91bmRcbiAgICB3aXRoQWN0aXZlU3Bhbjogd2l0aEFjdGl2ZVNwYW4gLFxuICAgIHN1cHByZXNzVHJhY2luZzogc3VwcHJlc3NUcmFjaW5nLFxuICB9KTtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kMyhvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG4vKipcbiAqIFdyYXAgYW4gT3BlblRlbGVtZXRyeSBDb250ZXh0TWFuYWdlciBpbiBhIHdheSB0aGF0IGVuc3VyZXMgdGhlIGNvbnRleHQgaXMga2VwdCBpbiBzeW5jIHdpdGggdGhlIFNlbnRyeSBTY29wZS5cbiAqXG4gKiBVc2FnZTpcbiAqIGltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXIgfSBmcm9tICdAb3BlbnRlbGVtZXRyeS9jb250ZXh0LWFzeW5jLWhvb2tzJztcbiAqIGNvbnN0IFNlbnRyeUNvbnRleHRNYW5hZ2VyID0gd3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MoQXN5bmNMb2NhbFN0b3JhZ2VDb250ZXh0TWFuYWdlcik7XG4gKiBjb25zdCBjb250ZXh0TWFuYWdlciA9IG5ldyBTZW50cnlDb250ZXh0TWFuYWdlcigpO1xuICovXG5mdW5jdGlvbiB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcyhcbiAgQ29udGV4dE1hbmFnZXJDbGFzcyxcbikge1xuICAvKipcbiAgICogVGhpcyBpcyBhIGN1c3RvbSBDb250ZXh0TWFuYWdlciBmb3IgT3BlblRlbGVtZXRyeSwgd2hpY2ggZXh0ZW5kcyB0aGUgZGVmYXVsdCBBc3luY0xvY2FsU3RvcmFnZUNvbnRleHRNYW5hZ2VyLlxuICAgKiBJdCBlbnN1cmVzIHRoYXQgd2UgY3JlYXRlIG5ldyBzY29wZXMgcGVyIGNvbnRleHQsIHNvIHRoYXQgdGhlIE9URUwgQ29udGV4dCAmIHRoZSBTZW50cnkgU2NvcGUgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2UgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBBc3luY0hvb2tzIHdpdGggdGhpcyxcbiAgICogYnV0IHNpbmNlIHRoaXMgc2hvdWxkIHdvcmsgZm9yIE5vZGUgMTQrIGFueWhvdyB0aGF0IHNob3VsZCBiZSBnb29kIGVub3VnaC5cbiAgICovXG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBkb2VzIG5vdCBsaWtlIHRoaXMsIGJ1dCB3ZSBrbm93IHRoaXMgaXMgZmluZVxuICBjbGFzcyBTZW50cnlDb250ZXh0TWFuYWdlciBleHRlbmRzIENvbnRleHRNYW5hZ2VyQ2xhc3Mge1xuICAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIHNldElzU2V0dXAoJ1NlbnRyeUNvbnRleHRNYW5hZ2VyJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZSB3aXRoKCkgb2YgdGhlIG9yaWdpbmFsIEFzeW5jTG9jYWxTdG9yYWdlQ29udGV4dE1hbmFnZXJcbiAgICAgKiB0byBlbnN1cmUgd2UgYWxzbyBjcmVhdGUgbmV3IHNjb3BlcyBwZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICAgd2l0aChcbiAgICAgIGNvbnRleHQsXG4gICAgICBmbixcbiAgICAgIHRoaXNBcmcsXG4gICAgICAuLi5hcmdzXG4gICAgKSB7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQoY29udGV4dCk7XG4gICAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBfb3B0aW9uYWxDaGFpbiQzKFtjdXJyZW50U2NvcGVzLCAnb3B0aW9uYWxBY2Nlc3MnLCBfID0+IF8uc2NvcGVdKSB8fCBjb3JlLmdldEN1cnJlbnRTY29wZSgpO1xuICAgICAgY29uc3QgY3VycmVudElzb2xhdGlvblNjb3BlID0gX29wdGlvbmFsQ2hhaW4kMyhbY3VycmVudFNjb3BlcywgJ29wdGlvbmFsQWNjZXNzJywgXzIgPT4gXzIuaXNvbGF0aW9uU2NvcGVdKSB8fCBjb3JlLmdldElzb2xhdGlvblNjb3BlKCk7XG5cbiAgICAgIGNvbnN0IHNob3VsZEZvcmtJc29sYXRpb25TY29wZSA9IGNvbnRleHQuZ2V0VmFsdWUoU0VOVFJZX0ZPUktfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKSA9PT0gdHJ1ZTtcbiAgICAgIGNvbnN0IHNjb3BlID0gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfU0NPUEVfQ09OVEVYVF9LRVkpIDtcbiAgICAgIGNvbnN0IGlzb2xhdGlvblNjb3BlID0gY29udGV4dC5nZXRWYWx1ZShTRU5UUllfRk9SS19TRVRfSVNPTEFUSU9OX1NDT1BFX0NPTlRFWFRfS0VZKSA7XG5cbiAgICAgIGNvbnN0IG5ld0N1cnJlbnRTY29wZSA9IHNjb3BlIHx8IGN1cnJlbnRTY29wZS5jbG9uZSgpO1xuICAgICAgY29uc3QgbmV3SXNvbGF0aW9uU2NvcGUgPVxuICAgICAgICBpc29sYXRpb25TY29wZSB8fCAoc2hvdWxkRm9ya0lzb2xhdGlvblNjb3BlID8gY3VycmVudElzb2xhdGlvblNjb3BlLmNsb25lKCkgOiBjdXJyZW50SXNvbGF0aW9uU2NvcGUpO1xuICAgICAgY29uc3Qgc2NvcGVzID0geyBzY29wZTogbmV3Q3VycmVudFNjb3BlLCBpc29sYXRpb25TY29wZTogbmV3SXNvbGF0aW9uU2NvcGUgfTtcblxuICAgICAgY29uc3QgY3R4MSA9IHNldFNjb3Blc09uQ29udGV4dChjb250ZXh0LCBzY29wZXMpO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIHVubmVlZGVkIHZhbHVlcyBhZ2FpblxuICAgICAgY29uc3QgY3R4MiA9IGN0eDFcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX0lTT0xBVElPTl9TQ09QRV9DT05URVhUX0tFWSlcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX1NFVF9TQ09QRV9DT05URVhUX0tFWSlcbiAgICAgICAgLmRlbGV0ZVZhbHVlKFNFTlRSWV9GT1JLX1NFVF9JU09MQVRJT05fU0NPUEVfQ09OVEVYVF9LRVkpO1xuXG4gICAgICBzZXRDb250ZXh0T25TY29wZShuZXdDdXJyZW50U2NvcGUsIGN0eDIpO1xuXG4gICAgICByZXR1cm4gc3VwZXIud2l0aChjdHgyLCBmbiwgdGhpc0FyZywgLi4uYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFNlbnRyeUNvbnRleHRNYW5hZ2VyIDtcbn1cblxuLyoqIElmIHRoaXMgYXR0cmlidXRlIGlzIHRydWUsIGl0IG1lYW5zIHRoYXQgdGhlIHBhcmVudCBpcyBhIHJlbW90ZSBzcGFuLiAqL1xuY29uc3QgU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFID0gJ3NlbnRyeS5wYXJlbnRJc1JlbW90ZSc7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBydW5zIHRocm91Z2ggYSBsaXN0IG9mIE9URUwgU3BhbnMsIGFuZCB3cmFwcyB0aGVtIGluIGFuIGBTcGFuTm9kZWBcbiAqIHdoZXJlIGVhY2ggbm9kZSBob2xkcyBhIHJlZmVyZW5jZSB0byB0aGVpciBwYXJlbnQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBTcGFuc1dpdGhQYXJlbnRzKHNwYW5zKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChjb25zdCBzcGFuIG9mIHNwYW5zKSB7XG4gICAgY3JlYXRlT3JVcGRhdGVTcGFuTm9kZUFuZFJlZnMobm9kZU1hcCwgc3Bhbik7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShub2RlTWFwLCBmdW5jdGlvbiAoW19pZCwgc3Bhbk5vZGVdKSB7XG4gICAgcmV0dXJuIHNwYW5Ob2RlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaGlzIHJldHVybnMgdGhlIF9sb2NhbF8gcGFyZW50IElEIC0gYHBhcmVudElkYCBvbiB0aGUgc3BhbiBtYXkgcG9pbnQgdG8gYSByZW1vdGUgc3Bhbi5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxQYXJlbnRJZChzcGFuKSB7XG4gIGNvbnN0IHBhcmVudElzUmVtb3RlID0gc3Bhbi5hdHRyaWJ1dGVzW1NFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfUEFSRU5UX0lTX1JFTU9URV0gPT09IHRydWU7XG4gIC8vIElmIHRoZSBwYXJlbnRJZCBpcyB0aGUgdHJhY2UgcGFyZW50IElELCB3ZSBwcmV0ZW5kIGl0J3MgdW5kZWZpbmVkXG4gIC8vIEFzIHRoaXMgbWVhbnMgdGhlIHBhcmVudCBleGlzdHMgc29tZXdoZXJlIGVsc2VcbiAgcmV0dXJuICFwYXJlbnRJc1JlbW90ZSA/IHNwYW4ucGFyZW50U3BhbklkIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPclVwZGF0ZVNwYW5Ob2RlQW5kUmVmcyhub2RlTWFwLCBzcGFuKSB7XG4gIGNvbnN0IGlkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgY29uc3QgcGFyZW50SWQgPSBnZXRMb2NhbFBhcmVudElkKHNwYW4pO1xuXG4gIGlmICghcGFyZW50SWQpIHtcbiAgICBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgeyBpZCwgc3BhbiwgY2hpbGRyZW46IFtdIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVsc2UgbWFrZSBzdXJlIHRvIGNyZWF0ZSBwYXJlbnQgbm9kZSBhcyB3ZWxsXG4gIC8vIE5vdGUgdGhhdCB0aGUgcGFyZW50IG1heSBub3Qga25vdyBpdCdzIHBhcmVudCBfeWV0XywgdGhpcyBtYXkgYmUgdXBkYXRlZCBpbiBhIGxhdGVyIHBhc3NcbiAgY29uc3QgcGFyZW50Tm9kZSA9IGNyZWF0ZU9yR2V0UGFyZW50Tm9kZShub2RlTWFwLCBwYXJlbnRJZCk7XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVPclVwZGF0ZU5vZGUobm9kZU1hcCwgeyBpZCwgc3BhbiwgcGFyZW50Tm9kZSwgY2hpbGRyZW46IFtdIH0pO1xuICBwYXJlbnROb2RlLmNoaWxkcmVuLnB1c2gobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9yR2V0UGFyZW50Tm9kZShub2RlTWFwLCBpZCkge1xuICBjb25zdCBleGlzdGluZyA9IG5vZGVNYXAuZ2V0KGlkKTtcblxuICBpZiAoZXhpc3RpbmcpIHtcbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHsgaWQsIGNoaWxkcmVuOiBbXSB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVOb2RlKG5vZGVNYXAsIHNwYW5Ob2RlKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gbm9kZU1hcC5nZXQoc3Bhbk5vZGUuaWQpO1xuXG4gIC8vIElmIHNwYW4gaXMgYWxyZWFkeSBzZXQsIG5vdGhpbmcgdG8gZG8gaGVyZVxuICBpZiAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc3Bhbikge1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIC8vIElmIGl0IGV4aXN0cyBidXQgc3BhbiBpcyBub3Qgc2V0IHlldCwgd2UgdXBkYXRlIGl0XG4gIGlmIChleGlzdGluZyAmJiAhZXhpc3Rpbmcuc3Bhbikge1xuICAgIGV4aXN0aW5nLnNwYW4gPSBzcGFuTm9kZS5zcGFuO1xuICAgIGV4aXN0aW5nLnBhcmVudE5vZGUgPSBzcGFuTm9kZS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIC8vIEVsc2UsIHdlIGNyZWF0ZSBhIG5ldyBvbmUuLi5cbiAgbm9kZU1hcC5zZXQoc3Bhbk5vZGUuaWQsIHNwYW5Ob2RlKTtcbiAgcmV0dXJuIHNwYW5Ob2RlO1xufVxuXG4vLyBjYW5vbmljYWxDb2Rlc0dycGNNYXAgbWFwcyBzb21lIEdSUEMgY29kZXMgdG8gU2VudHJ5J3Mgc3BhbiBzdGF0dXNlcy4gU2VlIGRlc2NyaXB0aW9uIGluIGdycGMgZG9jdW1lbnRhdGlvbi5cbmNvbnN0IGNhbm9uaWNhbEdycGNFcnJvckNvZGVzTWFwID0ge1xuICAnMSc6ICdjYW5jZWxsZWQnLFxuICAnMic6ICd1bmtub3duX2Vycm9yJyxcbiAgJzMnOiAnaW52YWxpZF9hcmd1bWVudCcsXG4gICc0JzogJ2RlYWRsaW5lX2V4Y2VlZGVkJyxcbiAgJzUnOiAnbm90X2ZvdW5kJyxcbiAgJzYnOiAnYWxyZWFkeV9leGlzdHMnLFxuICAnNyc6ICdwZXJtaXNzaW9uX2RlbmllZCcsXG4gICc4JzogJ3Jlc291cmNlX2V4aGF1c3RlZCcsXG4gICc5JzogJ2ZhaWxlZF9wcmVjb25kaXRpb24nLFxuICAnMTAnOiAnYWJvcnRlZCcsXG4gICcxMSc6ICdvdXRfb2ZfcmFuZ2UnLFxuICAnMTInOiAndW5pbXBsZW1lbnRlZCcsXG4gICcxMyc6ICdpbnRlcm5hbF9lcnJvcicsXG4gICcxNCc6ICd1bmF2YWlsYWJsZScsXG4gICcxNSc6ICdkYXRhX2xvc3MnLFxuICAnMTYnOiAndW5hdXRoZW50aWNhdGVkJyxcbn0gO1xuXG5jb25zdCBpc1N0YXR1c0Vycm9yTWVzc2FnZVZhbGlkID0gKG1lc3NhZ2UpID0+IHtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXApLmluY2x1ZGVzKG1lc3NhZ2UgKTtcbn07XG5cbi8qKlxuICogR2V0IGEgU2VudHJ5IHNwYW4gc3RhdHVzIGZyb20gYW4gb3RlbCBzcGFuLlxuICovXG5mdW5jdGlvbiBtYXBTdGF0dXMoc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbkhhc0F0dHJpYnV0ZXMoc3BhbikgPyBzcGFuLmF0dHJpYnV0ZXMgOiB7fTtcbiAgY29uc3Qgc3RhdHVzID0gc3Bhbkhhc1N0YXR1cyhzcGFuKSA/IHNwYW4uc3RhdHVzIDogdW5kZWZpbmVkO1xuXG4gIGlmIChzdGF0dXMpIHtcbiAgICAvLyBTaW5jZSBzcGFuIHN0YXR1cyBPSyBpcyBub3Qgc2V0IGJ5IGRlZmF1bHQsIHdlIGdpdmUgaXQgcHJpb3JpdHk6IGh0dHBzOi8vb3BlbnRlbGVtZXRyeS5pby9kb2NzL2NvbmNlcHRzL3NpZ25hbHMvdHJhY2VzLyNzcGFuLXN0YXR1c1xuICAgIGlmIChzdGF0dXMuY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLk9LKSB7XG4gICAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX09LIH07XG4gICAgICAvLyBJZiB0aGUgc3BhbiBpcyBhbHJlYWR5IG1hcmtlZCBhcyBlcnJvbmVvdXMgd2UgcmV0dXJuIHRoYXQgZXhhY3Qgc3RhdHVzXG4gICAgfSBlbHNlIGlmIChzdGF0dXMuY29kZSA9PT0gYXBpLlNwYW5TdGF0dXNDb2RlLkVSUk9SKSB7XG4gICAgICBpZiAodHlwZW9mIHN0YXR1cy5tZXNzYWdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBpbmZlcnJlZFN0YXR1cyA9IGluZmVyU3RhdHVzRnJvbUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChpbmZlcnJlZFN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBpbmZlcnJlZFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdHVzLm1lc3NhZ2UgJiYgaXNTdGF0dXNFcnJvck1lc3NhZ2VWYWxpZChzdGF0dXMubWVzc2FnZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogc3RhdHVzLm1lc3NhZ2UgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGNvZGU6IGNvcmUuU1BBTl9TVEFUVVNfRVJST1IsIG1lc3NhZ2U6ICd1bmtub3duX2Vycm9yJyB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBzcGFuIHN0YXR1cyBpcyBVTlNFVCwgd2UgdHJ5IHRvIGluZmVyIGl0IGZyb20gSFRUUCBvciBHUlBDIHN0YXR1cyBjb2Rlcy5cbiAgY29uc3QgaW5mZXJyZWRTdGF0dXMgPSBpbmZlclN0YXR1c0Zyb21BdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpO1xuXG4gIGlmIChpbmZlcnJlZFN0YXR1cykge1xuICAgIHJldHVybiBpbmZlcnJlZFN0YXR1cztcbiAgfVxuXG4gIC8vIFdlIGRlZmF1bHQgdG8gc2V0dGluZyB0aGUgc3BhbnMgc3RhdHVzIHRvIG9rLlxuICBpZiAoc3RhdHVzICYmIHN0YXR1cy5jb2RlID09PSBhcGkuU3BhblN0YXR1c0NvZGUuVU5TRVQpIHtcbiAgICByZXR1cm4geyBjb2RlOiBjb3JlLlNQQU5fU1RBVFVTX09LIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogJ3Vua25vd25fZXJyb3InIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5mZXJTdGF0dXNGcm9tQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gIC8vIElmIHRoZSBzcGFuIHN0YXR1cyBpcyBVTlNFVCwgd2UgdHJ5IHRvIGluZmVyIGl0IGZyb20gSFRUUCBvciBHUlBDIHN0YXR1cyBjb2Rlcy5cblxuICBjb25zdCBodHRwQ29kZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXTtcbiAgY29uc3QgZ3JwY0NvZGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW3NlbWFudGljQ29udmVudGlvbnMuU0VNQVRUUlNfUlBDX0dSUENfU1RBVFVTX0NPREVdO1xuXG4gIGNvbnN0IG51bWJlckh0dHBDb2RlID1cbiAgICB0eXBlb2YgaHR0cENvZGVBdHRyaWJ1dGUgPT09ICdudW1iZXInXG4gICAgICA/IGh0dHBDb2RlQXR0cmlidXRlXG4gICAgICA6IHR5cGVvZiBodHRwQ29kZUF0dHJpYnV0ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBwYXJzZUludChodHRwQ29kZUF0dHJpYnV0ZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKHR5cGVvZiBudW1iZXJIdHRwQ29kZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gY29yZS5nZXRTcGFuU3RhdHVzRnJvbUh0dHBDb2RlKG51bWJlckh0dHBDb2RlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ3JwY0NvZGVBdHRyaWJ1dGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHsgY29kZTogY29yZS5TUEFOX1NUQVRVU19FUlJPUiwgbWVzc2FnZTogY2Fub25pY2FsR3JwY0Vycm9yQ29kZXNNYXBbZ3JwY0NvZGVBdHRyaWJ1dGVdIHx8ICd1bmtub3duX2Vycm9yJyB9O1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kMihvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG5jb25zdCBNQVhfU1BBTl9DT1VOVCA9IDEwMDA7XG5jb25zdCBERUZBVUxUX1RJTUVPVVQgPSAzMDA7IC8vIDUgbWluXG5cbi8qKlxuICogQSBTZW50cnktc3BlY2lmaWMgZXhwb3J0ZXIgdGhhdCBjb252ZXJ0cyBPcGVuVGVsZW1ldHJ5IFNwYW5zIHRvIFNlbnRyeSBTcGFucyAmIFRyYW5zYWN0aW9ucy5cbiAqL1xuY2xhc3MgU2VudHJ5U3BhbkV4cG9ydGVyIHtcblxuICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICB0aGlzLl90aW1lb3V0ID0gX29wdGlvbmFsQ2hhaW4kMihbb3B0aW9ucywgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnRpbWVvdXRdKSB8fCBERUZBVUxUX1RJTUVPVVQ7XG4gIH1cblxuICAvKiogRXhwb3J0IGEgc2luZ2xlIHNwYW4uICovXG4gICBleHBvcnQoc3Bhbikge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMucHVzaChzcGFuKTtcblxuICAgIC8vIElmIHRoZSBzcGFuIGhhcyBhIGxvY2FsIHBhcmVudCBJRCwgd2UgZG9uJ3QgbmVlZCB0byBleHBvcnQgYW55dGhpbmcganVzdCB5ZXRcbiAgICBpZiAoZ2V0TG9jYWxQYXJlbnRJZChzcGFuKSkge1xuICAgICAgY29uc3Qgb3BlblNwYW5Db3VudCA9IHRoaXMuX2ZpbmlzaGVkU3BhbnMubGVuZ3RoO1xuICAgICAgREVCVUdfQlVJTEQgJiYgdXRpbHMubG9nZ2VyLmxvZyhgU3BhbkV4cG9ydGVyIGhhcyAke29wZW5TcGFuQ291bnR9IHVuc2VudCBzcGFucyByZW1haW5pbmdgKTtcbiAgICAgIHRoaXMuX2NsZWFudXBPbGRTcGFucygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgLy8gSWYgd2UgZ290IGEgcGFyZW50IHNwYW4sIHdlIHRyeSB0byBzZW5kIHRoZSBzcGFuIHRyZWVcbiAgICAvLyBXYWl0IGEgdGljayBmb3IgdGhpcywgdG8gZW5zdXJlIHdlIGF2b2lkIHJhY2UgY29uZGl0aW9uc1xuICAgIHRoaXMuX2ZsdXNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH0sIDEpO1xuICB9XG5cbiAgLyoqIFRyeSB0byBmbHVzaCBhbnkgcGVuZGluZyBzcGFucyBpbW1lZGlhdGVseS4gKi9cbiAgIGZsdXNoKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgY29uc3Qgb3BlblNwYW5Db3VudCA9IHRoaXMuX2ZpbmlzaGVkU3BhbnMubGVuZ3RoO1xuXG4gICAgY29uc3QgcmVtYWluaW5nU3BhbnMgPSBtYXliZVNlbmQodGhpcy5fZmluaXNoZWRTcGFucyk7XG5cbiAgICBjb25zdCByZW1haW5pbmdPcGVuU3BhbkNvdW50ID0gcmVtYWluaW5nU3BhbnMubGVuZ3RoO1xuICAgIGNvbnN0IHNlbnRTcGFuQ291bnQgPSBvcGVuU3BhbkNvdW50IC0gcmVtYWluaW5nT3BlblNwYW5Db3VudDtcblxuICAgIERFQlVHX0JVSUxEICYmXG4gICAgICB1dGlscy5sb2dnZXIubG9nKGBTcGFuRXhwb3J0ZXIgZXhwb3J0ZWQgJHtzZW50U3BhbkNvdW50fSBzcGFucywgJHtyZW1haW5pbmdPcGVuU3BhbkNvdW50fSB1bnNlbnQgc3BhbnMgcmVtYWluaW5nYCk7XG5cbiAgICB0aGlzLl9jbGVhbnVwT2xkU3BhbnMocmVtYWluaW5nU3BhbnMpO1xuICB9XG5cbiAgLyoqIENsZWFyIHRoZSBleHBvcnRlci4gKi9cbiAgIGNsZWFyKCkge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBbXTtcbiAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgfVxuXG4gIC8qKiBDbGVhciB0aGUgZmx1c2ggdGltZW91dC4gKi9cbiAgIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMuX2ZsdXNoVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2ZsdXNoVGltZW91dCk7XG4gICAgICB0aGlzLl9mbHVzaFRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbnkgc3BhbiB0aGF0IGlzIG9sZGVyIHRoYW4gNW1pbi5cbiAgICogV2UgZG8gdGhpcyB0byBhdm9pZCBsZWFraW5nIG1lbW9yeS5cbiAgICovXG4gICBfY2xlYW51cE9sZFNwYW5zKHNwYW5zID0gdGhpcy5fZmluaXNoZWRTcGFucykge1xuICAgIHRoaXMuX2ZpbmlzaGVkU3BhbnMgPSBzcGFucy5maWx0ZXIoc3BhbiA9PiB7XG4gICAgICBjb25zdCBzaG91bGREcm9wID0gc2hvdWxkQ2xlYW51cFNwYW4oc3BhbiwgdGhpcy5fdGltZW91dCk7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICBzaG91bGREcm9wICYmXG4gICAgICAgIHV0aWxzLmxvZ2dlci5sb2coXG4gICAgICAgICAgYFNwYW5FeHBvcnRlciBkcm9wcGluZyBzcGFuICR7c3Bhbi5uYW1lfSAoJHtcbiAgICAgICAgICAgIHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWRcbiAgICAgICAgICB9KSBiZWNhdXNlIGl0IGlzIHBlbmRpbmcgZm9yIG1vcmUgdGhhbiA1IG1pbnV0ZXMuYCxcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiAhc2hvdWxkRHJvcDtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFNlbmQgdGhlIGdpdmVuIHNwYW5zLCBidXQgb25seSBpZiB0aGV5IGFyZSBwYXJ0IG9mIGEgZmluaXNoZWQgdHJhbnNhY3Rpb24uXG4gKlxuICogUmV0dXJucyB0aGUgdW5zZW50IHNwYW5zLlxuICogU3BhbnMgcmVtYWluIHVuc2VudCB3aGVuIHRoZWlyIHBhcmVudCBzcGFuIGlzIG5vdCB5ZXQgZmluaXNoZWQuXG4gKiBUaGlzIHdpbGwgaGFwcGVuIHJlZ3VsYXJseSwgYXMgY2hpbGQgc3BhbnMgYXJlIGdlbmVyYWxseSBmaW5pc2hlZCBiZWZvcmUgdGhlaXIgcGFyZW50cy5cbiAqIEJ1dCBpdCBfY291bGRfIGFsc28gaGFwcGVuIGJlY2F1c2UsIGZvciB3aGF0ZXZlciByZWFzb24sIGEgcGFyZW50IHNwYW4gd2FzIGxvc3QuXG4gKiBJbiB0aGlzIGNhc2UsIHdlJ2xsIGV2ZW50dWFsbHkgbmVlZCB0byBjbGVhbiB0aGlzIHVwLlxuICovXG5mdW5jdGlvbiBtYXliZVNlbmQoc3BhbnMpIHtcbiAgY29uc3QgZ3JvdXBlZCA9IGdyb3VwU3BhbnNXaXRoUGFyZW50cyhzcGFucyk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IG5ldyBTZXQoZ3JvdXBlZCk7XG5cbiAgY29uc3Qgcm9vdE5vZGVzID0gZ2V0Q29tcGxldGVkUm9vdE5vZGVzKGdyb3VwZWQpO1xuXG4gIHJvb3ROb2Rlcy5mb3JFYWNoKHJvb3QgPT4ge1xuICAgIHJlbWFpbmluZy5kZWxldGUocm9vdCk7XG4gICAgY29uc3Qgc3BhbiA9IHJvb3Quc3BhbjtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkV2ZW50ID0gY3JlYXRlVHJhbnNhY3Rpb25Gb3JPdGVsU3BhbihzcGFuKTtcblxuICAgIC8vIFdlJ2xsIHJlY3Vyc2l2ZWx5IGFkZCBhbGwgdGhlIGNoaWxkIHNwYW5zIHRvIHRoaXMgYXJyYXlcbiAgICBjb25zdCBzcGFucyA9IHRyYW5zYWN0aW9uRXZlbnQuc3BhbnMgfHwgW107XG5cbiAgICByb290LmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgcmVtYWluaW5nKTtcbiAgICB9KTtcblxuICAgIC8vIHNwYW5zLnNvcnQoKSBtdXRhdGVzIHRoZSBhcnJheSwgYnV0IHdlIGRvIG5vdCB1c2UgdGhpcyBhbnltb3JlIGFmdGVyIHRoaXMgcG9pbnRcbiAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IG11dGF0ZSBpdCBoZXJlXG4gICAgdHJhbnNhY3Rpb25FdmVudC5zcGFucyA9XG4gICAgICBzcGFucy5sZW5ndGggPiBNQVhfU1BBTl9DT1VOVFxuICAgICAgICA/IHNwYW5zLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRfdGltZXN0YW1wIC0gYi5zdGFydF90aW1lc3RhbXApLnNsaWNlKDAsIE1BWF9TUEFOX0NPVU5UKVxuICAgICAgICA6IHNwYW5zO1xuXG4gICAgY29uc3QgbWVhc3VyZW1lbnRzID0gY29yZS50aW1lZEV2ZW50c1RvTWVhc3VyZW1lbnRzKHNwYW4uZXZlbnRzKTtcbiAgICBpZiAobWVhc3VyZW1lbnRzKSB7XG4gICAgICB0cmFuc2FjdGlvbkV2ZW50Lm1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cztcbiAgICB9XG5cbiAgICBjb3JlLmNhcHR1cmVFdmVudCh0cmFuc2FjdGlvbkV2ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIEFycmF5LmZyb20ocmVtYWluaW5nKVxuICAgIC5tYXAobm9kZSA9PiBub2RlLnNwYW4pXG4gICAgLmZpbHRlcigoc3BhbikgPT4gISFzcGFuKTtcbn1cblxuZnVuY3Rpb24gbm9kZUlzQ29tcGxldGVkUm9vdE5vZGUobm9kZSkge1xuICByZXR1cm4gISFub2RlLnNwYW4gJiYgIW5vZGUucGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcGxldGVkUm9vdE5vZGVzKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5maWx0ZXIobm9kZUlzQ29tcGxldGVkUm9vdE5vZGUpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDbGVhbnVwU3BhbihzcGFuLCBtYXhTdGFydFRpbWVPZmZzZXRTZWNvbmRzKSB7XG4gIGNvbnN0IGN1dG9mZiA9IERhdGUubm93KCkgLyAxMDAwIC0gbWF4U3RhcnRUaW1lT2Zmc2V0U2Vjb25kcztcbiAgcmV0dXJuIGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzcGFuLnN0YXJ0VGltZSkgPCBjdXRvZmY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3BhbihzcGFuKSB7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBzcGFuLmF0dHJpYnV0ZXM7XG5cbiAgY29uc3Qgb3JpZ2luID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1JJR0lOXSA7XG4gIGNvbnN0IG9wID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfT1BdIDtcbiAgY29uc3Qgc291cmNlID0gYXR0cmlidXRlc1tjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU09VUkNFXSA7XG5cbiAgcmV0dXJuIHsgb3JpZ2luLCBvcCwgc291cmNlIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uRm9yT3RlbFNwYW4oc3Bhbikge1xuICBjb25zdCB7IG9wLCBkZXNjcmlwdGlvbiwgZGF0YSwgb3JpZ2luID0gJ21hbnVhbCcsIHNvdXJjZSB9ID0gZ2V0U3BhbkRhdGEoc3Bhbik7XG4gIGNvbnN0IGNhcHR1cmVkU3BhblNjb3BlcyA9IGNvcmUuZ2V0Q2FwdHVyZWRTY29wZXNPblNwYW4oc3BhbiApO1xuXG4gIGNvbnN0IHNhbXBsZVJhdGUgPSBzcGFuLmF0dHJpYnV0ZXNbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXSA7XG5cbiAgY29uc3QgYXR0cmlidXRlcyA9IHV0aWxzLmRyb3BVbmRlZmluZWRLZXlzKHtcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NPVVJDRV06IHNvdXJjZSxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTogc2FtcGxlUmF0ZSxcbiAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX09QXTogb3AsXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBvcmlnaW4sXG4gICAgLi4uZGF0YSxcbiAgICAuLi5yZW1vdmVTZW50cnlBdHRyaWJ1dGVzKHNwYW4uYXR0cmlidXRlcyksXG4gIH0pO1xuXG4gIGNvbnN0IHsgdHJhY2VJZDogdHJhY2VfaWQsIHNwYW5JZDogc3Bhbl9pZCB9ID0gc3Bhbi5zcGFuQ29udGV4dCgpO1xuXG4gIGNvbnN0IHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlID0gX29wdGlvbmFsQ2hhaW4kMihbc3BhbiwgJ2FjY2VzcycsIF8yID0+IF8yLnNwYW5Db250ZXh0LCAnY2FsbCcsIF8zID0+IF8zKCksICdhY2Nlc3MnLCBfNCA9PiBfNC50cmFjZVN0YXRlLCAnb3B0aW9uYWxBY2Nlc3MnLCBfNSA9PiBfNS5nZXQsICdjYWxsJywgXzYgPT4gXzYoU0VOVFJZX1RSQUNFX1NUQVRFX1BBUkVOVF9TUEFOX0lEKV0pO1xuXG4gIC8vIElmIHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlIGlzIGRlZmluZWQgYXQgYWxsLCB3ZSB3YW50IGl0IHRvIHRha2UgcHJlc2VkZW5jZVxuICAvLyBJbiB0aGF0IGNhc2UsIGFuIGVtcHR5IHN0cmluZyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgXCJubyBwYXJlbnQgc3BhbiBpZFwiLFxuICAvLyBldmVuIGlmIGBzcGFuLnBhcmVudFNwYW5JZGAgaXMgc2V0XG4gIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB3ZSBhcmUgc3RhcnRpbmcgYSBuZXcgdHJhY2UsIHdoZXJlIHdlIGhhdmUgYSB2aXJ0dWFsIHNwYW4gYmFzZWQgb24gdGhlIHByb3BhZ2F0aW9uQ29udGV4dFxuICAvLyBXZSBvbmx5IHdhbnQgdG8gY29udGludWUgdGhlIHRyYWNlSWQgaW4gdGhpcyBjYXNlLCBidXQgaWdub3JlIHRoZSBwYXJlbnQgc3BhblxuICBjb25zdCBwYXJlbnRfc3Bhbl9pZCA9XG4gICAgdHlwZW9mIHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlID09PSAnc3RyaW5nJyA/IHBhcmVudFNwYW5JZEZyb21UcmFjZVN0YXRlIHx8IHVuZGVmaW5lZCA6IHNwYW4ucGFyZW50U3BhbklkO1xuXG4gIGNvbnN0IHN0YXR1cyA9IG1hcFN0YXR1cyhzcGFuKTtcblxuICBjb25zdCB0cmFjZUNvbnRleHQgPSB1dGlscy5kcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgcGFyZW50X3NwYW5faWQsXG4gICAgc3Bhbl9pZCxcbiAgICB0cmFjZV9pZCxcbiAgICBkYXRhOiBhdHRyaWJ1dGVzLFxuICAgIG9yaWdpbixcbiAgICBvcCxcbiAgICBzdGF0dXM6IGNvcmUuZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLCAvLyBBcyBwZXIgcHJvdG9jb2wsIHNwYW4gc3RhdHVzIGlzIGFsbG93ZWQgdG8gYmUgdW5kZWZpbmVkXG4gIH0pO1xuXG4gIGNvbnN0IHRyYW5zYWN0aW9uRXZlbnQgPSB7XG4gICAgY29udGV4dHM6IHtcbiAgICAgIHRyYWNlOiB0cmFjZUNvbnRleHQsXG4gICAgICBvdGVsOiB7XG4gICAgICAgIHJlc291cmNlOiBzcGFuLnJlc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICB9LFxuICAgIH0sXG4gICAgc3BhbnM6IFtdLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHNwYW4uc3RhcnRUaW1lKSxcbiAgICB0aW1lc3RhbXA6IGNvcmUuc3BhblRpbWVJbnB1dFRvU2Vjb25kcyhzcGFuLmVuZFRpbWUpLFxuICAgIHRyYW5zYWN0aW9uOiBkZXNjcmlwdGlvbixcbiAgICB0eXBlOiAndHJhbnNhY3Rpb24nLFxuICAgIHNka1Byb2Nlc3NpbmdNZXRhZGF0YToge1xuICAgICAgLi4udXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgICAgICBjYXB0dXJlZFNwYW5TY29wZTogY2FwdHVyZWRTcGFuU2NvcGVzLnNjb3BlLFxuICAgICAgICBjYXB0dXJlZFNwYW5Jc29sYXRpb25TY29wZTogY2FwdHVyZWRTcGFuU2NvcGVzLmlzb2xhdGlvblNjb3BlLFxuICAgICAgICBzYW1wbGVSYXRlLFxuICAgICAgICBkeW5hbWljU2FtcGxpbmdDb250ZXh0OiBjb3JlLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbihzcGFuICksXG4gICAgICB9KSxcbiAgICB9LFxuICAgIC4uLihzb3VyY2UgJiYge1xuICAgICAgdHJhbnNhY3Rpb25faW5mbzoge1xuICAgICAgICBzb3VyY2UsXG4gICAgICB9LFxuICAgIH0pLFxuICAgIF9tZXRyaWNzX3N1bW1hcnk6IGNvcmUuZ2V0TWV0cmljU3VtbWFyeUpzb25Gb3JTcGFuKHNwYW4gKSxcbiAgfTtcblxuICByZXR1cm4gdHJhbnNhY3Rpb25FdmVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKG5vZGUsIHNwYW5zLCByZW1haW5pbmcpIHtcbiAgcmVtYWluaW5nLmRlbGV0ZShub2RlKTtcbiAgY29uc3Qgc3BhbiA9IG5vZGUuc3BhbjtcblxuICBjb25zdCBzaG91bGREcm9wID0gIXNwYW47XG5cbiAgLy8gSWYgdGhpcyBzcGFuIHNob3VsZCBiZSBkcm9wcGVkLCB3ZSBzdGlsbCB3YW50IHRvIGNyZWF0ZSBzcGFucyBmb3IgdGhlIGNoaWxkcmVuIG9mIHRoaXNcbiAgaWYgKHNob3VsZERyb3ApIHtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgcmVtYWluaW5nKTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzcGFuX2lkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgY29uc3QgdHJhY2VfaWQgPSBzcGFuLnNwYW5Db250ZXh0KCkudHJhY2VJZDtcblxuICBjb25zdCB7IGF0dHJpYnV0ZXMsIHN0YXJ0VGltZSwgZW5kVGltZSwgcGFyZW50U3BhbklkIH0gPSBzcGFuO1xuXG4gIGNvbnN0IHsgb3AsIGRlc2NyaXB0aW9uLCBkYXRhLCBvcmlnaW4gPSAnbWFudWFsJyB9ID0gZ2V0U3BhbkRhdGEoc3Bhbik7XG4gIGNvbnN0IGFsbERhdGEgPSB1dGlscy5kcm9wVW5kZWZpbmVkS2V5cyh7XG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUklHSU5dOiBvcmlnaW4sXG4gICAgW2NvcmUuU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9PUF06IG9wLFxuICAgIC4uLnJlbW92ZVNlbnRyeUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgLi4uZGF0YSxcbiAgfSk7XG5cbiAgY29uc3Qgc3RhdHVzID0gbWFwU3RhdHVzKHNwYW4pO1xuXG4gIGNvbnN0IHNwYW5KU09OID0gdXRpbHMuZHJvcFVuZGVmaW5lZEtleXMoe1xuICAgIHNwYW5faWQsXG4gICAgdHJhY2VfaWQsXG4gICAgZGF0YTogYWxsRGF0YSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBwYXJlbnRfc3Bhbl9pZDogcGFyZW50U3BhbklkLFxuICAgIHN0YXJ0X3RpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKHN0YXJ0VGltZSksXG4gICAgLy8gVGhpcyBpcyBbMCwwXSBieSBkZWZhdWx0IGluIE9URUwsIGluIHdoaWNoIGNhc2Ugd2Ugd2FudCB0byBpbnRlcnByZXQgdGhpcyBhcyBubyBlbmQgdGltZVxuICAgIHRpbWVzdGFtcDogY29yZS5zcGFuVGltZUlucHV0VG9TZWNvbmRzKGVuZFRpbWUpIHx8IHVuZGVmaW5lZCxcbiAgICBzdGF0dXM6IGNvcmUuZ2V0U3RhdHVzTWVzc2FnZShzdGF0dXMpLCAvLyBBcyBwZXIgcHJvdG9jb2wsIHNwYW4gc3RhdHVzIGlzIGFsbG93ZWQgdG8gYmUgdW5kZWZpbmVkXG4gICAgb3AsXG4gICAgb3JpZ2luLFxuICAgIF9tZXRyaWNzX3N1bW1hcnk6IGNvcmUuZ2V0TWV0cmljU3VtbWFyeUpzb25Gb3JTcGFuKHNwYW4gKSxcbiAgICBtZWFzdXJlbWVudHM6IGNvcmUudGltZWRFdmVudHNUb01lYXN1cmVtZW50cyhzcGFuLmV2ZW50cyksXG4gIH0pO1xuXG4gIHNwYW5zLnB1c2goc3BhbkpTT04pO1xuXG4gIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgY3JlYXRlQW5kRmluaXNoU3BhbkZvck90ZWxTcGFuKGNoaWxkLCBzcGFucywgcmVtYWluaW5nKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNwYW5EYXRhKHNwYW4pXG5cbiB7XG4gIGNvbnN0IHsgb3A6IGRlZmluZWRPcCwgc291cmNlOiBkZWZpbmVkU291cmNlLCBvcmlnaW4gfSA9IHBhcnNlU3BhbihzcGFuKTtcbiAgY29uc3QgeyBvcDogaW5mZXJyZWRPcCwgZGVzY3JpcHRpb24sIHNvdXJjZTogaW5mZXJyZWRTb3VyY2UsIGRhdGE6IGluZmVycmVkRGF0YSB9ID0gcGFyc2VTcGFuRGVzY3JpcHRpb24oc3Bhbik7XG5cbiAgY29uc3Qgb3AgPSBkZWZpbmVkT3AgfHwgaW5mZXJyZWRPcDtcbiAgY29uc3Qgc291cmNlID0gZGVmaW5lZFNvdXJjZSB8fCBpbmZlcnJlZFNvdXJjZTtcblxuICBjb25zdCBkYXRhID0geyAuLi5pbmZlcnJlZERhdGEsIC4uLmdldERhdGEoc3BhbikgfTtcblxuICByZXR1cm4ge1xuICAgIG9wLFxuICAgIGRlc2NyaXB0aW9uLFxuICAgIHNvdXJjZSxcbiAgICBvcmlnaW4sXG4gICAgZGF0YSxcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgY3VzdG9tIGBzZW50cnkuYCBhdHRyaWJ0dWVzIHdlIGRvIG5vdCBuZWVkIHRvIHNlbmQuXG4gKiBUaGVzZSBhcmUgbW9yZSBjYXJyaWVyIGF0dHJpYnV0ZXMgd2UgdXNlIGluc2lkZSBvZiB0aGUgU0RLLCB3ZSBkbyBub3QgbmVlZCB0byBzZW5kIHRoZW0gdG8gdGhlIEFQSS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlU2VudHJ5QXR0cmlidXRlcyhkYXRhKSB7XG4gIGNvbnN0IGNsZWFuZWREYXRhID0geyAuLi5kYXRhIH07XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWR5bmFtaWMtZGVsZXRlICovXG4gIGRlbGV0ZSBjbGVhbmVkRGF0YVtjb3JlLlNFTUFOVElDX0FUVFJJQlVURV9TRU5UUllfU0FNUExFX1JBVEVdO1xuICBkZWxldGUgY2xlYW5lZERhdGFbU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFXTtcbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZHluYW1pYy1kZWxldGUgKi9cblxuICByZXR1cm4gY2xlYW5lZERhdGE7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoc3Bhbikge1xuICBjb25zdCBhdHRyaWJ1dGVzID0gc3Bhbi5hdHRyaWJ1dGVzO1xuICBjb25zdCBkYXRhID0ge1xuICAgICdvdGVsLmtpbmQnOiBhcGkuU3BhbktpbmRbc3Bhbi5raW5kXSxcbiAgfTtcblxuICBpZiAoYXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfU1RBVFVTX0NPREVdKSB7XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX1NUQVRVU19DT0RFXSA7XG4gICAgZGF0YVsnaHR0cC5yZXNwb25zZS5zdGF0dXNfY29kZSddID0gc3RhdHVzQ29kZTtcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3REYXRhID0gZ2V0UmVxdWVzdFNwYW5EYXRhKHNwYW4pO1xuXG4gIGlmIChyZXF1ZXN0RGF0YS51cmwpIHtcbiAgICBkYXRhLnVybCA9IHJlcXVlc3REYXRhLnVybDtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0RGF0YVsnaHR0cC5xdWVyeSddKSB7XG4gICAgZGF0YVsnaHR0cC5xdWVyeSddID0gcmVxdWVzdERhdGFbJ2h0dHAucXVlcnknXS5zbGljZSgxKTtcbiAgfVxuICBpZiAocmVxdWVzdERhdGFbJ2h0dHAuZnJhZ21lbnQnXSkge1xuICAgIGRhdGFbJ2h0dHAuZnJhZ21lbnQnXSA9IHJlcXVlc3REYXRhWydodHRwLmZyYWdtZW50J10uc2xpY2UoMSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gX29wdGlvbmFsQ2hhaW4kMShvcHMpIHsgbGV0IGxhc3RBY2Nlc3NMSFMgPSB1bmRlZmluZWQ7IGxldCB2YWx1ZSA9IG9wc1swXTsgbGV0IGkgPSAxOyB3aGlsZSAoaSA8IG9wcy5sZW5ndGgpIHsgY29uc3Qgb3AgPSBvcHNbaV07IGNvbnN0IGZuID0gb3BzW2kgKyAxXTsgaSArPSAyOyBpZiAoKG9wID09PSAnb3B0aW9uYWxBY2Nlc3MnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgJiYgdmFsdWUgPT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGlmIChvcCA9PT0gJ2FjY2VzcycgfHwgb3AgPT09ICdvcHRpb25hbEFjY2VzcycpIHsgbGFzdEFjY2Vzc0xIUyA9IHZhbHVlOyB2YWx1ZSA9IGZuKHZhbHVlKTsgfSBlbHNlIGlmIChvcCA9PT0gJ2NhbGwnIHx8IG9wID09PSAnb3B0aW9uYWxDYWxsJykgeyB2YWx1ZSA9IGZuKCguLi5hcmdzKSA9PiB2YWx1ZS5jYWxsKGxhc3RBY2Nlc3NMSFMsIC4uLmFyZ3MpKTsgbGFzdEFjY2Vzc0xIUyA9IHVuZGVmaW5lZDsgfSB9IHJldHVybiB2YWx1ZTsgfVxuXG5mdW5jdGlvbiBvblNwYW5TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KSB7XG4gIC8vIFRoaXMgaXMgYSByZWxpYWJsZSB3YXkgdG8gZ2V0IHRoZSBwYXJlbnQgc3BhbiAtIGJlY2F1c2UgdGhpcyBpcyBleGFjdGx5IGhvdyB0aGUgcGFyZW50IGlzIGlkZW50aWZpZWQgaW4gdGhlIE9URUwgU0RLXG4gIGNvbnN0IHBhcmVudFNwYW4gPSBhcGkudHJhY2UuZ2V0U3BhbihwYXJlbnRDb250ZXh0KTtcblxuICBsZXQgc2NvcGVzID0gZ2V0U2NvcGVzRnJvbUNvbnRleHQocGFyZW50Q29udGV4dCk7XG5cbiAgLy8gV2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHBhcmVudCBzcGFuIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gbW92ZSB1cCB0aGUgc3BhbiB0cmVlIGZvciBicmVhZGNydW1ic1xuICBpZiAocGFyZW50U3BhbiAmJiAhcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgY29yZS5hZGRDaGlsZFNwYW5Ub1NwYW4ocGFyZW50U3Bhbiwgc3Bhbik7XG4gIH1cblxuICAvLyBXZSBuZWVkIHRoaXMgaW4gdGhlIHNwYW4gZXhwb3J0ZXJcbiAgaWYgKHBhcmVudFNwYW4gJiYgcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpLmlzUmVtb3RlKSB7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoU0VNQU5USUNfQVRUUklCVVRFX1NFTlRSWV9QQVJFTlRfSVNfUkVNT1RFLCB0cnVlKTtcbiAgfVxuXG4gIC8vIFRoZSByb290IGNvbnRleHQgZG9lcyBub3QgaGF2ZSBzY29wZXMgc3RvcmVkLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBzcGVjaWZpY2FsbHlcbiAgLy8gQXMgZmFsbGJhY2sgd2UgYXR0YWNoIHRoZSBnbG9iYWwgc2NvcGVzXG4gIGlmIChwYXJlbnRDb250ZXh0ID09PSBhcGkuUk9PVF9DT05URVhUKSB7XG4gICAgc2NvcGVzID0ge1xuICAgICAgc2NvcGU6IGNvcmUuZ2V0RGVmYXVsdEN1cnJlbnRTY29wZSgpLFxuICAgICAgaXNvbGF0aW9uU2NvcGU6IGNvcmUuZ2V0RGVmYXVsdElzb2xhdGlvblNjb3BlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdGhlIHNjb3BlIGF0IHRpbWUgb2Ygc3BhbiBjcmVhdGlvbiBpbiBvcmRlciB0byBhcHBseSBpdCB0byB0aGUgZXZlbnQgd2hlbiB0aGUgc3BhbiBpcyBmaW5pc2hlZFxuICBpZiAoc2NvcGVzKSB7XG4gICAgY29yZS5zZXRDYXB0dXJlZFNjb3Blc09uU3BhbihzcGFuLCBzY29wZXMuc2NvcGUsIHNjb3Blcy5pc29sYXRpb25TY29wZSk7XG4gIH1cblxuICBjb3JlLmxvZ1NwYW5TdGFydChzcGFuKTtcblxuICBjb25zdCBjbGllbnQgPSBjb3JlLmdldENsaWVudCgpO1xuICBfb3B0aW9uYWxDaGFpbiQxKFtjbGllbnQsICdvcHRpb25hbEFjY2VzcycsIF8gPT4gXy5lbWl0LCAnY2FsbCcsIF8yID0+IF8yKCdzcGFuU3RhcnQnLCBzcGFuKV0pO1xufVxuXG5mdW5jdGlvbiBvblNwYW5FbmQoc3Bhbikge1xuICBjb3JlLmxvZ1NwYW5FbmQoc3Bhbik7XG5cbiAgY29uc3QgY2xpZW50ID0gY29yZS5nZXRDbGllbnQoKTtcbiAgX29wdGlvbmFsQ2hhaW4kMShbY2xpZW50LCAnb3B0aW9uYWxBY2Nlc3MnLCBfMyA9PiBfMy5lbWl0LCAnY2FsbCcsIF80ID0+IF80KCdzcGFuRW5kJywgc3BhbildKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBPcGVuVGVsZW1ldHJ5IFNwYW5zIHRvIFNlbnRyeSBTcGFucyBhbmQgc2VuZHMgdGhlbSB0byBTZW50cnkgdmlhXG4gKiB0aGUgU2VudHJ5IFNESy5cbiAqL1xuY2xhc3MgU2VudHJ5U3BhblByb2Nlc3NvciAge1xuXG4gICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc2V0SXNTZXR1cCgnU2VudHJ5U3BhblByb2Nlc3NvcicpO1xuICAgIHRoaXMuX2V4cG9ydGVyID0gbmV3IFNlbnRyeVNwYW5FeHBvcnRlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFzeW5jIGZvcmNlRmx1c2goKSB7XG4gICAgdGhpcy5fZXhwb3J0ZXIuZmx1c2goKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgIGFzeW5jIHNodXRkb3duKCkge1xuICAgIHRoaXMuX2V4cG9ydGVyLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gICBvblN0YXJ0KHNwYW4sIHBhcmVudENvbnRleHQpIHtcbiAgICBvblNwYW5TdGFydChzcGFuLCBwYXJlbnRDb250ZXh0KTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgb25FbmQoc3Bhbikge1xuICAgIG9uU3BhbkVuZChzcGFuKTtcblxuICAgIHRoaXMuX2V4cG9ydGVyLmV4cG9ydChzcGFuKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgY3VzdG9tIE9URUwgc2FtcGxlciB0aGF0IHVzZXMgU2VudHJ5IHNhbXBsaW5nIHJhdGVzIHRvIG1ha2UgaXRzIGRlY2lzaW9uXG4gKi9cbmNsYXNzIFNlbnRyeVNhbXBsZXIgIHtcblxuICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgdGhpcy5fY2xpZW50ID0gY2xpZW50O1xuICAgIHNldElzU2V0dXAoJ1NlbnRyeVNhbXBsZXInKTtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgc2hvdWxkU2FtcGxlKFxuICAgIGNvbnRleHQsXG4gICAgdHJhY2VJZCxcbiAgICBzcGFuTmFtZSxcbiAgICBzcGFuS2luZCxcbiAgICBzcGFuQXR0cmlidXRlcyxcbiAgICBfbGlua3MsXG4gICkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9jbGllbnQuZ2V0T3B0aW9ucygpO1xuXG4gICAgY29uc3QgcGFyZW50U3BhbiA9IGFwaS50cmFjZS5nZXRTcGFuKGNvbnRleHQpO1xuICAgIGNvbnN0IHBhcmVudENvbnRleHQgPSBfb3B0aW9uYWxDaGFpbihbcGFyZW50U3BhbiwgJ29wdGlvbmFsQWNjZXNzJywgXyA9PiBfLnNwYW5Db250ZXh0LCAnY2FsbCcsIF8yID0+IF8yKCldKTtcblxuICAgIGlmICghY29yZS5oYXNUcmFjaW5nRW5hYmxlZChvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIGh0dHAuY2xpZW50IHNwYW4gdGhhdCBoYXMgbm8gbG9jYWwgcGFyZW50LCB3ZSBuZXZlciB3YW50IHRvIHNhbXBsZSBpdFxuICAgIC8vIGJ1dCB3ZSB3YW50IHRvIGxlYXZlIGRvd25zdHJlYW0gc2FtcGxpbmcgZGVjaXNpb25zIHVwIHRvIHRoZSBzZXJ2ZXJcbiAgICBpZiAoXG4gICAgICBzcGFuS2luZCA9PT0gYXBpLlNwYW5LaW5kLkNMSUVOVCAmJlxuICAgICAgc3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF0gJiZcbiAgICAgICghcGFyZW50U3BhbiB8fCBfb3B0aW9uYWxDaGFpbihbcGFyZW50Q29udGV4dCwgJ29wdGlvbmFsQWNjZXNzJywgXzMgPT4gXzMuaXNSZW1vdGVdKSlcbiAgICApIHtcbiAgICAgIHJldHVybiB3cmFwU2FtcGxpbmdEZWNpc2lvbih7IGRlY2lzaW9uOiB1bmRlZmluZWQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBwYXJlbnRTcGFuID8gZ2V0UGFyZW50U2FtcGxlZChwYXJlbnRTcGFuLCB0cmFjZUlkLCBzcGFuTmFtZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbiA9IHsgZGVjaXNpb246IHRydWUgfTtcbiAgICB0aGlzLl9jbGllbnQuZW1pdChcbiAgICAgICdiZWZvcmVTYW1wbGluZycsXG4gICAgICB7XG4gICAgICAgIHNwYW5BdHRyaWJ1dGVzOiBzcGFuQXR0cmlidXRlcyxcbiAgICAgICAgc3Bhbk5hbWU6IHNwYW5OYW1lLFxuICAgICAgICBwYXJlbnRTYW1wbGVkOiBwYXJlbnRTYW1wbGVkLFxuICAgICAgICBwYXJlbnRDb250ZXh0OiBwYXJlbnRDb250ZXh0LFxuICAgICAgfSxcbiAgICAgIG11dGFibGVTYW1wbGluZ0RlY2lzaW9uLFxuICAgICk7XG4gICAgaWYgKCFtdXRhYmxlU2FtcGxpbmdEZWNpc2lvbi5kZWNpc2lvbikge1xuICAgICAgcmV0dXJuIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHVuZGVmaW5lZCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgW3NhbXBsZWQsIHNhbXBsZVJhdGVdID0gY29yZS5zYW1wbGVTcGFuKG9wdGlvbnMsIHtcbiAgICAgIG5hbWU6IHNwYW5OYW1lLFxuICAgICAgYXR0cmlidXRlczogc3BhbkF0dHJpYnV0ZXMsXG4gICAgICB0cmFuc2FjdGlvbkNvbnRleHQ6IHtcbiAgICAgICAgbmFtZTogc3Bhbk5hbWUsXG4gICAgICAgIHBhcmVudFNhbXBsZWQsXG4gICAgICB9LFxuICAgICAgcGFyZW50U2FtcGxlZCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7XG4gICAgICBbY29yZS5TRU1BTlRJQ19BVFRSSUJVVEVfU0VOVFJZX1NBTVBMRV9SQVRFXTogc2FtcGxlUmF0ZSxcbiAgICB9O1xuXG4gICAgY29uc3QgbWV0aG9kID0gYCR7c3BhbkF0dHJpYnV0ZXNbc2VtYW50aWNDb252ZW50aW9ucy5TRU1BVFRSU19IVFRQX01FVEhPRF19YC50b1VwcGVyQ2FzZSgpO1xuICAgIGlmIChtZXRob2QgPT09ICdPUFRJT05TJyB8fCBtZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgREVCVUdfQlVJTEQgJiYgdXRpbHMubG9nZ2VyLmxvZyhgW1RyYWNpbmddIE5vdCBzYW1wbGluZyBzcGFuIGJlY2F1c2UgSFRUUCBtZXRob2QgaXMgJyR7bWV0aG9kfScgZm9yICR7c3Bhbk5hbWV9YCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLndyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pLFxuICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXNhbXBsZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLndyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsIGNvbnRleHQsIHNwYW5BdHRyaWJ1dGVzIH0pLFxuICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLndyYXBTYW1wbGluZ0RlY2lzaW9uKHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLlJFQ09SRF9BTkRfU0FNUExFRCwgY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMgfSksXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgIH07XG4gIH1cblxuICAvKiogUmV0dXJucyB0aGUgc2FtcGxlciBuYW1lIG9yIHNob3J0IGRlc2NyaXB0aW9uIHdpdGggdGhlIGNvbmZpZ3VyYXRpb24uICovXG4gICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NlbnRyeVNhbXBsZXInO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFJlbW90ZVNhbXBsZWQocGFyZW50U3Bhbikge1xuICBjb25zdCB0cmFjZUlkID0gcGFyZW50U3Bhbi5zcGFuQ29udGV4dCgpLnRyYWNlSWQ7XG4gIGNvbnN0IHRyYWNlcGFyZW50RGF0YSA9IGdldFByb3BhZ2F0aW9uQ29udGV4dEZyb21TcGFuKHBhcmVudFNwYW4pO1xuXG4gIC8vIE9ubHkgaW5oZXJpdCBzYW1wbGVkIGlmIGB0cmFjZUlkYCBpcyB0aGUgc2FtZVxuICByZXR1cm4gdHJhY2VwYXJlbnREYXRhICYmIHRyYWNlSWQgPT09IHRyYWNlcGFyZW50RGF0YS50cmFjZUlkID8gdHJhY2VwYXJlbnREYXRhLnNhbXBsZWQgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFNhbXBsZWQocGFyZW50U3BhbiwgdHJhY2VJZCwgc3Bhbk5hbWUpIHtcbiAgY29uc3QgcGFyZW50Q29udGV4dCA9IHBhcmVudFNwYW4uc3BhbkNvbnRleHQoKTtcblxuICAvLyBPbmx5IGluaGVyaXQgc2FtcGxlIHJhdGUgaWYgYHRyYWNlSWRgIGlzIHRoZSBzYW1lXG4gIC8vIE5vdGUgZm9yIHRlc3Rpbmc6IGBpc1NwYW5Db250ZXh0VmFsaWQoKWAgY2hlY2tzIHRoZSBmb3JtYXQgb2YgdGhlIHRyYWNlSWQvc3BhbklkLCBzbyB3ZSBuZWVkIHRvIHBhc3MgdmFsaWQgb25lc1xuICBpZiAoYXBpLmlzU3BhbkNvbnRleHRWYWxpZChwYXJlbnRDb250ZXh0KSAmJiBwYXJlbnRDb250ZXh0LnRyYWNlSWQgPT09IHRyYWNlSWQpIHtcbiAgICBpZiAocGFyZW50Q29udGV4dC5pc1JlbW90ZSkge1xuICAgICAgY29uc3QgcGFyZW50U2FtcGxlZCA9IGdldFBhcmVudFJlbW90ZVNhbXBsZWQocGFyZW50U3Bhbik7XG4gICAgICBERUJVR19CVUlMRCAmJlxuICAgICAgICB1dGlscy5sb2dnZXIubG9nKGBbVHJhY2luZ10gSW5oZXJpdGluZyByZW1vdGUgcGFyZW50J3Mgc2FtcGxlZCBkZWNpc2lvbiBmb3IgJHtzcGFuTmFtZX06ICR7cGFyZW50U2FtcGxlZH1gKTtcbiAgICAgIHJldHVybiBwYXJlbnRTYW1wbGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudFNhbXBsZWQgPSBnZXRTYW1wbGluZ0RlY2lzaW9uKHBhcmVudENvbnRleHQpO1xuICAgIERFQlVHX0JVSUxEICYmIHV0aWxzLmxvZ2dlci5sb2coYFtUcmFjaW5nXSBJbmhlcml0aW5nIHBhcmVudCdzIHNhbXBsZWQgZGVjaXNpb24gZm9yICR7c3Bhbk5hbWV9OiAke3BhcmVudFNhbXBsZWR9YCk7XG4gICAgcmV0dXJuIHBhcmVudFNhbXBsZWQ7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFdyYXAgYSBzYW1wbGluZyBkZWNpc2lvbiB3aXRoIGRhdGEgdGhhdCBTZW50cnkgbmVlZHMgdG8gd29yayBwcm9wZXJseSB3aXRoIGl0LlxuICogSWYgeW91IHBhc3MgYGRlY2lzaW9uOiB1bmRlZmluZWRgLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYE5PVF9SRUNPUkRJTkdgLCBidXQgaW4gY29udHJhc3QgdG8gcGFzc2luZyBgTk9UX1JFQ09SRElOR2BcbiAqIGl0IHdpbGwgbm90IHByb3BhZ2F0ZSB0aGlzIGRlY2lzaW9uIHRvIGRvd25zdHJlYW0gU2VudHJ5IFNES3MuXG4gKi9cbmZ1bmN0aW9uIHdyYXBTYW1wbGluZ0RlY2lzaW9uKHtcbiAgZGVjaXNpb24sXG4gIGNvbnRleHQsXG4gIHNwYW5BdHRyaWJ1dGVzLFxufSkge1xuICBjb25zdCB0cmFjZVN0YXRlID0gZ2V0QmFzZVRyYWNlU3RhdGUoY29udGV4dCwgc3BhbkF0dHJpYnV0ZXMpO1xuXG4gIC8vIElmIHRoZSBkZWNpc2lvbiBpcyB1bmRlZmluZWQsIHdlIHRyZWF0IGl0IGFzIE5PVF9SRUNPUkRJTkcsIGJ1dCB3ZSBkb24ndCBwcm9wYWdhdGUgdGhpcyBkZWNpc2lvbiB0byBkb3duc3RyZWFtIFNES3NcbiAgLy8gV2hpY2ggaXMgZG9uZSBieSBub3Qgc2V0dGluZyBgU0VOVFJZX1RSQUNFX1NUQVRFX1NBTVBMRURfTk9UX1JFQ09SRElOR2AgdHJhY2VTdGF0ZVxuICBpZiAoZGVjaXNpb24gPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHsgZGVjaXNpb246IHNka1RyYWNlQmFzZS5TYW1wbGluZ0RlY2lzaW9uLk5PVF9SRUNPUkQsIHRyYWNlU3RhdGUgfTtcbiAgfVxuXG4gIGlmIChkZWNpc2lvbiA9PT0gc2RrVHJhY2VCYXNlLlNhbXBsaW5nRGVjaXNpb24uTk9UX1JFQ09SRCkge1xuICAgIHJldHVybiB7IGRlY2lzaW9uLCB0cmFjZVN0YXRlOiB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfU0FNUExFRF9OT1RfUkVDT1JESU5HLCAnMScpIH07XG4gIH1cblxuICByZXR1cm4geyBkZWNpc2lvbiwgdHJhY2VTdGF0ZSB9O1xufVxuXG5mdW5jdGlvbiBnZXRCYXNlVHJhY2VTdGF0ZShjb250ZXh0LCBzcGFuQXR0cmlidXRlcykge1xuICBjb25zdCBwYXJlbnRTcGFuID0gYXBpLnRyYWNlLmdldFNwYW4oY29udGV4dCk7XG4gIGNvbnN0IHBhcmVudENvbnRleHQgPSBfb3B0aW9uYWxDaGFpbihbcGFyZW50U3BhbiwgJ29wdGlvbmFsQWNjZXNzJywgXzQgPT4gXzQuc3BhbkNvbnRleHQsICdjYWxsJywgXzUgPT4gXzUoKV0pO1xuXG4gIGxldCB0cmFjZVN0YXRlID0gX29wdGlvbmFsQ2hhaW4oW3BhcmVudENvbnRleHQsICdvcHRpb25hbEFjY2VzcycsIF82ID0+IF82LnRyYWNlU3RhdGVdKSB8fCBuZXcgY29yZSQxLlRyYWNlU3RhdGUoKTtcblxuICAvLyBXZSBhbHdheXMga2VlcCB0aGUgVVJMIG9uIHRoZSB0cmFjZSBzdGF0ZSwgc28gd2UgY2FuIGFjY2VzcyBpdCBpbiB0aGUgcHJvcGFnYXRvclxuICBjb25zdCB1cmwgPSBzcGFuQXR0cmlidXRlc1tzZW1hbnRpY0NvbnZlbnRpb25zLlNFTUFUVFJTX0hUVFBfVVJMXTtcbiAgaWYgKHVybCAmJiB0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgIHRyYWNlU3RhdGUgPSB0cmFjZVN0YXRlLnNldChTRU5UUllfVFJBQ0VfU1RBVEVfVVJMLCB1cmwpO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNlU3RhdGU7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgYW4gT3BlblRlbGVtZXRyeSBpbnN0cnVtZW50YXRpb24gb3JcbiAqIGFycmF5IG9mIGluc3RydW1lbnRhdGlvbnMgYW5kIHJlZ2lzdGVycyB0aGVtIHdpdGggT3BlblRlbGVtZXRyeS5cbiAqL1xuZnVuY3Rpb24gYWRkT3BlblRlbGVtZXRyeUluc3RydW1lbnRhdGlvbiguLi5pbnN0cnVtZW50YXRpb25zKSB7XG4gIGluc3RydW1lbnRhdGlvbi5yZWdpc3Rlckluc3RydW1lbnRhdGlvbnMoe1xuICAgIGluc3RydW1lbnRhdGlvbnMsXG4gIH0pO1xufVxuXG5leHBvcnRzLmdldENsaWVudCA9IGNvcmUuZ2V0Q2xpZW50O1xuZXhwb3J0cy5nZXRDdXJyZW50SHViU2hpbSA9IGNvcmUuZ2V0Q3VycmVudEh1YlNoaW07XG5leHBvcnRzLmdldER5bmFtaWNTYW1wbGluZ0NvbnRleHRGcm9tU3BhbiA9IGNvcmUuZ2V0RHluYW1pY1NhbXBsaW5nQ29udGV4dEZyb21TcGFuO1xuZXhwb3J0cy5TZW50cnlQcm9wYWdhdG9yID0gU2VudHJ5UHJvcGFnYXRvcjtcbmV4cG9ydHMuU2VudHJ5U2FtcGxlciA9IFNlbnRyeVNhbXBsZXI7XG5leHBvcnRzLlNlbnRyeVNwYW5Qcm9jZXNzb3IgPSBTZW50cnlTcGFuUHJvY2Vzc29yO1xuZXhwb3J0cy5hZGRPcGVuVGVsZW1ldHJ5SW5zdHJ1bWVudGF0aW9uID0gYWRkT3BlblRlbGVtZXRyeUluc3RydW1lbnRhdGlvbjtcbmV4cG9ydHMuY29udGludWVUcmFjZSA9IGNvbnRpbnVlVHJhY2U7XG5leHBvcnRzLmVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZSA9IGVuaGFuY2VEc2NXaXRoT3BlblRlbGVtZXRyeVJvb3RTcGFuTmFtZTtcbmV4cG9ydHMuZ2V0QWN0aXZlU3BhbiA9IGdldEFjdGl2ZVNwYW47XG5leHBvcnRzLmdldFJlcXVlc3RTcGFuRGF0YSA9IGdldFJlcXVlc3RTcGFuRGF0YTtcbmV4cG9ydHMuZ2V0U2NvcGVzRnJvbUNvbnRleHQgPSBnZXRTY29wZXNGcm9tQ29udGV4dDtcbmV4cG9ydHMuZ2V0U3BhbktpbmQgPSBnZXRTcGFuS2luZDtcbmV4cG9ydHMuaXNTZW50cnlSZXF1ZXN0U3BhbiA9IGlzU2VudHJ5UmVxdWVzdFNwYW47XG5leHBvcnRzLm9wZW5UZWxlbWV0cnlTZXR1cENoZWNrID0gb3BlblRlbGVtZXRyeVNldHVwQ2hlY2s7XG5leHBvcnRzLnNldE9wZW5UZWxlbWV0cnlDb250ZXh0QXN5bmNDb250ZXh0U3RyYXRlZ3kgPSBzZXRPcGVuVGVsZW1ldHJ5Q29udGV4dEFzeW5jQ29udGV4dFN0cmF0ZWd5O1xuZXhwb3J0cy5zZXR1cEV2ZW50Q29udGV4dFRyYWNlID0gc2V0dXBFdmVudENvbnRleHRUcmFjZTtcbmV4cG9ydHMuc3Bhbkhhc0F0dHJpYnV0ZXMgPSBzcGFuSGFzQXR0cmlidXRlcztcbmV4cG9ydHMuc3Bhbkhhc0V2ZW50cyA9IHNwYW5IYXNFdmVudHM7XG5leHBvcnRzLnNwYW5IYXNLaW5kID0gc3Bhbkhhc0tpbmQ7XG5leHBvcnRzLnNwYW5IYXNOYW1lID0gc3Bhbkhhc05hbWU7XG5leHBvcnRzLnNwYW5IYXNQYXJlbnRJZCA9IHNwYW5IYXNQYXJlbnRJZDtcbmV4cG9ydHMuc3Bhbkhhc1N0YXR1cyA9IHNwYW5IYXNTdGF0dXM7XG5leHBvcnRzLnN0YXJ0SW5hY3RpdmVTcGFuID0gc3RhcnRJbmFjdGl2ZVNwYW47XG5leHBvcnRzLnN0YXJ0U3BhbiA9IHN0YXJ0U3BhbjtcbmV4cG9ydHMuc3RhcnRTcGFuTWFudWFsID0gc3RhcnRTcGFuTWFudWFsO1xuZXhwb3J0cy5zdXBwcmVzc1RyYWNpbmcgPSBzdXBwcmVzc1RyYWNpbmc7XG5leHBvcnRzLndpdGhBY3RpdmVTcGFuID0gd2l0aEFjdGl2ZVNwYW47XG5leHBvcnRzLndyYXBDbGllbnRDbGFzcyA9IHdyYXBDbGllbnRDbGFzcztcbmV4cG9ydHMud3JhcENvbnRleHRNYW5hZ2VyQ2xhc3MgPSB3cmFwQ29udGV4dE1hbmFnZXJDbGFzcztcbmV4cG9ydHMud3JhcFNhbXBsaW5nRGVjaXNpb24gPSB3cmFwU2FtcGxpbmdEZWNpc2lvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@sentry+opentelemetry@8.17.0_@opentelemetry+api@1.9.0_@opentelemetry+core@1.25.1_@opentelemet_ow7c37dm3l4bymc7i4etipzmaa/node_modules/@sentry/opentelemetry/build/cjs/index.js\n");

/***/ })

};
;